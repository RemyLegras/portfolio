/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Rl = "138",
  Ui = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  zi = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  ff = 0,
  vc = 1,
  pf = 2,
  mu = 1,
  mf = 2,
  rs = 3,
  gr = 0,
  Ut = 1,
  Li = 2,
  gu = 1,
  ci = 0,
  fr = 1,
  To = 2,
  xc = 3,
  yc = 4,
  gf = 5,
  sr = 100,
  vf = 101,
  xf = 102,
  _c = 103,
  wc = 104,
  yf = 200,
  _f = 201,
  wf = 202,
  bf = 203,
  vu = 204,
  xu = 205,
  Mf = 206,
  Sf = 207,
  Tf = 208,
  Ef = 209,
  Af = 210,
  Cf = 0,
  Rf = 1,
  Lf = 2,
  Ja = 3,
  Pf = 4,
  If = 5,
  Df = 6,
  Ff = 7,
  ko = 0,
  Nf = 1,
  Bf = 2,
  hi = 0,
  Of = 1,
  Uf = 2,
  zf = 3,
  kf = 4,
  Hf = 5,
  yu = 300,
  vr = 301,
  xr = 302,
  Eo = 303,
  Qa = 304,
  Ho = 306,
  Ll = 307,
  pi = 1e3,
  Zt = 1001,
  Ao = 1002,
  zt = 1003,
  el = 1004,
  tl = 1005,
  st = 1006,
  _u = 1007,
  yi = 1008,
  mi = 1009,
  Gf = 1010,
  Vf = 1011,
  ds = 1012,
  Wf = 1013,
  yo = 1014,
  tn = 1015,
  nn = 1016,
  Xf = 1017,
  jf = 1018,
  pr = 1020,
  qf = 1021,
  Yf = 1022,
  Nt = 1023,
  Zf = 1024,
  $f = 1025,
  Ri = 1026,
  yr = 1027,
  wu = 1028,
  Kf = 1029,
  Jf = 1030,
  Qf = 1031,
  ep = 1033,
  _o = 33776,
  ra = 33777,
  sa = 33778,
  wo = 33779,
  nl = 35840,
  bc = 35841,
  il = 35842,
  Mc = 35843,
  bu = 36196,
  rl = 37492,
  sl = 37496,
  ol = 37808,
  Sc = 37809,
  Tc = 37810,
  Ec = 37811,
  Ac = 37812,
  Cc = 37813,
  Rc = 37814,
  Lc = 37815,
  Pc = 37816,
  Ic = 37817,
  Dc = 37818,
  Fc = 37819,
  Nc = 37820,
  Bc = 37821,
  al = 36492,
  tp = 2200,
  np = 2201,
  ip = 2202,
  fs = 2300,
  _r = 2301,
  oa = 2302,
  lr = 2400,
  cr = 2401,
  Co = 2402,
  Pl = 2500,
  Mu = 2501,
  rp = 0,
  sp = 1,
  Su = 2,
  an = 3e3,
  it = 3001,
  op = 3200,
  ap = 3201,
  Ii = 0,
  lp = 1,
  aa = 7680,
  cp = 519,
  ps = 35044,
  Ro = 35048,
  Oc = "300 es",
  ll = 1035;
class _i {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
      e.target = null;
    }
  }
}
const Xt = [];
for (let s = 0; s < 256; s++) Xt[s] = (s < 16 ? "0" : "") + s.toString(16);
let Os = 1234567;
const os = Math.PI / 180,
  ms = 180 / Math.PI;
function gn() {
  const s = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Xt[s & 255] +
    Xt[(s >> 8) & 255] +
    Xt[(s >> 16) & 255] +
    Xt[(s >> 24) & 255] +
    "-" +
    Xt[e & 255] +
    Xt[(e >> 8) & 255] +
    "-" +
    Xt[((e >> 16) & 15) | 64] +
    Xt[(e >> 24) & 255] +
    "-" +
    Xt[(t & 63) | 128] +
    Xt[(t >> 8) & 255] +
    "-" +
    Xt[(t >> 16) & 255] +
    Xt[(t >> 24) & 255] +
    Xt[n & 255] +
    Xt[(n >> 8) & 255] +
    Xt[(n >> 16) & 255] +
    Xt[(n >> 24) & 255]
  ).toUpperCase();
}
function Kt(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function Il(s, e) {
  return ((s % e) + e) % e;
}
function hp(s, e, t, n, i) {
  return n + ((s - e) * (i - n)) / (t - e);
}
function up(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function as(s, e, t) {
  return (1 - t) * s + t * e;
}
function dp(s, e, t, n) {
  return as(s, e, 1 - Math.exp(-t * n));
}
function fp(s, e = 1) {
  return e - Math.abs(Il(s, e * 2) - e);
}
function pp(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * (3 - 2 * s));
}
function mp(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * s * (s * (s * 6 - 15) + 10));
}
function gp(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function vp(s, e) {
  return s + Math.random() * (e - s);
}
function xp(s) {
  return s * (0.5 - Math.random());
}
function yp(s) {
  return (
    s !== void 0 && (Os = s % 2147483647),
    (Os = (Os * 16807) % 2147483647),
    (Os - 1) / 2147483646
  );
}
function _p(s) {
  return s * os;
}
function wp(s) {
  return s * ms;
}
function cl(s) {
  return (s & (s - 1)) === 0 && s !== 0;
}
function Tu(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Lo(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function bp(s, e, t, n, i) {
  const r = Math.cos,
    o = Math.sin,
    a = r(t / 2),
    l = o(t / 2),
    c = r((e + n) / 2),
    h = o((e + n) / 2),
    u = r((e - n) / 2),
    d = o((e - n) / 2),
    f = r((n - e) / 2),
    m = o((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(a * h, l * u, l * d, a * c);
      break;
    case "YZY":
      s.set(l * d, a * h, l * u, a * c);
      break;
    case "ZXZ":
      s.set(l * u, l * d, a * h, a * c);
      break;
    case "XZX":
      s.set(a * h, l * m, l * f, a * c);
      break;
    case "YXY":
      s.set(l * f, a * h, l * m, a * c);
      break;
    case "ZYZ":
      s.set(l * m, l * f, a * h, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
var Sn = Object.freeze({
  __proto__: null,
  DEG2RAD: os,
  RAD2DEG: ms,
  generateUUID: gn,
  clamp: Kt,
  euclideanModulo: Il,
  mapLinear: hp,
  inverseLerp: up,
  lerp: as,
  damp: dp,
  pingpong: fp,
  smoothstep: pp,
  smootherstep: mp,
  randInt: gp,
  randFloat: vp,
  randFloatSpread: xp,
  seededRandom: yp,
  degToRad: _p,
  radToDeg: wp,
  isPowerOfTwo: cl,
  ceilPowerOfTwo: Tu,
  floorPowerOfTwo: Lo,
  setQuaternionFromProperEuler: bp,
});
class ae {
  constructor(e = 0, t = 0) {
    (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(e, t))
      : ((this.x += e.x), (this.y += e.y), this);
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(e, t))
      : ((this.x -= e.x), (this.y -= e.y), this);
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      this
    );
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = this.x - e.x,
      o = this.y - e.y;
    return (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
ae.prototype.isVector2 = !0;
class Gt {
  constructor() {
    (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(e, t, n, i, r, o, a, l, c) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = i),
      (h[2] = a),
      (h[3] = t),
      (h[4] = r),
      (h[5] = l),
      (h[6] = n),
      (h[7] = o),
      (h[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      o = n[0],
      a = n[3],
      l = n[6],
      c = n[1],
      h = n[4],
      u = n[7],
      d = n[2],
      f = n[5],
      m = n[8],
      v = i[0],
      y = i[3],
      p = i[6],
      g = i[1],
      w = i[4],
      b = i[7],
      _ = i[2],
      E = i[5],
      L = i[8];
    return (
      (r[0] = o * v + a * g + l * _),
      (r[3] = o * y + a * w + l * E),
      (r[6] = o * p + a * b + l * L),
      (r[1] = c * v + h * g + u * _),
      (r[4] = c * y + h * w + u * E),
      (r[7] = c * p + h * b + u * L),
      (r[2] = d * v + f * g + m * _),
      (r[5] = d * y + f * w + m * E),
      (r[8] = d * p + f * b + m * L),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8];
    return (
      t * o * h - t * a * c - n * r * h + n * a * l + i * r * c - i * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      u = h * o - a * c,
      d = a * l - h * r,
      f = c * r - o * l,
      m = t * u + n * d + i * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / m;
    return (
      (e[0] = u * v),
      (e[1] = (i * c - h * n) * v),
      (e[2] = (a * n - i * o) * v),
      (e[3] = d * v),
      (e[4] = (h * t - i * l) * v),
      (e[5] = (i * r - a * t) * v),
      (e[6] = f * v),
      (e[7] = (n * l - c * t) * v),
      (e[8] = (o * t - n * r) * v),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, r, o, a) {
    const l = Math.cos(r),
      c = Math.sin(r);
    return (
      this.set(
        n * l,
        n * c,
        -n * (l * o + c * a) + o + e,
        -i * c,
        i * l,
        -i * (-c * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[3] *= e),
      (n[6] *= e),
      (n[1] *= t),
      (n[4] *= t),
      (n[7] *= t),
      this
    );
  }
  rotate(e) {
    const t = Math.cos(e),
      n = Math.sin(e),
      i = this.elements,
      r = i[0],
      o = i[3],
      a = i[6],
      l = i[1],
      c = i[4],
      h = i[7];
    return (
      (i[0] = t * r + n * l),
      (i[3] = t * o + n * c),
      (i[6] = t * a + n * h),
      (i[1] = -n * r + t * l),
      (i[4] = -n * o + t * c),
      (i[7] = -n * a + t * h),
      this
    );
  }
  translate(e, t) {
    const n = this.elements;
    return (
      (n[0] += e * n[2]),
      (n[3] += e * n[5]),
      (n[6] += e * n[8]),
      (n[1] += t * n[2]),
      (n[4] += t * n[5]),
      (n[7] += t * n[8]),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Gt.prototype.isMatrix3 = !0;
function Eu(s) {
  for (let e = s.length - 1; e >= 0; --e) if (s[e] > 65535) return !0;
  return !1;
}
function gs(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
const Au = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  wn = { h: 0, s: 0, l: 0 },
  Us = { h: 0, s: 0, l: 0 };
function la(s, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? s + (e - s) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? s + (e - s) * 6 * (2 / 3 - t)
      : s
  );
}
function mr(s) {
  return s < 0.04045
    ? s * 0.0773993808
    : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function ca(s) {
  return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
class ye {
  constructor(e, t, n) {
    return t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n);
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      this
    );
  }
  setRGB(e, t, n) {
    return (this.r = e), (this.g = t), (this.b = n), this;
  }
  setHSL(e, t, n) {
    if (((e = Il(e, 1)), (t = Kt(t, 0, 1)), (n = Kt(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        r = 2 * n - i;
      (this.r = la(r, i, e + 1 / 3)),
        (this.g = la(r, i, e)),
        (this.b = la(r, i, e - 1 / 3));
    }
    return this;
  }
  setStyle(e) {
    function t(i) {
      i !== void 0 &&
        parseFloat(i) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let n;
    if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
      let i;
      const r = n[1],
        o = n[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (
            (i =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
              t(i[4]),
              this
            );
          if (
            (i =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
              t(i[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (i =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          ) {
            const a = parseFloat(i[1]) / 360,
              l = parseInt(i[2], 10) / 100,
              c = parseInt(i[3], 10) / 100;
            return t(i[4]), this.setHSL(a, l, c);
          }
          break;
      }
    } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const i = n[1],
        r = i.length;
      if (r === 3)
        return (
          (this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255),
          (this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255),
          (this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255),
          this
        );
      if (r === 6)
        return (
          (this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255),
          (this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255),
          (this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255),
          this
        );
    }
    return e && e.length > 0 ? this.setColorName(e) : this;
  }
  setColorName(e) {
    const t = Au[e.toLowerCase()];
    return (
      t !== void 0
        ? this.setHex(t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = mr(e.r)), (this.g = mr(e.g)), (this.b = mr(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = ca(e.r)), (this.g = ca(e.g)), (this.b = ca(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return (
      ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0)
    );
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      r = Math.max(t, n, i),
      o = Math.min(t, n, i);
    let a, l;
    const c = (o + r) / 2;
    if (o === r) (a = 0), (l = 0);
    else {
      const h = r - o;
      switch (((l = c <= 0.5 ? h / (r + o) : h / (2 - r - o)), r)) {
        case t:
          a = (n - i) / h + (n < i ? 6 : 0);
          break;
        case n:
          a = (i - t) / h + 2;
          break;
        case i:
          a = (t - n) / h + 4;
          break;
      }
      a /= 6;
    }
    return (e.h = a), (e.s = l), (e.l = c), e;
  }
  getStyle() {
    return (
      "rgb(" +
      ((this.r * 255) | 0) +
      "," +
      ((this.g * 255) | 0) +
      "," +
      ((this.b * 255) | 0) +
      ")"
    );
  }
  offsetHSL(e, t, n) {
    return (
      this.getHSL(wn),
      (wn.h += e),
      (wn.s += t),
      (wn.l += n),
      this.setHSL(wn.h, wn.s, wn.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(wn), e.getHSL(Us);
    const n = as(wn.h, Us.h, t),
      i = as(wn.s, Us.s, t),
      r = as(wn.l, Us.l, t);
    return this.setHSL(n, i, r), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)),
      (this.g = e.getY(t)),
      (this.b = e.getZ(t)),
      e.normalized === !0 &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
}
ye.NAMES = Au;
ye.prototype.isColor = !0;
ye.prototype.r = 1;
ye.prototype.g = 1;
ye.prototype.b = 1;
let ki;
class Di {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      ki === void 0 && (ki = gs("canvas")),
        (ki.width = e.width),
        (ki.height = e.height);
      const n = ki.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = ki);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement != "undefined" &&
        e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement != "undefined" &&
        e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
    ) {
      const t = gs("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        r = i.data;
      for (let o = 0; o < r.length; o++) r[o] = mr(r[o] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(mr(t[n] / 255) * 255))
          : (t[n] = mr(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
class Cu {
  constructor(e = null) {
    (this.uuid = gn()), (this.data = e), (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let r;
      if (Array.isArray(i)) {
        r = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? r.push(ha(i[o].image)) : r.push(ha(i[o]));
      } else r = ha(i);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function ha(s) {
  return (typeof HTMLImageElement != "undefined" &&
    s instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement != "undefined" &&
      s instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap != "undefined" && s instanceof ImageBitmap)
    ? Di.getDataURL(s)
    : s.data
    ? {
        data: Array.prototype.slice.call(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
Cu.prototype.isSource = !0;
let Mp = 0;
class At extends _i {
  constructor(
    e = At.DEFAULT_IMAGE,
    t = At.DEFAULT_MAPPING,
    n = Zt,
    i = Zt,
    r = st,
    o = yi,
    a = Nt,
    l = mi,
    c = 1,
    h = an
  ) {
    super();
    Object.defineProperty(this, "id", { value: Mp++ }),
      (this.uuid = gn()),
      (this.name = ""),
      (this.source = new Cu(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = r),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new ae(0, 0)),
      (this.repeat = new ae(1, 1)),
      (this.center = new ae(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Gt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== yu) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case pi:
          e.x = e.x - Math.floor(e.x);
          break;
        case Zt:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Ao:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case pi:
          e.y = e.y - Math.floor(e.y);
          break;
        case Zt:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Ao:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
}
At.DEFAULT_IMAGE = null;
At.DEFAULT_MAPPING = yu;
At.prototype.isTexture = !0;
class ct {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.x = e), (this.y = t), (this.z = n), (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(e, t))
      : ((this.x += e.x),
        (this.y += e.y),
        (this.z += e.z),
        (this.w += e.w),
        this);
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(e, t))
      : ((this.x -= e.x),
        (this.y -= e.y),
        (this.z -= e.z),
        (this.w -= e.w),
        this);
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
      (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
      (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
      (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const l = e.elements,
      c = l[0],
      h = l[4],
      u = l[8],
      d = l[1],
      f = l[5],
      m = l[9],
      v = l[2],
      y = l[6],
      p = l[10];
    if (
      Math.abs(h - d) < 0.01 &&
      Math.abs(u - v) < 0.01 &&
      Math.abs(m - y) < 0.01
    ) {
      if (
        Math.abs(h + d) < 0.1 &&
        Math.abs(u + v) < 0.1 &&
        Math.abs(m + y) < 0.1 &&
        Math.abs(c + f + p - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const w = (c + 1) / 2,
        b = (f + 1) / 2,
        _ = (p + 1) / 2,
        E = (h + d) / 4,
        L = (u + v) / 4,
        D = (m + y) / 4;
      return (
        w > b && w > _
          ? w < 0.01
            ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(w)), (i = E / n), (r = L / n))
          : b > _
          ? b < 0.01
            ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
            : ((i = Math.sqrt(b)), (n = E / i), (r = D / i))
          : _ < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
          : ((r = Math.sqrt(_)), (n = L / r), (i = D / r)),
        this.set(n, i, r, t),
        this
      );
    }
    let g = Math.sqrt(
      (y - m) * (y - m) + (u - v) * (u - v) + (d - h) * (d - h)
    );
    return (
      Math.abs(g) < 0.001 && (g = 1),
      (this.x = (y - m) / g),
      (this.y = (u - v) / g),
      (this.z = (d - h) / g),
      (this.w = Math.acos((c + f + p - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
ct.prototype.isVector4 = !0;
class Bt extends _i {
  constructor(e, t, n = {}) {
    super();
    (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new ct(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new ct(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    (this.texture = new At(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.internalFormat =
        n.internalFormat !== void 0 ? n.internalFormat : null),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : st),
      (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
      (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
      (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null),
      (this.samples = n.samples !== void 0 ? n.samples : 0);
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = n),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.image = Object.assign({}, e.texture.image)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
Bt.prototype.isWebGLRenderTarget = !0;
class Go extends At {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null);
    (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = zt),
      (this.minFilter = zt),
      (this.wrapR = Zt),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
Go.prototype.isDataArrayTexture = !0;
class Sp extends Bt {
  constructor(e, t, n) {
    super(e, t);
    (this.depth = n),
      (this.texture = new Go(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
Sp.prototype.isWebGLArrayRenderTarget = !0;
class Dl extends At {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null);
    (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = zt),
      (this.minFilter = zt),
      (this.wrapR = Zt),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
Dl.prototype.isData3DTexture = !0;
class Tp extends Bt {
  constructor(e, t, n) {
    super(e, t);
    (this.depth = n),
      (this.texture = new Dl(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
Tp.prototype.isWebGL3DRenderTarget = !0;
class Ep extends Bt {
  constructor(e, t, n, i = {}) {
    super(e, t, i);
    const r = this.texture;
    this.texture = [];
    for (let o = 0; o < n; o++)
      (this.texture[o] = r.clone()),
        (this.texture[o].isRenderTargetTexture = !0);
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      (this.width = e), (this.height = t), (this.depth = n);
      for (let i = 0, r = this.texture.length; i < r; i++)
        (this.texture[i].image.width = e),
          (this.texture[i].image.height = t),
          (this.texture[i].image.depth = n);
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.set(0, 0, this.width, this.height),
      this.scissor.set(0, 0, this.width, this.height),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.depthTexture = e.depthTexture),
      (this.texture.length = 0);
    for (let t = 0, n = e.texture.length; t < n; t++)
      this.texture[t] = e.texture[t].clone();
    return this;
  }
}
Ep.prototype.isWebGLMultipleRenderTargets = !0;
class Dt {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this._x = e), (this._y = t), (this._z = n), (this._w = i);
  }
  static slerp(e, t, n, i) {
    return (
      console.warn(
        "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
      ),
      n.slerpQuaternions(e, t, i)
    );
  }
  static slerpFlat(e, t, n, i, r, o, a) {
    let l = n[i + 0],
      c = n[i + 1],
      h = n[i + 2],
      u = n[i + 3];
    const d = r[o + 0],
      f = r[o + 1],
      m = r[o + 2],
      v = r[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
      return;
    }
    if (a === 1) {
      (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = m), (e[t + 3] = v);
      return;
    }
    if (u !== v || l !== d || c !== f || h !== m) {
      let y = 1 - a;
      const p = l * d + c * f + h * m + u * v,
        g = p >= 0 ? 1 : -1,
        w = 1 - p * p;
      if (w > Number.EPSILON) {
        const _ = Math.sqrt(w),
          E = Math.atan2(_, p * g);
        (y = Math.sin(y * E) / _), (a = Math.sin(a * E) / _);
      }
      const b = a * g;
      if (
        ((l = l * y + d * b),
        (c = c * y + f * b),
        (h = h * y + m * b),
        (u = u * y + v * b),
        y === 1 - a)
      ) {
        const _ = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        (l *= _), (c *= _), (h *= _), (u *= _);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, o) {
    const a = n[i],
      l = n[i + 1],
      c = n[i + 2],
      h = n[i + 3],
      u = r[o],
      d = r[o + 1],
      f = r[o + 2],
      m = r[o + 3];
    return (
      (e[t] = a * m + h * u + l * f - c * d),
      (e[t + 1] = l * m + h * d + c * u - a * f),
      (e[t + 2] = c * m + h * f + a * d - l * u),
      (e[t + 3] = h * m - a * u - l * d - c * f),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    if (!(e && e.isEuler))
      throw new Error(
        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
      );
    const n = e._x,
      i = e._y,
      r = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(n / 2),
      h = a(i / 2),
      u = a(r / 2),
      d = l(n / 2),
      f = l(i / 2),
      m = l(r / 2);
    switch (o) {
      case "XYZ":
        (this._x = d * h * u + c * f * m),
          (this._y = c * f * u - d * h * m),
          (this._z = c * h * m + d * f * u),
          (this._w = c * h * u - d * f * m);
        break;
      case "YXZ":
        (this._x = d * h * u + c * f * m),
          (this._y = c * f * u - d * h * m),
          (this._z = c * h * m - d * f * u),
          (this._w = c * h * u + d * f * m);
        break;
      case "ZXY":
        (this._x = d * h * u - c * f * m),
          (this._y = c * f * u + d * h * m),
          (this._z = c * h * m + d * f * u),
          (this._w = c * h * u - d * f * m);
        break;
      case "ZYX":
        (this._x = d * h * u - c * f * m),
          (this._y = c * f * u + d * h * m),
          (this._z = c * h * m - d * f * u),
          (this._w = c * h * u + d * f * m);
        break;
      case "YZX":
        (this._x = d * h * u + c * f * m),
          (this._y = c * f * u + d * h * m),
          (this._z = c * h * m - d * f * u),
          (this._w = c * h * u - d * f * m);
        break;
      case "XZY":
        (this._x = d * h * u - c * f * m),
          (this._y = c * f * u - d * h * m),
          (this._z = c * h * m + d * f * u),
          (this._w = c * h * u + d * f * m);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      r = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      h = t[6],
      u = t[10],
      d = n + a + u;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      (this._w = 0.25 / f),
        (this._x = (h - l) * f),
        (this._y = (r - c) * f),
        (this._z = (o - i) * f);
    } else if (n > a && n > u) {
      const f = 2 * Math.sqrt(1 + n - a - u);
      (this._w = (h - l) / f),
        (this._x = 0.25 * f),
        (this._y = (i + o) / f),
        (this._z = (r + c) / f);
    } else if (a > u) {
      const f = 2 * Math.sqrt(1 + a - n - u);
      (this._w = (r - c) / f),
        (this._x = (i + o) / f),
        (this._y = 0.25 * f),
        (this._z = (l + h) / f);
    } else {
      const f = 2 * Math.sqrt(1 + u - n - a);
      (this._w = (o - i) / f),
        (this._x = (r + c) / f),
        (this._y = (l + h) / f),
        (this._z = 0.25 * f);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Kt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
        ),
        this.multiplyQuaternions(e, t))
      : this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      r = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      h = t._w;
    return (
      (this._x = n * h + o * a + i * c - r * l),
      (this._y = i * h + o * l + r * a - n * c),
      (this._z = r * h + o * c + n * l - i * a),
      (this._w = o * h - n * a - i * l - r * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      r = this._z,
      o = this._w;
    let a = o * e._w + n * e._x + i * e._y + r * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = n), (this._y = i), (this._z = r), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return (
        (this._w = f * o + t * this._w),
        (this._x = f * n + t * this._x),
        (this._y = f * i + t * this._y),
        (this._z = f * r + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(l),
      h = Math.atan2(c, a),
      u = Math.sin((1 - t) * h) / c,
      d = Math.sin(t * h) / c;
    return (
      (this._w = o * u + this._w * d),
      (this._x = n * u + this._x * d),
      (this._y = i * u + this._y * d),
      (this._z = r * u + this._z * d),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      n = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(r),
      n * Math.cos(r),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
}
Dt.prototype.isQuaternion = !0;
class P {
  constructor(e = 0, t = 0, n = 0) {
    (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(e, t))
      : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(e, t))
      : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
        ),
        this.multiplyVectors(e, t))
      : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return (
      (e && e.isEuler) ||
        console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ),
      this.applyQuaternion(Uc.setFromEuler(e))
    );
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Uc.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * n + r[6] * i),
      (this.y = r[1] * t + r[4] * n + r[7] * i),
      (this.z = r[2] * t + r[5] * n + r[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements,
      o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return (
      (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o),
      (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o),
      (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = l * t + o * i - a * n,
      h = l * n + a * t - r * i,
      u = l * i + r * n - o * t,
      d = -r * t - o * n - a * i;
    return (
      (this.x = c * l + d * -r + h * -a - u * -o),
      (this.y = h * l + d * -o + u * -r - c * -a),
      (this.z = u * l + d * -a + c * -o - h * -r),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[4] * n + r[8] * i),
      (this.y = r[1] * t + r[5] * n + r[9] * i),
      (this.z = r[2] * t + r[6] * n + r[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
        ),
        this.crossVectors(e, t))
      : this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      r = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = i * l - r * a),
      (this.y = r * o - n * l),
      (this.z = n * a - i * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return ua.copy(this).projectOnVector(e), this.sub(ua);
  }
  reflect(e) {
    return this.sub(ua.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Kt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - e ** 2);
    return (
      (this.x = n * Math.cos(t)), (this.y = n * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
P.prototype.isVector3 = !0;
const ua = new P(),
  Uc = new Dt();
class _n {
  constructor(
    e = new P(1 / 0, 1 / 0, 1 / 0),
    t = new P(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      a = -1 / 0;
    for (let l = 0, c = e.length; l < c; l += 3) {
      const h = e[l],
        u = e[l + 1],
        d = e[l + 2];
      h < t && (t = h),
        u < n && (n = u),
        d < i && (i = d),
        h > r && (r = h),
        u > o && (o = u),
        d > a && (a = d);
    }
    return this.min.set(t, n, i), this.max.set(r, o, a), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      a = -1 / 0;
    for (let l = 0, c = e.count; l < c; l++) {
      const h = e.getX(l),
        u = e.getY(l),
        d = e.getZ(l);
      h < t && (t = h),
        u < n && (n = u),
        d < i && (i = d),
        h > r && (r = h),
        u > o && (o = u),
        d > a && (a = d);
    }
    return this.min.set(t, n, i), this.max.set(r, o, a), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Mi.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0)
      if (t && n.attributes != null && n.attributes.position !== void 0) {
        const r = n.attributes.position;
        for (let o = 0, a = r.count; o < a; o++)
          Mi.fromBufferAttribute(r, o).applyMatrix4(e.matrixWorld),
            this.expandByPoint(Mi);
      } else
        n.boundingBox === null && n.computeBoundingBox(),
          da.copy(n.boundingBox),
          da.applyMatrix4(e.matrixWorld),
          this.union(da);
    const i = e.children;
    for (let r = 0, o = i.length; r < o; r++) this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Mi),
      Mi.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Yr),
      zs.subVectors(this.max, Yr),
      Hi.subVectors(e.a, Yr),
      Gi.subVectors(e.b, Yr),
      Vi.subVectors(e.c, Yr),
      Jn.subVectors(Gi, Hi),
      Qn.subVectors(Vi, Gi),
      Si.subVectors(Hi, Vi);
    let t = [
      0,
      -Jn.z,
      Jn.y,
      0,
      -Qn.z,
      Qn.y,
      0,
      -Si.z,
      Si.y,
      Jn.z,
      0,
      -Jn.x,
      Qn.z,
      0,
      -Qn.x,
      Si.z,
      0,
      -Si.x,
      -Jn.y,
      Jn.x,
      0,
      -Qn.y,
      Qn.x,
      0,
      -Si.y,
      Si.x,
      0,
    ];
    return !fa(t, Hi, Gi, Vi, zs) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !fa(t, Hi, Gi, Vi, zs))
      ? !1
      : (ks.crossVectors(Jn, Qn),
        (t = [ks.x, ks.y, ks.z]),
        fa(t, Hi, Gi, Vi, zs));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return Mi.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return (
      this.getCenter(e.center), (e.radius = this.getSize(Mi).length() * 0.5), e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Un[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Un[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Un[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Un[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Un[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Un[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Un[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Un[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Un),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
_n.prototype.isBox3 = !0;
const Un = [
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
  ],
  Mi = new P(),
  da = new _n(),
  Hi = new P(),
  Gi = new P(),
  Vi = new P(),
  Jn = new P(),
  Qn = new P(),
  Si = new P(),
  Yr = new P(),
  zs = new P(),
  ks = new P(),
  Ti = new P();
function fa(s, e, t, n, i) {
  for (let r = 0, o = s.length - 3; r <= o; r += 3) {
    Ti.fromArray(s, r);
    const a =
        i.x * Math.abs(Ti.x) + i.y * Math.abs(Ti.y) + i.z * Math.abs(Ti.z),
      l = e.dot(Ti),
      c = t.dot(Ti),
      h = n.dot(Ti);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
  }
  return !0;
}
const Ap = new _n(),
  zc = new P(),
  Hs = new P(),
  pa = new P();
class Fi {
  constructor(e = new P(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : Ap.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, o = e.length; r < o; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    pa.subVectors(e, this.center);
    const t = pa.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.add(pa.multiplyScalar(i / n)), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return (
      this.center.equals(e.center) === !0
        ? Hs.set(0, 0, 1).multiplyScalar(e.radius)
        : Hs.subVectors(e.center, this.center)
            .normalize()
            .multiplyScalar(e.radius),
      this.expandByPoint(zc.copy(e.center).add(Hs)),
      this.expandByPoint(zc.copy(e.center).sub(Hs)),
      this
    );
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const zn = new P(),
  ma = new P(),
  Gs = new P(),
  ei = new P(),
  ga = new P(),
  Vs = new P(),
  va = new P();
class Rr {
  constructor(e = new P(), t = new P(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, zn)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = zn.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (zn.copy(this.direction).multiplyScalar(t).add(this.origin),
        zn.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    ma.copy(e).add(t).multiplyScalar(0.5),
      Gs.copy(t).sub(e).normalize(),
      ei.copy(this.origin).sub(ma);
    const r = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(Gs),
      a = ei.dot(this.direction),
      l = -ei.dot(Gs),
      c = ei.lengthSq(),
      h = Math.abs(1 - o * o);
    let u, d, f, m;
    if (h > 0)
      if (((u = o * l - a), (d = o * a - l), (m = r * h), u >= 0))
        if (d >= -m)
          if (d <= m) {
            const v = 1 / h;
            (u *= v),
              (d *= v),
              (f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c);
          } else
            (d = r),
              (u = Math.max(0, -(o * d + a))),
              (f = -u * u + d * (d + 2 * l) + c);
        else
          (d = -r),
            (u = Math.max(0, -(o * d + a))),
            (f = -u * u + d * (d + 2 * l) + c);
      else
        d <= -m
          ? ((u = Math.max(0, -(-o * r + a))),
            (d = u > 0 ? -r : Math.min(Math.max(-r, -l), r)),
            (f = -u * u + d * (d + 2 * l) + c))
          : d <= m
          ? ((u = 0),
            (d = Math.min(Math.max(-r, -l), r)),
            (f = d * (d + 2 * l) + c))
          : ((u = Math.max(0, -(o * r + a))),
            (d = u > 0 ? r : Math.min(Math.max(-r, -l), r)),
            (f = -u * u + d * (d + 2 * l) + c));
    else
      (d = o > 0 ? -r : r),
        (u = Math.max(0, -(o * d + a))),
        (f = -u * u + d * (d + 2 * l) + c);
    return (
      n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
      i && i.copy(Gs).multiplyScalar(d).add(ma),
      f
    );
  }
  intersectSphere(e, t) {
    zn.subVectors(e.center, this.origin);
    const n = zn.dot(this.direction),
      i = zn.dot(zn) - n * n,
      r = e.radius * e.radius;
    if (i > r) return null;
    const o = Math.sqrt(r - i),
      a = n - o,
      l = n + o;
    return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, o, a, l;
    const c = 1 / this.direction.x,
      h = 1 / this.direction.y,
      u = 1 / this.direction.z,
      d = this.origin;
    return (
      c >= 0
        ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
        : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
      h >= 0
        ? ((r = (e.min.y - d.y) * h), (o = (e.max.y - d.y) * h))
        : ((r = (e.max.y - d.y) * h), (o = (e.min.y - d.y) * h)),
      n > o ||
      r > i ||
      ((r > n || n !== n) && (n = r),
      (o < i || i !== i) && (i = o),
      u >= 0
        ? ((a = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u))
        : ((a = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
      n > l || a > i) ||
      ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, zn) !== null;
  }
  intersectTriangle(e, t, n, i, r) {
    ga.subVectors(t, e), Vs.subVectors(n, e), va.crossVectors(ga, Vs);
    let o = this.direction.dot(va),
      a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    ei.subVectors(this.origin, e);
    const l = a * this.direction.dot(Vs.crossVectors(ei, Vs));
    if (l < 0) return null;
    const c = a * this.direction.dot(ga.cross(ei));
    if (c < 0 || l + c > o) return null;
    const h = -a * ei.dot(va);
    return h < 0 ? null : this.at(h / o, r);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class be {
  constructor() {
    (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(e, t, n, i, r, o, a, l, c, h, u, d, f, m, v, y) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[4] = t),
      (p[8] = n),
      (p[12] = i),
      (p[1] = r),
      (p[5] = o),
      (p[9] = a),
      (p[13] = l),
      (p[2] = c),
      (p[6] = h),
      (p[10] = u),
      (p[14] = d),
      (p[3] = f),
      (p[7] = m),
      (p[11] = v),
      (p[15] = y),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new be().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / Wi.setFromMatrixColumn(e, 0).length(),
      r = 1 / Wi.setFromMatrixColumn(e, 1).length(),
      o = 1 / Wi.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * r),
      (t[5] = n[5] * r),
      (t[6] = n[6] * r),
      (t[7] = 0),
      (t[8] = n[8] * o),
      (t[9] = n[9] * o),
      (t[10] = n[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    (e && e.isEuler) ||
      console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z,
      o = Math.cos(n),
      a = Math.sin(n),
      l = Math.cos(i),
      c = Math.sin(i),
      h = Math.cos(r),
      u = Math.sin(r);
    if (e.order === "XYZ") {
      const d = o * h,
        f = o * u,
        m = a * h,
        v = a * u;
      (t[0] = l * h),
        (t[4] = -l * u),
        (t[8] = c),
        (t[1] = f + m * c),
        (t[5] = d - v * c),
        (t[9] = -a * l),
        (t[2] = v - d * c),
        (t[6] = m + f * c),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const d = l * h,
        f = l * u,
        m = c * h,
        v = c * u;
      (t[0] = d + v * a),
        (t[4] = m * a - f),
        (t[8] = o * c),
        (t[1] = o * u),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = f * a - m),
        (t[6] = v + d * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const d = l * h,
        f = l * u,
        m = c * h,
        v = c * u;
      (t[0] = d - v * a),
        (t[4] = -o * u),
        (t[8] = m + f * a),
        (t[1] = f + m * a),
        (t[5] = o * h),
        (t[9] = v - d * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const d = o * h,
        f = o * u,
        m = a * h,
        v = a * u;
      (t[0] = l * h),
        (t[4] = m * c - f),
        (t[8] = d * c + v),
        (t[1] = l * u),
        (t[5] = v * c + d),
        (t[9] = f * c - m),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const d = o * l,
        f = o * c,
        m = a * l,
        v = a * c;
      (t[0] = l * h),
        (t[4] = v - d * u),
        (t[8] = m * u + f),
        (t[1] = u),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -c * h),
        (t[6] = f * u + m),
        (t[10] = d - v * u);
    } else if (e.order === "XZY") {
      const d = o * l,
        f = o * c,
        m = a * l,
        v = a * c;
      (t[0] = l * h),
        (t[4] = -u),
        (t[8] = c * h),
        (t[1] = d * u + v),
        (t[5] = o * h),
        (t[9] = f * u - m),
        (t[2] = m * u - f),
        (t[6] = a * h),
        (t[10] = v * u + d);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Cp, e, Rp);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      sn.subVectors(e, t),
      sn.lengthSq() === 0 && (sn.z = 1),
      sn.normalize(),
      ti.crossVectors(n, sn),
      ti.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (sn.x += 1e-4) : (sn.z += 1e-4),
        sn.normalize(),
        ti.crossVectors(n, sn)),
      ti.normalize(),
      Ws.crossVectors(sn, ti),
      (i[0] = ti.x),
      (i[4] = Ws.x),
      (i[8] = sn.x),
      (i[1] = ti.y),
      (i[5] = Ws.y),
      (i[9] = sn.y),
      (i[2] = ti.z),
      (i[6] = Ws.z),
      (i[10] = sn.z),
      this
    );
  }
  multiply(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
        ),
        this.multiplyMatrices(e, t))
      : this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      o = n[0],
      a = n[4],
      l = n[8],
      c = n[12],
      h = n[1],
      u = n[5],
      d = n[9],
      f = n[13],
      m = n[2],
      v = n[6],
      y = n[10],
      p = n[14],
      g = n[3],
      w = n[7],
      b = n[11],
      _ = n[15],
      E = i[0],
      L = i[4],
      D = i[8],
      V = i[12],
      F = i[1],
      M = i[5],
      A = i[9],
      N = i[13],
      O = i[2],
      H = i[6],
      G = i[10],
      W = i[14],
      k = i[3],
      Q = i[7],
      ie = i[11],
      re = i[15];
    return (
      (r[0] = o * E + a * F + l * O + c * k),
      (r[4] = o * L + a * M + l * H + c * Q),
      (r[8] = o * D + a * A + l * G + c * ie),
      (r[12] = o * V + a * N + l * W + c * re),
      (r[1] = h * E + u * F + d * O + f * k),
      (r[5] = h * L + u * M + d * H + f * Q),
      (r[9] = h * D + u * A + d * G + f * ie),
      (r[13] = h * V + u * N + d * W + f * re),
      (r[2] = m * E + v * F + y * O + p * k),
      (r[6] = m * L + v * M + y * H + p * Q),
      (r[10] = m * D + v * A + y * G + p * ie),
      (r[14] = m * V + v * N + y * W + p * re),
      (r[3] = g * E + w * F + b * O + _ * k),
      (r[7] = g * L + w * M + b * H + _ * Q),
      (r[11] = g * D + w * A + b * G + _ * ie),
      (r[15] = g * V + w * N + b * W + _ * re),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      r = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      h = e[2],
      u = e[6],
      d = e[10],
      f = e[14],
      m = e[3],
      v = e[7],
      y = e[11],
      p = e[15];
    return (
      m *
        (+r * l * u -
          i * c * u -
          r * a * d +
          n * c * d +
          i * a * f -
          n * l * f) +
      v *
        (+t * l * f -
          t * c * d +
          r * o * d -
          i * o * f +
          i * c * h -
          r * l * h) +
      y *
        (+t * c * u -
          t * a * f -
          r * o * u +
          n * o * f +
          r * a * h -
          n * c * h) +
      p *
        (-i * a * h - t * l * u + t * a * d + i * o * u - n * o * d + n * l * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      u = e[9],
      d = e[10],
      f = e[11],
      m = e[12],
      v = e[13],
      y = e[14],
      p = e[15],
      g = u * y * c - v * d * c + v * l * f - a * y * f - u * l * p + a * d * p,
      w = m * d * c - h * y * c - m * l * f + o * y * f + h * l * p - o * d * p,
      b = h * v * c - m * u * c + m * a * f - o * v * f - h * a * p + o * u * p,
      _ = m * u * l - h * v * l - m * a * d + o * v * d + h * a * y - o * u * y,
      E = t * g + n * w + i * b + r * _;
    if (E === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const L = 1 / E;
    return (
      (e[0] = g * L),
      (e[1] =
        (v * d * r -
          u * y * r -
          v * i * f +
          n * y * f +
          u * i * p -
          n * d * p) *
        L),
      (e[2] =
        (a * y * r -
          v * l * r +
          v * i * c -
          n * y * c -
          a * i * p +
          n * l * p) *
        L),
      (e[3] =
        (u * l * r -
          a * d * r -
          u * i * c +
          n * d * c +
          a * i * f -
          n * l * f) *
        L),
      (e[4] = w * L),
      (e[5] =
        (h * y * r -
          m * d * r +
          m * i * f -
          t * y * f -
          h * i * p +
          t * d * p) *
        L),
      (e[6] =
        (m * l * r -
          o * y * r -
          m * i * c +
          t * y * c +
          o * i * p -
          t * l * p) *
        L),
      (e[7] =
        (o * d * r -
          h * l * r +
          h * i * c -
          t * d * c -
          o * i * f +
          t * l * f) *
        L),
      (e[8] = b * L),
      (e[9] =
        (m * u * r -
          h * v * r -
          m * n * f +
          t * v * f +
          h * n * p -
          t * u * p) *
        L),
      (e[10] =
        (o * v * r -
          m * a * r +
          m * n * c -
          t * v * c -
          o * n * p +
          t * a * p) *
        L),
      (e[11] =
        (h * a * r -
          o * u * r -
          h * n * c +
          t * u * c +
          o * n * f -
          t * a * f) *
        L),
      (e[12] = _ * L),
      (e[13] =
        (h * v * i -
          m * u * i +
          m * n * d -
          t * v * d -
          h * n * y +
          t * u * y) *
        L),
      (e[14] =
        (m * a * i -
          o * v * i -
          m * n * l +
          t * v * l +
          o * n * y -
          t * a * y) *
        L),
      (e[15] =
        (o * u * i -
          h * a * i +
          h * n * l -
          t * u * l -
          o * n * d +
          t * a * d) *
        L),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= r),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= r),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= r),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = 1 - n,
      o = e.x,
      a = e.y,
      l = e.z,
      c = r * o,
      h = r * a;
    return (
      this.set(
        c * o + n,
        c * a - i * l,
        c * l + i * a,
        0,
        c * a + i * l,
        h * a + n,
        h * l - i * o,
        0,
        c * l - i * a,
        h * l + i * o,
        r * l * l + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, r, o) {
    return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      r = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = r + r,
      h = o + o,
      u = a + a,
      d = r * c,
      f = r * h,
      m = r * u,
      v = o * h,
      y = o * u,
      p = a * u,
      g = l * c,
      w = l * h,
      b = l * u,
      _ = n.x,
      E = n.y,
      L = n.z;
    return (
      (i[0] = (1 - (v + p)) * _),
      (i[1] = (f + b) * _),
      (i[2] = (m - w) * _),
      (i[3] = 0),
      (i[4] = (f - b) * E),
      (i[5] = (1 - (d + p)) * E),
      (i[6] = (y + g) * E),
      (i[7] = 0),
      (i[8] = (m + w) * L),
      (i[9] = (y - g) * L),
      (i[10] = (1 - (d + v)) * L),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = Wi.set(i[0], i[1], i[2]).length();
    const o = Wi.set(i[4], i[5], i[6]).length(),
      a = Wi.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      bn.copy(this);
    const c = 1 / r,
      h = 1 / o,
      u = 1 / a;
    return (
      (bn.elements[0] *= c),
      (bn.elements[1] *= c),
      (bn.elements[2] *= c),
      (bn.elements[4] *= h),
      (bn.elements[5] *= h),
      (bn.elements[6] *= h),
      (bn.elements[8] *= u),
      (bn.elements[9] *= u),
      (bn.elements[10] *= u),
      t.setFromRotationMatrix(bn),
      (n.x = r),
      (n.y = o),
      (n.z = a),
      this
    );
  }
  makePerspective(e, t, n, i, r, o) {
    o === void 0 &&
      console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
    const a = this.elements,
      l = (2 * r) / (t - e),
      c = (2 * r) / (n - i),
      h = (t + e) / (t - e),
      u = (n + i) / (n - i),
      d = -(o + r) / (o - r),
      f = (-2 * o * r) / (o - r);
    return (
      (a[0] = l),
      (a[4] = 0),
      (a[8] = h),
      (a[12] = 0),
      (a[1] = 0),
      (a[5] = c),
      (a[9] = u),
      (a[13] = 0),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = d),
      (a[14] = f),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = -1),
      (a[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, r, o) {
    const a = this.elements,
      l = 1 / (t - e),
      c = 1 / (n - i),
      h = 1 / (o - r),
      u = (t + e) * l,
      d = (n + i) * c,
      f = (o + r) * h;
    return (
      (a[0] = 2 * l),
      (a[4] = 0),
      (a[8] = 0),
      (a[12] = -u),
      (a[1] = 0),
      (a[5] = 2 * c),
      (a[9] = 0),
      (a[13] = -d),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = -2 * h),
      (a[14] = -f),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
be.prototype.isMatrix4 = !0;
const Wi = new P(),
  bn = new be(),
  Cp = new P(0, 0, 0),
  Rp = new P(1, 1, 1),
  ti = new P(),
  Ws = new P(),
  sn = new P(),
  kc = new be(),
  Hc = new Dt();
class mn {
  constructor(e = 0, t = 0, n = 0, i = mn.DefaultOrder) {
    (this._x = e), (this._y = t), (this._z = n), (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      r = i[0],
      o = i[4],
      a = i[8],
      l = i[1],
      c = i[5],
      h = i[9],
      u = i[2],
      d = i[6],
      f = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Kt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, f)), (this._z = Math.atan2(-o, r)))
            : ((this._x = Math.atan2(d, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Kt(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-u, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Kt(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-u, f)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Kt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, r)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
        break;
      case "YZX":
        (this._z = Math.asin(Kt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, c)), (this._y = Math.atan2(-u, r)))
            : ((this._x = 0), (this._y = Math.atan2(a, f)));
        break;
      case "XZY":
        (this._z = Math.asin(-Kt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, r)))
            : ((this._x = Math.atan2(-h, f)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      kc.makeRotationFromQuaternion(e), this.setFromRotationMatrix(kc, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Hc.setFromEuler(this), this.setFromQuaternion(Hc, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
}
mn.prototype.isEuler = !0;
mn.DefaultOrder = "XYZ";
mn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Ru {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Lp = 0;
const Gc = new P(),
  Xi = new Dt(),
  kn = new be(),
  Xs = new P(),
  Zr = new P(),
  Pp = new P(),
  Ip = new Dt(),
  Vc = new P(1, 0, 0),
  Wc = new P(0, 1, 0),
  Xc = new P(0, 0, 1),
  Dp = { type: "added" },
  jc = { type: "removed" };
class at extends _i {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: Lp++ }),
      (this.uuid = gn()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = at.DefaultUp.clone());
    const e = new P(),
      t = new mn(),
      n = new Dt(),
      i = new P(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r),
      n._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new be() },
        normalMatrix: { value: new Gt() },
      }),
      (this.matrix = new be()),
      (this.matrixWorld = new be()),
      (this.matrixAutoUpdate = at.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Ru()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Xi.setFromAxisAngle(e, t), this.quaternion.multiply(Xi), this;
  }
  rotateOnWorldAxis(e, t) {
    return Xi.setFromAxisAngle(e, t), this.quaternion.premultiply(Xi), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Vc, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Wc, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Xc, e);
  }
  translateOnAxis(e, t) {
    return (
      Gc.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Gc.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Vc, e);
  }
  translateY(e) {
    return this.translateOnAxis(Wc, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Xc, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(kn.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Xs.copy(e) : Xs.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Zr.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? kn.lookAt(Zr, Xs, this.up)
        : kn.lookAt(Xs, Zr, this.up),
      this.quaternion.setFromRotationMatrix(kn),
      i &&
        (kn.extractRotation(i.matrixWorld),
        Xi.setFromRotationMatrix(kn),
        this.quaternion.premultiply(Xi.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Dp))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(jc)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(jc);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      kn.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), kn.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(kn),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zr, e, Pp), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zr, Ip, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function r(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            r(e.shapes, u);
          }
        else r(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (r(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(r(e.materials, this.material[l]));
        i.material = a;
      } else i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        h = o(e.images),
        u = o(e.shapes),
        d = o(e.skeletons),
        f = o(e.animations),
        m = o(e.nodes);
      a.length > 0 && (n.geometries = a),
        l.length > 0 && (n.materials = l),
        c.length > 0 && (n.textures = c),
        h.length > 0 && (n.images = h),
        u.length > 0 && (n.shapes = u),
        d.length > 0 && (n.skeletons = d),
        f.length > 0 && (n.animations = f),
        m.length > 0 && (n.nodes = m);
    }
    return (n.object = i), n;
    function o(a) {
      const l = [];
      for (const c in a) {
        const h = a[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
at.DefaultUp = new P(0, 1, 0);
at.DefaultMatrixAutoUpdate = !0;
at.prototype.isObject3D = !0;
const Mn = new P(),
  Hn = new P(),
  xa = new P(),
  Gn = new P(),
  ji = new P(),
  qi = new P(),
  qc = new P(),
  ya = new P(),
  _a = new P(),
  wa = new P();
class Ft {
  constructor(e = new P(), t = new P(), n = new P()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Mn.subVectors(e, t), i.cross(Mn);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, r) {
    Mn.subVectors(i, t), Hn.subVectors(n, t), xa.subVectors(e, t);
    const o = Mn.dot(Mn),
      a = Mn.dot(Hn),
      l = Mn.dot(xa),
      c = Hn.dot(Hn),
      h = Hn.dot(xa),
      u = o * c - a * a;
    if (u === 0) return r.set(-2, -1, -1);
    const d = 1 / u,
      f = (c * l - a * h) * d,
      m = (o * h - a * l) * d;
    return r.set(1 - f - m, m, f);
  }
  static containsPoint(e, t, n, i) {
    return (
      this.getBarycoord(e, t, n, i, Gn),
      Gn.x >= 0 && Gn.y >= 0 && Gn.x + Gn.y <= 1
    );
  }
  static getUV(e, t, n, i, r, o, a, l) {
    return (
      this.getBarycoord(e, t, n, i, Gn),
      l.set(0, 0),
      l.addScaledVector(r, Gn.x),
      l.addScaledVector(o, Gn.y),
      l.addScaledVector(a, Gn.z),
      l
    );
  }
  static isFrontFacing(e, t, n, i) {
    return Mn.subVectors(n, t), Hn.subVectors(e, t), Mn.cross(Hn).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Mn.subVectors(this.c, this.b),
      Hn.subVectors(this.a, this.b),
      Mn.cross(Hn).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ft.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ft.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, r) {
    return Ft.getUV(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return Ft.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ft.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      r = this.c;
    let o, a;
    ji.subVectors(i, n), qi.subVectors(r, n), ya.subVectors(e, n);
    const l = ji.dot(ya),
      c = qi.dot(ya);
    if (l <= 0 && c <= 0) return t.copy(n);
    _a.subVectors(e, i);
    const h = ji.dot(_a),
      u = qi.dot(_a);
    if (h >= 0 && u <= h) return t.copy(i);
    const d = l * u - h * c;
    if (d <= 0 && l >= 0 && h <= 0)
      return (o = l / (l - h)), t.copy(n).addScaledVector(ji, o);
    wa.subVectors(e, r);
    const f = ji.dot(wa),
      m = qi.dot(wa);
    if (m >= 0 && f <= m) return t.copy(r);
    const v = f * c - l * m;
    if (v <= 0 && c >= 0 && m <= 0)
      return (a = c / (c - m)), t.copy(n).addScaledVector(qi, a);
    const y = h * m - f * u;
    if (y <= 0 && u - h >= 0 && f - m >= 0)
      return (
        qc.subVectors(r, i),
        (a = (u - h) / (u - h + (f - m))),
        t.copy(i).addScaledVector(qc, a)
      );
    const p = 1 / (y + v + d);
    return (
      (o = v * p),
      (a = d * p),
      t.copy(n).addScaledVector(ji, o).addScaledVector(qi, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Fp = 0;
class Et extends _i {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: Fp++ }),
      (this.uuid = gn()),
      (this.name = ""),
      (this.type = "Material"),
      (this.fog = !0),
      (this.blending = fr),
      (this.side = gr),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = vu),
      (this.blendDst = xu),
      (this.blendEquation = sr),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Ja),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = cp),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = aa),
      (this.stencilZFail = aa),
      (this.stencilZPass = aa),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead."
          ),
            (this.flatShading = n === gu);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            "THREE." +
              this.type +
              ": '" +
              t +
              "' is not a property of this material."
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== fr && (n.blending = this.blending),
      this.side !== gr && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function i(r) {
      const o = [];
      for (const a in r) {
        const l = r[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const r = i(e.textures),
        o = i(e.images);
      r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.fog = e.fog),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
Et.prototype.isMaterial = !0;
Et.fromType = function () {
  return null;
};
class Rn extends Et {
  constructor(e) {
    super();
    (this.type = "MeshBasicMaterial"),
      (this.color = new ye(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = ko),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      this
    );
  }
}
Rn.prototype.isMeshBasicMaterial = !0;
const vt = new P(),
  js = new ae();
class St {
  constructor(e, t, n) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n === !0),
      (this.usage = ps),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let o = e[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          i
        ),
        (o = new ye())),
        (t[n++] = o.r),
        (t[n++] = o.g),
        (t[n++] = o.b);
    }
    return this;
  }
  copyVector2sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let o = e[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          i
        ),
        (o = new ae())),
        (t[n++] = o.x),
        (t[n++] = o.y);
    }
    return this;
  }
  copyVector3sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let o = e[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          i
        ),
        (o = new P())),
        (t[n++] = o.x),
        (t[n++] = o.y),
        (t[n++] = o.z);
    }
    return this;
  }
  copyVector4sArray(e) {
    const t = this.array;
    let n = 0;
    for (let i = 0, r = e.length; i < r; i++) {
      let o = e[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          i
        ),
        (o = new ct())),
        (t[n++] = o.x),
        (t[n++] = o.y),
        (t[n++] = o.z),
        (t[n++] = o.w);
    }
    return this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        js.fromBufferAttribute(this, t),
          js.applyMatrix3(e),
          this.setXY(t, js.x, js.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        vt.fromBufferAttribute(this, t),
          vt.applyMatrix3(e),
          this.setXYZ(t, vt.x, vt.y, vt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (vt.x = this.getX(t)),
        (vt.y = this.getY(t)),
        (vt.z = this.getZ(t)),
        vt.applyMatrix4(e),
        this.setXYZ(t, vt.x, vt.y, vt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (vt.x = this.getX(t)),
        (vt.y = this.getY(t)),
        (vt.z = this.getZ(t)),
        vt.applyNormalMatrix(e),
        this.setXYZ(t, vt.x, vt.y, vt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (vt.x = this.getX(t)),
        (vt.y = this.getY(t)),
        (vt.z = this.getZ(t)),
        vt.transformDirection(e),
        this.setXYZ(t, vt.x, vt.y, vt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, t) {
    return (this.array[e * this.itemSize] = t), this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, t) {
    return (this.array[e * this.itemSize + 1] = t), this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, t) {
    return (this.array[e * this.itemSize + 2] = t), this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, t) {
    return (this.array[e * this.itemSize + 3] = t), this;
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = r),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== ps && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
}
St.prototype.isBufferAttribute = !0;
class Fl extends St {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class Lu extends St {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class Np extends St {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
Np.prototype.isFloat16BufferAttribute = !0;
class Je extends St {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let Bp = 0;
const fn = new be(),
  ba = new at(),
  Yi = new P(),
  on = new _n(),
  $r = new _n(),
  Ht = new P();
class tt extends _i {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: Bp++ }),
      (this.uuid = gn()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (Eu(e) ? Lu : Fl)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Gt().getNormalMatrix(e);
      n.applyNormalMatrix(r), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return fn.makeRotationFromQuaternion(e), this.applyMatrix4(fn), this;
  }
  rotateX(e) {
    return fn.makeRotationX(e), this.applyMatrix4(fn), this;
  }
  rotateY(e) {
    return fn.makeRotationY(e), this.applyMatrix4(fn), this;
  }
  rotateZ(e) {
    return fn.makeRotationZ(e), this.applyMatrix4(fn), this;
  }
  translate(e, t, n) {
    return fn.makeTranslation(e, t, n), this.applyMatrix4(fn), this;
  }
  scale(e, t, n) {
    return fn.makeScale(e, t, n), this.applyMatrix4(fn), this;
  }
  lookAt(e) {
    return ba.lookAt(e), ba.updateMatrix(), this.applyMatrix4(ba.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Yi).negate(),
      this.translate(Yi.x, Yi.y, Yi.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const r = e[n];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new Je(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new _n());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new P(-1 / 0, -1 / 0, -1 / 0),
          new P(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          on.setFromBufferAttribute(r),
            this.morphTargetsRelative
              ? (Ht.addVectors(this.boundingBox.min, on.min),
                this.boundingBox.expandByPoint(Ht),
                Ht.addVectors(this.boundingBox.max, on.max),
                this.boundingBox.expandByPoint(Ht))
              : (this.boundingBox.expandByPoint(on.min),
                this.boundingBox.expandByPoint(on.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Fi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new P(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((on.setFromBufferAttribute(e), t))
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r];
          $r.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Ht.addVectors(on.min, $r.min),
                on.expandByPoint(Ht),
                Ht.addVectors(on.max, $r.max),
                on.expandByPoint(Ht))
              : (on.expandByPoint($r.min), on.expandByPoint($r.max));
        }
      on.getCenter(n);
      let i = 0;
      for (let r = 0, o = e.count; r < o; r++)
        Ht.fromBufferAttribute(e, r),
          (i = Math.max(i, n.distanceToSquared(Ht)));
      if (t)
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r],
            l = this.morphTargetsRelative;
          for (let c = 0, h = a.count; c < h; c++)
            Ht.fromBufferAttribute(a, c),
              l && (Yi.fromBufferAttribute(e, c), Ht.add(Yi)),
              (i = Math.max(i, n.distanceToSquared(Ht)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = e.array,
      i = t.position.array,
      r = t.normal.array,
      o = t.uv.array,
      a = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new St(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      h = [];
    for (let F = 0; F < a; F++) (c[F] = new P()), (h[F] = new P());
    const u = new P(),
      d = new P(),
      f = new P(),
      m = new ae(),
      v = new ae(),
      y = new ae(),
      p = new P(),
      g = new P();
    function w(F, M, A) {
      u.fromArray(i, F * 3),
        d.fromArray(i, M * 3),
        f.fromArray(i, A * 3),
        m.fromArray(o, F * 2),
        v.fromArray(o, M * 2),
        y.fromArray(o, A * 2),
        d.sub(u),
        f.sub(u),
        v.sub(m),
        y.sub(m);
      const N = 1 / (v.x * y.y - y.x * v.y);
      !isFinite(N) ||
        (p
          .copy(d)
          .multiplyScalar(y.y)
          .addScaledVector(f, -v.y)
          .multiplyScalar(N),
        g
          .copy(f)
          .multiplyScalar(v.x)
          .addScaledVector(d, -y.x)
          .multiplyScalar(N),
        c[F].add(p),
        c[M].add(p),
        c[A].add(p),
        h[F].add(g),
        h[M].add(g),
        h[A].add(g));
    }
    let b = this.groups;
    b.length === 0 && (b = [{ start: 0, count: n.length }]);
    for (let F = 0, M = b.length; F < M; ++F) {
      const A = b[F],
        N = A.start,
        O = A.count;
      for (let H = N, G = N + O; H < G; H += 3) w(n[H + 0], n[H + 1], n[H + 2]);
    }
    const _ = new P(),
      E = new P(),
      L = new P(),
      D = new P();
    function V(F) {
      L.fromArray(r, F * 3), D.copy(L);
      const M = c[F];
      _.copy(M),
        _.sub(L.multiplyScalar(L.dot(M))).normalize(),
        E.crossVectors(D, M);
      const N = E.dot(h[F]) < 0 ? -1 : 1;
      (l[F * 4] = _.x),
        (l[F * 4 + 1] = _.y),
        (l[F * 4 + 2] = _.z),
        (l[F * 4 + 3] = N);
    }
    for (let F = 0, M = b.length; F < M; ++F) {
      const A = b[F],
        N = A.start,
        O = A.count;
      for (let H = N, G = N + O; H < G; H += 3)
        V(n[H + 0]), V(n[H + 1]), V(n[H + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new St(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
      const i = new P(),
        r = new P(),
        o = new P(),
        a = new P(),
        l = new P(),
        c = new P(),
        h = new P(),
        u = new P();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const m = e.getX(d + 0),
            v = e.getX(d + 1),
            y = e.getX(d + 2);
          i.fromBufferAttribute(t, m),
            r.fromBufferAttribute(t, v),
            o.fromBufferAttribute(t, y),
            h.subVectors(o, r),
            u.subVectors(i, r),
            h.cross(u),
            a.fromBufferAttribute(n, m),
            l.fromBufferAttribute(n, v),
            c.fromBufferAttribute(n, y),
            a.add(h),
            l.add(h),
            c.add(h),
            n.setXYZ(m, a.x, a.y, a.z),
            n.setXYZ(v, l.x, l.y, l.z),
            n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          i.fromBufferAttribute(t, d + 0),
            r.fromBufferAttribute(t, d + 1),
            o.fromBufferAttribute(t, d + 2),
            h.subVectors(o, r),
            u.subVectors(i, r),
            h.cross(u),
            n.setXYZ(d + 0, h.x, h.y, h.z),
            n.setXYZ(d + 1, h.x, h.y, h.z),
            n.setXYZ(d + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  merge(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        e
      );
      return;
    }
    t === void 0 &&
      ((t = 0),
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      ));
    const n = this.attributes;
    for (const i in n) {
      if (e.attributes[i] === void 0) continue;
      const o = n[i].array,
        a = e.attributes[i],
        l = a.array,
        c = a.itemSize * t,
        h = Math.min(l.length, o.length - c);
      for (let u = 0, d = c; u < h; u++, d++) o[d] = l[u];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Ht.fromBufferAttribute(e, t),
        Ht.normalize(),
        e.setXYZ(t, Ht.x, Ht.y, Ht.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        h = a.itemSize,
        u = a.normalized,
        d = new c.constructor(l.length * h);
      let f = 0,
        m = 0;
      for (let v = 0, y = l.length; v < y; v++) {
        a.isInterleavedBufferAttribute
          ? (f = l[v] * a.data.stride + a.offset)
          : (f = l[v] * h);
        for (let p = 0; p < h; p++) d[m++] = c[f++];
      }
      return new St(d, h, u);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new tt(),
      n = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const l = i[a],
        c = e(l, n);
      t.setAttribute(a, c);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const l = [],
        c = r[a];
      for (let h = 0, u = c.length; h < u; h++) {
        const d = c[h],
          f = e(d, n);
        l.push(f);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        h = [];
      for (let u = 0, d = c.length; u < d; u++) {
        const f = c[u];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && ((i[l] = h), (r = !0));
    }
    r &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const h = i[c];
      this.setAttribute(c, h.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const h = [],
        u = r[c];
      for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const u = o[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      e.parameters !== void 0 &&
        (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
tt.prototype.isBufferGeometry = !0;
const Yc = new be(),
  Zi = new Rr(),
  Ma = new Fi(),
  ni = new P(),
  ii = new P(),
  ri = new P(),
  Sa = new P(),
  Ta = new P(),
  Ea = new P(),
  qs = new P(),
  Ys = new P(),
  Zs = new P(),
  $s = new ae(),
  Ks = new ae(),
  Js = new ae(),
  Aa = new P(),
  Qs = new P();
class jt extends at {
  constructor(e = new tt(), t = new Rn()) {
    super();
    (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e) {
    return (
      super.copy(e),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = r);
          }
        }
      }
    } else {
      const t = e.morphTargets;
      t !== void 0 &&
        t.length > 0 &&
        console.error(
          "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      r = this.matrixWorld;
    if (
      i === void 0 ||
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Ma.copy(n.boundingSphere),
      Ma.applyMatrix4(r),
      e.ray.intersectsSphere(Ma) === !1) ||
      (Yc.copy(r).invert(),
      Zi.copy(e.ray).applyMatrix4(Yc),
      n.boundingBox !== null && Zi.intersectsBox(n.boundingBox) === !1)
    )
      return;
    let o;
    if (n.isBufferGeometry) {
      const a = n.index,
        l = n.attributes.position,
        c = n.morphAttributes.position,
        h = n.morphTargetsRelative,
        u = n.attributes.uv,
        d = n.attributes.uv2,
        f = n.groups,
        m = n.drawRange;
      if (a !== null)
        if (Array.isArray(i))
          for (let v = 0, y = f.length; v < y; v++) {
            const p = f[v],
              g = i[p.materialIndex],
              w = Math.max(p.start, m.start),
              b = Math.min(
                a.count,
                Math.min(p.start + p.count, m.start + m.count)
              );
            for (let _ = w, E = b; _ < E; _ += 3) {
              const L = a.getX(_),
                D = a.getX(_ + 1),
                V = a.getX(_ + 2);
              (o = eo(this, g, e, Zi, l, c, h, u, d, L, D, V)),
                o &&
                  ((o.faceIndex = Math.floor(_ / 3)),
                  (o.face.materialIndex = p.materialIndex),
                  t.push(o));
            }
          }
        else {
          const v = Math.max(0, m.start),
            y = Math.min(a.count, m.start + m.count);
          for (let p = v, g = y; p < g; p += 3) {
            const w = a.getX(p),
              b = a.getX(p + 1),
              _ = a.getX(p + 2);
            (o = eo(this, i, e, Zi, l, c, h, u, d, w, b, _)),
              o && ((o.faceIndex = Math.floor(p / 3)), t.push(o));
          }
        }
      else if (l !== void 0)
        if (Array.isArray(i))
          for (let v = 0, y = f.length; v < y; v++) {
            const p = f[v],
              g = i[p.materialIndex],
              w = Math.max(p.start, m.start),
              b = Math.min(
                l.count,
                Math.min(p.start + p.count, m.start + m.count)
              );
            for (let _ = w, E = b; _ < E; _ += 3) {
              const L = _,
                D = _ + 1,
                V = _ + 2;
              (o = eo(this, g, e, Zi, l, c, h, u, d, L, D, V)),
                o &&
                  ((o.faceIndex = Math.floor(_ / 3)),
                  (o.face.materialIndex = p.materialIndex),
                  t.push(o));
            }
          }
        else {
          const v = Math.max(0, m.start),
            y = Math.min(l.count, m.start + m.count);
          for (let p = v, g = y; p < g; p += 3) {
            const w = p,
              b = p + 1,
              _ = p + 2;
            (o = eo(this, i, e, Zi, l, c, h, u, d, w, b, _)),
              o && ((o.faceIndex = Math.floor(p / 3)), t.push(o));
          }
        }
    } else
      n.isGeometry &&
        console.error(
          "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
  }
}
jt.prototype.isMesh = !0;
function Op(s, e, t, n, i, r, o, a) {
  let l;
  if (
    (e.side === Ut
      ? (l = n.intersectTriangle(o, r, i, !0, a))
      : (l = n.intersectTriangle(i, r, o, e.side !== Li, a)),
    l === null)
  )
    return null;
  Qs.copy(a), Qs.applyMatrix4(s.matrixWorld);
  const c = t.ray.origin.distanceTo(Qs);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: Qs.clone(), object: s };
}
function eo(s, e, t, n, i, r, o, a, l, c, h, u) {
  ni.fromBufferAttribute(i, c),
    ii.fromBufferAttribute(i, h),
    ri.fromBufferAttribute(i, u);
  const d = s.morphTargetInfluences;
  if (r && d) {
    qs.set(0, 0, 0), Ys.set(0, 0, 0), Zs.set(0, 0, 0);
    for (let m = 0, v = r.length; m < v; m++) {
      const y = d[m],
        p = r[m];
      y !== 0 &&
        (Sa.fromBufferAttribute(p, c),
        Ta.fromBufferAttribute(p, h),
        Ea.fromBufferAttribute(p, u),
        o
          ? (qs.addScaledVector(Sa, y),
            Ys.addScaledVector(Ta, y),
            Zs.addScaledVector(Ea, y))
          : (qs.addScaledVector(Sa.sub(ni), y),
            Ys.addScaledVector(Ta.sub(ii), y),
            Zs.addScaledVector(Ea.sub(ri), y)));
    }
    ni.add(qs), ii.add(Ys), ri.add(Zs);
  }
  s.isSkinnedMesh &&
    (s.boneTransform(c, ni), s.boneTransform(h, ii), s.boneTransform(u, ri));
  const f = Op(s, e, t, n, ni, ii, ri, Aa);
  if (f) {
    a &&
      ($s.fromBufferAttribute(a, c),
      Ks.fromBufferAttribute(a, h),
      Js.fromBufferAttribute(a, u),
      (f.uv = Ft.getUV(Aa, ni, ii, ri, $s, Ks, Js, new ae()))),
      l &&
        ($s.fromBufferAttribute(l, c),
        Ks.fromBufferAttribute(l, h),
        Js.fromBufferAttribute(l, u),
        (f.uv2 = Ft.getUV(Aa, ni, ii, ri, $s, Ks, Js, new ae())));
    const m = { a: c, b: h, c: u, normal: new P(), materialIndex: 0 };
    Ft.getNormal(ni, ii, ri, m.normal), (f.face = m);
  }
  return f;
}
class Cs extends tt {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
    super();
    (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o,
      });
    const a = this;
    (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
    const l = [],
      c = [],
      h = [],
      u = [];
    let d = 0,
      f = 0;
    m("z", "y", "x", -1, -1, n, t, e, o, r, 0),
      m("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
      m("x", "z", "y", 1, 1, e, n, t, i, o, 2),
      m("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
      m("x", "y", "z", 1, -1, e, t, n, i, r, 4),
      m("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
      this.setIndex(l),
      this.setAttribute("position", new Je(c, 3)),
      this.setAttribute("normal", new Je(h, 3)),
      this.setAttribute("uv", new Je(u, 2));
    function m(v, y, p, g, w, b, _, E, L, D, V) {
      const F = b / L,
        M = _ / D,
        A = b / 2,
        N = _ / 2,
        O = E / 2,
        H = L + 1,
        G = D + 1;
      let W = 0,
        k = 0;
      const Q = new P();
      for (let ie = 0; ie < G; ie++) {
        const re = ie * M - N;
        for (let ee = 0; ee < H; ee++) {
          const Me = ee * F - A;
          (Q[v] = Me * g),
            (Q[y] = re * w),
            (Q[p] = O),
            c.push(Q.x, Q.y, Q.z),
            (Q[v] = 0),
            (Q[y] = 0),
            (Q[p] = E > 0 ? 1 : -1),
            h.push(Q.x, Q.y, Q.z),
            u.push(ee / L),
            u.push(1 - ie / D),
            (W += 1);
        }
      }
      for (let ie = 0; ie < D; ie++)
        for (let re = 0; re < L; re++) {
          const ee = d + re + H * ie,
            Me = d + re + H * (ie + 1),
            Be = d + (re + 1) + H * (ie + 1),
            Re = d + (re + 1) + H * ie;
          l.push(ee, Me, Re), l.push(Me, Be, Re), (k += 6);
        }
      a.addGroup(f, k, V), (f += k), (d += W);
    }
  }
  static fromJSON(e) {
    return new Cs(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function wr(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function qt(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = wr(s[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
const vs = { clone: wr, merge: qt };
var Up = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  zp = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Vt extends Et {
  constructor(e) {
    super();
    (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader = Up),
      (this.fragmentShader = zp),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 &&
        (e.attributes !== void 0 &&
          console.error(
            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
          ),
        this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = wr(e.uniforms)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[i] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
        : (t.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
Vt.prototype.isShaderMaterial = !0;
class Vo extends at {
  constructor() {
    super();
    (this.type = "Camera"),
      (this.matrixWorldInverse = new be()),
      (this.projectionMatrix = new be()),
      (this.projectionMatrixInverse = new be());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Vo.prototype.isCamera = !0;
class Yt extends Vo {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super();
    (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = ms * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(os * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return ms * 2 * Math.atan(Math.tan(os * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, i, r, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(os * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      r = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      (r += (o.offsetX * i) / l),
        (t -= (o.offsetY * n) / c),
        (i *= o.width / l),
        (n *= o.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (r += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
Yt.prototype.isPerspectiveCamera = !0;
const $i = 90,
  Ki = 1;
class Nl extends at {
  constructor(e, t, n) {
    super();
    if (((this.type = "CubeCamera"), n.isWebGLCubeRenderTarget !== !0)) {
      console.error(
        "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
      );
      return;
    }
    this.renderTarget = n;
    const i = new Yt($i, Ki, e, t);
    (i.layers = this.layers),
      i.up.set(0, -1, 0),
      i.lookAt(new P(1, 0, 0)),
      this.add(i);
    const r = new Yt($i, Ki, e, t);
    (r.layers = this.layers),
      r.up.set(0, -1, 0),
      r.lookAt(new P(-1, 0, 0)),
      this.add(r);
    const o = new Yt($i, Ki, e, t);
    (o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(new P(0, 1, 0)),
      this.add(o);
    const a = new Yt($i, Ki, e, t);
    (a.layers = this.layers),
      a.up.set(0, 0, -1),
      a.lookAt(new P(0, -1, 0)),
      this.add(a);
    const l = new Yt($i, Ki, e, t);
    (l.layers = this.layers),
      l.up.set(0, -1, 0),
      l.lookAt(new P(0, 0, 1)),
      this.add(l);
    const c = new Yt($i, Ki, e, t);
    (c.layers = this.layers),
      c.up.set(0, -1, 0),
      c.lookAt(new P(0, 0, -1)),
      this.add(c);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget,
      [i, r, o, a, l, c] = this.children,
      h = e.xr.enabled,
      u = e.getRenderTarget();
    e.xr.enabled = !1;
    const d = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0),
      e.render(t, i),
      e.setRenderTarget(n, 1),
      e.render(t, r),
      e.setRenderTarget(n, 2),
      e.render(t, o),
      e.setRenderTarget(n, 3),
      e.render(t, a),
      e.setRenderTarget(n, 4),
      e.render(t, l),
      (n.texture.generateMipmaps = d),
      e.setRenderTarget(n, 5),
      e.render(t, c),
      e.setRenderTarget(u),
      (e.xr.enabled = h),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class Wo extends At {
  constructor(e, t, n, i, r, o, a, l, c, h) {
    (e = e !== void 0 ? e : []), (t = t !== void 0 ? t : vr);
    super(e, t, n, i, r, o, a, l, c, h);
    this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
Wo.prototype.isCubeTexture = !0;
class Pu extends Bt {
  constructor(e, t = {}) {
    super(e, e, t);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    (this.texture = new Wo(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : st);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.format = Nt),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Cs(5, 5, 5),
      r = new Vt({
        name: "CubemapFromEquirect",
        uniforms: wr(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Ut,
        blending: ci,
      });
    r.uniforms.tEquirect.value = t;
    const o = new jt(i, r),
      a = t.minFilter;
    return (
      t.minFilter === yi && (t.minFilter = st),
      new Nl(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
Pu.prototype.isWebGLCubeRenderTarget = !0;
const Ca = new P(),
  kp = new P(),
  Hp = new Gt();
class Xn {
  constructor(e = new P(1, 0, 0), t = 0) {
    (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = Ca.subVectors(n, t).cross(kp.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const n = e.delta(Ca),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Hp.getNormalMatrix(e),
      i = this.coplanarPoint(Ca).applyMatrix4(e),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(r)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Xn.prototype.isPlane = !0;
const Ji = new Fi(),
  to = new P();
class Xo {
  constructor(
    e = new Xn(),
    t = new Xn(),
    n = new Xn(),
    i = new Xn(),
    r = new Xn(),
    o = new Xn()
  ) {
    this.planes = [e, t, n, i, r, o];
  }
  set(e, t, n, i, r, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(n),
      a[3].copy(i),
      a[4].copy(r),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      n = e.elements,
      i = n[0],
      r = n[1],
      o = n[2],
      a = n[3],
      l = n[4],
      c = n[5],
      h = n[6],
      u = n[7],
      d = n[8],
      f = n[9],
      m = n[10],
      v = n[11],
      y = n[12],
      p = n[13],
      g = n[14],
      w = n[15];
    return (
      t[0].setComponents(a - i, u - l, v - d, w - y).normalize(),
      t[1].setComponents(a + i, u + l, v + d, w + y).normalize(),
      t[2].setComponents(a + r, u + c, v + f, w + p).normalize(),
      t[3].setComponents(a - r, u - c, v - f, w - p).normalize(),
      t[4].setComponents(a - o, u - h, v - m, w - g).normalize(),
      t[5].setComponents(a + o, u + h, v + m, w + g).normalize(),
      this
    );
  }
  intersectsObject(e) {
    const t = e.geometry;
    return (
      t.boundingSphere === null && t.computeBoundingSphere(),
      Ji.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ji)
    );
  }
  intersectsSprite(e) {
    return (
      Ji.center.set(0, 0, 0),
      (Ji.radius = 0.7071067811865476),
      Ji.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ji)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((to.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (to.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (to.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(to) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Iu() {
  let s = null,
    e = !1,
    t = null,
    n = null;
  function i(r, o) {
    t(r, o), (n = s.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = s.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      s.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (r) {
      t = r;
    },
    setContext: function (r) {
      s = r;
    },
  };
}
function Gp(s, e) {
  const t = e.isWebGL2,
    n = new WeakMap();
  function i(c, h) {
    const u = c.array,
      d = c.usage,
      f = s.createBuffer();
    s.bindBuffer(h, f), s.bufferData(h, u, d), c.onUploadCallback();
    let m;
    if (u instanceof Float32Array) m = 5126;
    else if (u instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t) m = 5131;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else m = 5123;
    else if (u instanceof Int16Array) m = 5122;
    else if (u instanceof Uint32Array) m = 5125;
    else if (u instanceof Int32Array) m = 5124;
    else if (u instanceof Int8Array) m = 5120;
    else if (u instanceof Uint8Array) m = 5121;
    else if (u instanceof Uint8ClampedArray) m = 5121;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + u
      );
    return {
      buffer: f,
      type: m,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: c.version,
    };
  }
  function r(c, h, u) {
    const d = h.array,
      f = h.updateRange;
    s.bindBuffer(u, c),
      f.count === -1
        ? s.bufferSubData(u, 0, d)
        : (t
            ? s.bufferSubData(
                u,
                f.offset * d.BYTES_PER_ELEMENT,
                d,
                f.offset,
                f.count
              )
            : s.bufferSubData(
                u,
                f.offset * d.BYTES_PER_ELEMENT,
                d.subarray(f.offset, f.offset + f.count)
              ),
          (f.count = -1));
  }
  function o(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
  }
  function a(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = n.get(c);
    h && (s.deleteBuffer(h.buffer), n.delete(c));
  }
  function l(c, h) {
    if (c.isGLBufferAttribute) {
      const d = n.get(c);
      (!d || d.version < c.version) &&
        n.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = n.get(c);
    u === void 0
      ? n.set(c, i(c, h))
      : u.version < c.version && (r(u.buffer, c, h), (u.version = c.version));
  }
  return { get: o, remove: a, update: l };
}
class Bl extends tt {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super();
    (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const r = e / 2,
      o = t / 2,
      a = Math.floor(n),
      l = Math.floor(i),
      c = a + 1,
      h = l + 1,
      u = e / a,
      d = t / l,
      f = [],
      m = [],
      v = [],
      y = [];
    for (let p = 0; p < h; p++) {
      const g = p * d - o;
      for (let w = 0; w < c; w++) {
        const b = w * u - r;
        m.push(b, -g, 0), v.push(0, 0, 1), y.push(w / a), y.push(1 - p / l);
      }
    }
    for (let p = 0; p < l; p++)
      for (let g = 0; g < a; g++) {
        const w = g + c * p,
          b = g + c * (p + 1),
          _ = g + 1 + c * (p + 1),
          E = g + 1 + c * p;
        f.push(w, b, E), f.push(b, _, E);
      }
    this.setIndex(f),
      this.setAttribute("position", new Je(m, 3)),
      this.setAttribute("normal", new Je(v, 3)),
      this.setAttribute("uv", new Je(y, 2));
  }
  static fromJSON(e) {
    return new Bl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var Vp = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  Wp = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Xp = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  jp = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  qp = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  Yp = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  Zp = "vec3 transformed = vec3( position );",
  $p = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Kp = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
  Jp = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Qp = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  em = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  tm = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  nm = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  im = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  rm = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  sm = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  om = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  am = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  lm = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  cm = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  hm = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  um = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  dm = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  fm = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  pm = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  mm = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  gm = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  vm = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  xm = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  ym = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  _m = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  wm = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  bm = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  Mm = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  Sm = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  Tm = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
  Em = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  Am = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Cm = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
  Rm = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Lm = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  Pm = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  Im = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
  Dm = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  Fm = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
  Nm = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
  Bm = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Om = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Um = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  zm = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  km = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Hm = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Gm = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  Vm = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  Wm = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Xm = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  jm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  qm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Ym = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Zm = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  $m = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ]
		#endif
	}
#endif`,
  Km = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  Jm = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			float texelIndex = float( vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  Qm = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  eg = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  tg = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  ng = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  ig = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  rg = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  sg = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
  og = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  ag = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
  lg = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  cg = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  hg = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  ug = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  dg = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  fg = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  pg = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  mg = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  gg = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  vg = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  xg = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  yg = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
  _g = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  wg = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  bg = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
  Mg = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  Sg = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  Tg = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  Eg = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  Ag = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  Cg = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  Rg = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
  Lg = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  Pg = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  Ig = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  Dg = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  Fg = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  Ng = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  Bg = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  Og = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Ug = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  zg = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  kg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Hg = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  Gg = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  Vg = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  Wg = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  Xg = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  jg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  qg = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  Yg = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Zg = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  $g = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Kg = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Jg = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Qg = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  e0 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  t0 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  n0 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  i0 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  r0 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  s0 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  o0 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  a0 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  l0 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  c0 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  h0 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  u0 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  d0 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  f0 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  p0 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  m0 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Qe = {
    alphamap_fragment: Vp,
    alphamap_pars_fragment: Wp,
    alphatest_fragment: Xp,
    alphatest_pars_fragment: jp,
    aomap_fragment: qp,
    aomap_pars_fragment: Yp,
    begin_vertex: Zp,
    beginnormal_vertex: $p,
    bsdfs: Kp,
    bumpmap_pars_fragment: Jp,
    clipping_planes_fragment: Qp,
    clipping_planes_pars_fragment: em,
    clipping_planes_pars_vertex: tm,
    clipping_planes_vertex: nm,
    color_fragment: im,
    color_pars_fragment: rm,
    color_pars_vertex: sm,
    color_vertex: om,
    common: am,
    cube_uv_reflection_fragment: lm,
    defaultnormal_vertex: cm,
    displacementmap_pars_vertex: hm,
    displacementmap_vertex: um,
    emissivemap_fragment: dm,
    emissivemap_pars_fragment: fm,
    encodings_fragment: pm,
    encodings_pars_fragment: mm,
    envmap_fragment: gm,
    envmap_common_pars_fragment: vm,
    envmap_pars_fragment: xm,
    envmap_pars_vertex: ym,
    envmap_physical_pars_fragment: Lm,
    envmap_vertex: _m,
    fog_vertex: wm,
    fog_pars_vertex: bm,
    fog_fragment: Mm,
    fog_pars_fragment: Sm,
    gradientmap_pars_fragment: Tm,
    lightmap_fragment: Em,
    lightmap_pars_fragment: Am,
    lights_lambert_vertex: Cm,
    lights_pars_begin: Rm,
    lights_toon_fragment: Pm,
    lights_toon_pars_fragment: Im,
    lights_phong_fragment: Dm,
    lights_phong_pars_fragment: Fm,
    lights_physical_fragment: Nm,
    lights_physical_pars_fragment: Bm,
    lights_fragment_begin: Om,
    lights_fragment_maps: Um,
    lights_fragment_end: zm,
    logdepthbuf_fragment: km,
    logdepthbuf_pars_fragment: Hm,
    logdepthbuf_pars_vertex: Gm,
    logdepthbuf_vertex: Vm,
    map_fragment: Wm,
    map_pars_fragment: Xm,
    map_particle_fragment: jm,
    map_particle_pars_fragment: qm,
    metalnessmap_fragment: Ym,
    metalnessmap_pars_fragment: Zm,
    morphcolor_vertex: $m,
    morphnormal_vertex: Km,
    morphtarget_pars_vertex: Jm,
    morphtarget_vertex: Qm,
    normal_fragment_begin: eg,
    normal_fragment_maps: tg,
    normal_pars_fragment: ng,
    normal_pars_vertex: ig,
    normal_vertex: rg,
    normalmap_pars_fragment: sg,
    clearcoat_normal_fragment_begin: og,
    clearcoat_normal_fragment_maps: ag,
    clearcoat_pars_fragment: lg,
    output_fragment: cg,
    packing: hg,
    premultiplied_alpha_fragment: ug,
    project_vertex: dg,
    dithering_fragment: fg,
    dithering_pars_fragment: pg,
    roughnessmap_fragment: mg,
    roughnessmap_pars_fragment: gg,
    shadowmap_pars_fragment: vg,
    shadowmap_pars_vertex: xg,
    shadowmap_vertex: yg,
    shadowmask_pars_fragment: _g,
    skinbase_vertex: wg,
    skinning_pars_vertex: bg,
    skinning_vertex: Mg,
    skinnormal_vertex: Sg,
    specularmap_fragment: Tg,
    specularmap_pars_fragment: Eg,
    tonemapping_fragment: Ag,
    tonemapping_pars_fragment: Cg,
    transmission_fragment: Rg,
    transmission_pars_fragment: Lg,
    uv_pars_fragment: Pg,
    uv_pars_vertex: Ig,
    uv_vertex: Dg,
    uv2_pars_fragment: Fg,
    uv2_pars_vertex: Ng,
    uv2_vertex: Bg,
    worldpos_vertex: Og,
    background_vert: Ug,
    background_frag: zg,
    cube_vert: kg,
    cube_frag: Hg,
    depth_vert: Gg,
    depth_frag: Vg,
    distanceRGBA_vert: Wg,
    distanceRGBA_frag: Xg,
    equirect_vert: jg,
    equirect_frag: qg,
    linedashed_vert: Yg,
    linedashed_frag: Zg,
    meshbasic_vert: $g,
    meshbasic_frag: Kg,
    meshlambert_vert: Jg,
    meshlambert_frag: Qg,
    meshmatcap_vert: e0,
    meshmatcap_frag: t0,
    meshnormal_vert: n0,
    meshnormal_frag: i0,
    meshphong_vert: r0,
    meshphong_frag: s0,
    meshphysical_vert: o0,
    meshphysical_frag: a0,
    meshtoon_vert: l0,
    meshtoon_frag: c0,
    points_vert: h0,
    points_frag: u0,
    shadow_vert: d0,
    shadow_frag: f0,
    sprite_vert: p0,
    sprite_frag: m0,
  },
  Ae = {
    common: {
      diffuse: { value: new ye(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Gt() },
      uv2Transform: { value: new Gt() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new ae(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new ye(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new ye(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Gt() },
    },
    sprite: {
      diffuse: { value: new ye(16777215) },
      opacity: { value: 1 },
      center: { value: new ae(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Gt() },
    },
  },
  Cn = {
    basic: {
      uniforms: qt([
        Ae.common,
        Ae.specularmap,
        Ae.envmap,
        Ae.aomap,
        Ae.lightmap,
        Ae.fog,
      ]),
      vertexShader: Qe.meshbasic_vert,
      fragmentShader: Qe.meshbasic_frag,
    },
    lambert: {
      uniforms: qt([
        Ae.common,
        Ae.specularmap,
        Ae.envmap,
        Ae.aomap,
        Ae.lightmap,
        Ae.emissivemap,
        Ae.fog,
        Ae.lights,
        { emissive: { value: new ye(0) } },
      ]),
      vertexShader: Qe.meshlambert_vert,
      fragmentShader: Qe.meshlambert_frag,
    },
    phong: {
      uniforms: qt([
        Ae.common,
        Ae.specularmap,
        Ae.envmap,
        Ae.aomap,
        Ae.lightmap,
        Ae.emissivemap,
        Ae.bumpmap,
        Ae.normalmap,
        Ae.displacementmap,
        Ae.fog,
        Ae.lights,
        {
          emissive: { value: new ye(0) },
          specular: { value: new ye(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Qe.meshphong_vert,
      fragmentShader: Qe.meshphong_frag,
    },
    standard: {
      uniforms: qt([
        Ae.common,
        Ae.envmap,
        Ae.aomap,
        Ae.lightmap,
        Ae.emissivemap,
        Ae.bumpmap,
        Ae.normalmap,
        Ae.displacementmap,
        Ae.roughnessmap,
        Ae.metalnessmap,
        Ae.fog,
        Ae.lights,
        {
          emissive: { value: new ye(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Qe.meshphysical_vert,
      fragmentShader: Qe.meshphysical_frag,
    },
    toon: {
      uniforms: qt([
        Ae.common,
        Ae.aomap,
        Ae.lightmap,
        Ae.emissivemap,
        Ae.bumpmap,
        Ae.normalmap,
        Ae.displacementmap,
        Ae.gradientmap,
        Ae.fog,
        Ae.lights,
        { emissive: { value: new ye(0) } },
      ]),
      vertexShader: Qe.meshtoon_vert,
      fragmentShader: Qe.meshtoon_frag,
    },
    matcap: {
      uniforms: qt([
        Ae.common,
        Ae.bumpmap,
        Ae.normalmap,
        Ae.displacementmap,
        Ae.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Qe.meshmatcap_vert,
      fragmentShader: Qe.meshmatcap_frag,
    },
    points: {
      uniforms: qt([Ae.points, Ae.fog]),
      vertexShader: Qe.points_vert,
      fragmentShader: Qe.points_frag,
    },
    dashed: {
      uniforms: qt([
        Ae.common,
        Ae.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Qe.linedashed_vert,
      fragmentShader: Qe.linedashed_frag,
    },
    depth: {
      uniforms: qt([Ae.common, Ae.displacementmap]),
      vertexShader: Qe.depth_vert,
      fragmentShader: Qe.depth_frag,
    },
    normal: {
      uniforms: qt([
        Ae.common,
        Ae.bumpmap,
        Ae.normalmap,
        Ae.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Qe.meshnormal_vert,
      fragmentShader: Qe.meshnormal_frag,
    },
    sprite: {
      uniforms: qt([Ae.sprite, Ae.fog]),
      vertexShader: Qe.sprite_vert,
      fragmentShader: Qe.sprite_frag,
    },
    background: {
      uniforms: { uvTransform: { value: new Gt() }, t2D: { value: null } },
      vertexShader: Qe.background_vert,
      fragmentShader: Qe.background_frag,
    },
    cube: {
      uniforms: qt([Ae.envmap, { opacity: { value: 1 } }]),
      vertexShader: Qe.cube_vert,
      fragmentShader: Qe.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Qe.equirect_vert,
      fragmentShader: Qe.equirect_frag,
    },
    distanceRGBA: {
      uniforms: qt([
        Ae.common,
        Ae.displacementmap,
        {
          referencePosition: { value: new P() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Qe.distanceRGBA_vert,
      fragmentShader: Qe.distanceRGBA_frag,
    },
    shadow: {
      uniforms: qt([
        Ae.lights,
        Ae.fog,
        { color: { value: new ye(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Qe.shadow_vert,
      fragmentShader: Qe.shadow_frag,
    },
  };
Cn.physical = {
  uniforms: qt([
    Cn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new ae(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new ye(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new ae() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new ye(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new ye(1, 1, 1) },
      specularColorMap: { value: null },
    },
  ]),
  vertexShader: Qe.meshphysical_vert,
  fragmentShader: Qe.meshphysical_frag,
};
function g0(s, e, t, n, i, r) {
  const o = new ye(0);
  let a = i === !0 ? 0 : 1,
    l,
    c,
    h = null,
    u = 0,
    d = null;
  function f(v, y) {
    let p = !1,
      g = y.isScene === !0 ? y.background : null;
    g && g.isTexture && (g = e.get(g));
    const w = s.xr,
      b = w.getSession && w.getSession();
    b && b.environmentBlendMode === "additive" && (g = null),
      g === null ? m(o, a) : g && g.isColor && (m(g, 1), (p = !0)),
      (s.autoClear || p) &&
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
      g && (g.isCubeTexture || g.mapping === Ho)
        ? (c === void 0 &&
            ((c = new jt(
              new Cs(1, 1, 1),
              new Vt({
                name: "BackgroundCubeMaterial",
                uniforms: wr(Cn.cube.uniforms),
                vertexShader: Cn.cube.vertexShader,
                fragmentShader: Cn.cube.fragmentShader,
                side: Ut,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            c.geometry.deleteAttribute("uv"),
            (c.onBeforeRender = function (_, E, L) {
              this.matrixWorld.copyPosition(L.matrixWorld);
            }),
            Object.defineProperty(c.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            n.update(c)),
          (c.material.uniforms.envMap.value = g),
          (c.material.uniforms.flipEnvMap.value =
            g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1),
          (h !== g || u !== g.version || d !== s.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (h = g),
            (u = g.version),
            (d = s.toneMapping)),
          v.unshift(c, c.geometry, c.material, 0, 0, null))
        : g &&
          g.isTexture &&
          (l === void 0 &&
            ((l = new jt(
              new Bl(2, 2),
              new Vt({
                name: "BackgroundMaterial",
                uniforms: wr(Cn.background.uniforms),
                vertexShader: Cn.background.vertexShader,
                fragmentShader: Cn.background.fragmentShader,
                side: gr,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            l.geometry.deleteAttribute("normal"),
            Object.defineProperty(l.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            n.update(l)),
          (l.material.uniforms.t2D.value = g),
          g.matrixAutoUpdate === !0 && g.updateMatrix(),
          l.material.uniforms.uvTransform.value.copy(g.matrix),
          (h !== g || u !== g.version || d !== s.toneMapping) &&
            ((l.material.needsUpdate = !0),
            (h = g),
            (u = g.version),
            (d = s.toneMapping)),
          v.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function m(v, y) {
    t.buffers.color.setClear(v.r, v.g, v.b, y, r);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (v, y = 1) {
      o.set(v), (a = y), m(o, a);
    },
    getClearAlpha: function () {
      return a;
    },
    setClearAlpha: function (v) {
      (a = v), m(o, a);
    },
    render: f,
  };
}
function v0(s, e, t, n) {
  const i = s.getParameter(34921),
    r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = n.isWebGL2 || r !== null,
    a = {},
    l = v(null);
  let c = l;
  function h(N, O, H, G, W) {
    let k = !1;
    if (o) {
      const Q = m(G, H, O);
      c !== Q && ((c = Q), d(c.object)), (k = y(G, W)), k && p(G, W);
    } else {
      const Q = O.wireframe === !0;
      (c.geometry !== G.id || c.program !== H.id || c.wireframe !== Q) &&
        ((c.geometry = G.id), (c.program = H.id), (c.wireframe = Q), (k = !0));
    }
    N.isInstancedMesh === !0 && (k = !0),
      W !== null && t.update(W, 34963),
      k && (L(N, O, H, G), W !== null && s.bindBuffer(34963, t.get(W).buffer));
  }
  function u() {
    return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
  }
  function d(N) {
    return n.isWebGL2 ? s.bindVertexArray(N) : r.bindVertexArrayOES(N);
  }
  function f(N) {
    return n.isWebGL2 ? s.deleteVertexArray(N) : r.deleteVertexArrayOES(N);
  }
  function m(N, O, H) {
    const G = H.wireframe === !0;
    let W = a[N.id];
    W === void 0 && ((W = {}), (a[N.id] = W));
    let k = W[O.id];
    k === void 0 && ((k = {}), (W[O.id] = k));
    let Q = k[G];
    return Q === void 0 && ((Q = v(u())), (k[G] = Q)), Q;
  }
  function v(N) {
    const O = [],
      H = [],
      G = [];
    for (let W = 0; W < i; W++) (O[W] = 0), (H[W] = 0), (G[W] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: O,
      enabledAttributes: H,
      attributeDivisors: G,
      object: N,
      attributes: {},
      index: null,
    };
  }
  function y(N, O) {
    const H = c.attributes,
      G = N.attributes;
    let W = 0;
    for (const k in G) {
      const Q = H[k],
        ie = G[k];
      if (Q === void 0 || Q.attribute !== ie || Q.data !== ie.data) return !0;
      W++;
    }
    return c.attributesNum !== W || c.index !== O;
  }
  function p(N, O) {
    const H = {},
      G = N.attributes;
    let W = 0;
    for (const k in G) {
      const Q = G[k],
        ie = {};
      (ie.attribute = Q), Q.data && (ie.data = Q.data), (H[k] = ie), W++;
    }
    (c.attributes = H), (c.attributesNum = W), (c.index = O);
  }
  function g() {
    const N = c.newAttributes;
    for (let O = 0, H = N.length; O < H; O++) N[O] = 0;
  }
  function w(N) {
    b(N, 0);
  }
  function b(N, O) {
    const H = c.newAttributes,
      G = c.enabledAttributes,
      W = c.attributeDivisors;
    (H[N] = 1),
      G[N] === 0 && (s.enableVertexAttribArray(N), (G[N] = 1)),
      W[N] !== O &&
        ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[
          n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](N, O),
        (W[N] = O));
  }
  function _() {
    const N = c.newAttributes,
      O = c.enabledAttributes;
    for (let H = 0, G = O.length; H < G; H++)
      O[H] !== N[H] && (s.disableVertexAttribArray(H), (O[H] = 0));
  }
  function E(N, O, H, G, W, k) {
    n.isWebGL2 === !0 && (H === 5124 || H === 5125)
      ? s.vertexAttribIPointer(N, O, H, W, k)
      : s.vertexAttribPointer(N, O, H, G, W, k);
  }
  function L(N, O, H, G) {
    if (
      n.isWebGL2 === !1 &&
      (N.isInstancedMesh || G.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    g();
    const W = G.attributes,
      k = H.getAttributes(),
      Q = O.defaultAttributeValues;
    for (const ie in k) {
      const re = k[ie];
      if (re.location >= 0) {
        let ee = W[ie];
        if (
          (ee === void 0 &&
            (ie === "instanceMatrix" &&
              N.instanceMatrix &&
              (ee = N.instanceMatrix),
            ie === "instanceColor" &&
              N.instanceColor &&
              (ee = N.instanceColor)),
          ee !== void 0)
        ) {
          const Me = ee.normalized,
            Be = ee.itemSize,
            Re = t.get(ee);
          if (Re === void 0) continue;
          const Z = Re.buffer,
            qe = Re.type,
            ke = Re.bytesPerElement;
          if (ee.isInterleavedBufferAttribute) {
            const Fe = ee.data,
              Ie = Fe.stride,
              Ze = ee.offset;
            if (Fe.isInstancedInterleavedBuffer) {
              for (let K = 0; K < re.locationSize; K++)
                b(re.location + K, Fe.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                G._maxInstanceCount === void 0 &&
                (G._maxInstanceCount = Fe.meshPerAttribute * Fe.count);
            } else for (let K = 0; K < re.locationSize; K++) w(re.location + K);
            s.bindBuffer(34962, Z);
            for (let K = 0; K < re.locationSize; K++)
              E(
                re.location + K,
                Be / re.locationSize,
                qe,
                Me,
                Ie * ke,
                (Ze + (Be / re.locationSize) * K) * ke
              );
          } else {
            if (ee.isInstancedBufferAttribute) {
              for (let Fe = 0; Fe < re.locationSize; Fe++)
                b(re.location + Fe, ee.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                G._maxInstanceCount === void 0 &&
                (G._maxInstanceCount = ee.meshPerAttribute * ee.count);
            } else
              for (let Fe = 0; Fe < re.locationSize; Fe++) w(re.location + Fe);
            s.bindBuffer(34962, Z);
            for (let Fe = 0; Fe < re.locationSize; Fe++)
              E(
                re.location + Fe,
                Be / re.locationSize,
                qe,
                Me,
                Be * ke,
                (Be / re.locationSize) * Fe * ke
              );
          }
        } else if (Q !== void 0) {
          const Me = Q[ie];
          if (Me !== void 0)
            switch (Me.length) {
              case 2:
                s.vertexAttrib2fv(re.location, Me);
                break;
              case 3:
                s.vertexAttrib3fv(re.location, Me);
                break;
              case 4:
                s.vertexAttrib4fv(re.location, Me);
                break;
              default:
                s.vertexAttrib1fv(re.location, Me);
            }
        }
      }
    }
    _();
  }
  function D() {
    M();
    for (const N in a) {
      const O = a[N];
      for (const H in O) {
        const G = O[H];
        for (const W in G) f(G[W].object), delete G[W];
        delete O[H];
      }
      delete a[N];
    }
  }
  function V(N) {
    if (a[N.id] === void 0) return;
    const O = a[N.id];
    for (const H in O) {
      const G = O[H];
      for (const W in G) f(G[W].object), delete G[W];
      delete O[H];
    }
    delete a[N.id];
  }
  function F(N) {
    for (const O in a) {
      const H = a[O];
      if (H[N.id] === void 0) continue;
      const G = H[N.id];
      for (const W in G) f(G[W].object), delete G[W];
      delete H[N.id];
    }
  }
  function M() {
    A(), c !== l && ((c = l), d(c.object));
  }
  function A() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: h,
    reset: M,
    resetDefaultState: A,
    dispose: D,
    releaseStatesOfGeometry: V,
    releaseStatesOfProgram: F,
    initAttributes: g,
    enableAttribute: w,
    disableUnusedAttributes: _,
  };
}
function x0(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function o(c) {
    r = c;
  }
  function a(c, h) {
    s.drawArrays(r, c, h), t.update(h, r, 1);
  }
  function l(c, h, u) {
    if (u === 0) return;
    let d, f;
    if (i) (d = s), (f = "drawArraysInstanced");
    else if (
      ((d = e.get("ANGLE_instanced_arrays")),
      (f = "drawArraysInstancedANGLE"),
      d === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    d[f](r, c, h, u), t.update(h, r, u);
  }
  (this.setMode = o), (this.render = a), (this.renderInstances = l);
}
function y0(s, e, t) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const L = e.get("EXT_texture_filter_anisotropic");
      n = s.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function r(L) {
    if (L === "highp") {
      if (
        s.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        s.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      L = "mediump";
    }
    return L === "mediump" &&
      s.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      s.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const o =
    (typeof WebGL2RenderingContext != "undefined" &&
      s instanceof WebGL2RenderingContext) ||
    (typeof WebGL2ComputeRenderingContext != "undefined" &&
      s instanceof WebGL2ComputeRenderingContext);
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = r(a);
  l !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      l,
      "instead."
    ),
    (a = l));
  const c = o || e.has("WEBGL_draw_buffers"),
    h = t.logarithmicDepthBuffer === !0,
    u = s.getParameter(34930),
    d = s.getParameter(35660),
    f = s.getParameter(3379),
    m = s.getParameter(34076),
    v = s.getParameter(34921),
    y = s.getParameter(36347),
    p = s.getParameter(36348),
    g = s.getParameter(36349),
    w = d > 0,
    b = o || e.has("OES_texture_float"),
    _ = w && b,
    E = o ? s.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    drawBuffers: c,
    getMaxAnisotropy: i,
    getMaxPrecision: r,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: u,
    maxVertexTextures: d,
    maxTextureSize: f,
    maxCubemapSize: m,
    maxAttributes: v,
    maxVertexUniforms: y,
    maxVaryings: p,
    maxFragmentUniforms: g,
    vertexTextures: w,
    floatFragmentTextures: b,
    floatVertexTextures: _,
    maxSamples: E,
  };
}
function _0(s) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    r = !1;
  const o = new Xn(),
    a = new Gt(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (u, d, f) {
      const m = u.length !== 0 || d || n !== 0 || i;
      return (i = d), (t = h(u, f, 0)), (n = u.length), m;
    }),
    (this.beginShadows = function () {
      (r = !0), h(null);
    }),
    (this.endShadows = function () {
      (r = !1), c();
    }),
    (this.setState = function (u, d, f) {
      const m = u.clippingPlanes,
        v = u.clipIntersection,
        y = u.clipShadows,
        p = s.get(u);
      if (!i || m === null || m.length === 0 || (r && !y)) r ? h(null) : c();
      else {
        const g = r ? 0 : n,
          w = g * 4;
        let b = p.clippingState || null;
        (l.value = b), (b = h(m, d, w, f));
        for (let _ = 0; _ !== w; ++_) b[_] = t[_];
        (p.clippingState = b),
          (this.numIntersection = v ? this.numPlanes : 0),
          (this.numPlanes += g);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function h(u, d, f, m) {
    const v = u !== null ? u.length : 0;
    let y = null;
    if (v !== 0) {
      if (((y = l.value), m !== !0 || y === null)) {
        const p = f + v * 4,
          g = d.matrixWorldInverse;
        a.getNormalMatrix(g),
          (y === null || y.length < p) && (y = new Float32Array(p));
        for (let w = 0, b = f; w !== v; ++w, b += 4)
          o.copy(u[w]).applyMatrix4(g, a),
            o.normal.toArray(y, b),
            (y[b + 3] = o.constant);
      }
      (l.value = y), (l.needsUpdate = !0);
    }
    return (e.numPlanes = v), (e.numIntersection = 0), y;
  }
}
function w0(s) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Eo ? (o.mapping = vr) : a === Qa && (o.mapping = xr), o;
  }
  function n(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === Eo || a === Qa)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new Pu(l.height / 2);
            return (
              c.fromEquirectangularTexture(s, o),
              e.set(o, c),
              o.addEventListener("dispose", i),
              t(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function r() {
    e = new WeakMap();
  }
  return { get: n, dispose: r };
}
class Ni extends Vo {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
    super();
    (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = r),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, r, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let r = n - e,
      o = n + e,
      a = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += c * this.view.offsetX),
        (o = r + c * this.view.width),
        (a -= h * this.view.offsetY),
        (l = a - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
Ni.prototype.isOrthographicCamera = !0;
const hr = 4,
  Zc = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Ci = 20,
  Ra = new Ni(),
  $c = new ye();
let La = null;
const Ei = (1 + Math.sqrt(5)) / 2,
  Qi = 1 / Ei,
  Kc = [
    new P(1, 1, 1),
    new P(-1, 1, 1),
    new P(1, 1, -1),
    new P(-1, 1, -1),
    new P(0, Ei, Qi),
    new P(0, Ei, -Qi),
    new P(Qi, 0, Ei),
    new P(-Qi, 0, Ei),
    new P(Ei, Qi, 0),
    new P(-Ei, Qi, 0),
  ];
class Jc {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (La = this._renderer.getRenderTarget()), this._setSize(256);
    const r = this._allocateTargets();
    return (
      (r.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, r),
      t > 0 && this._blur(r, 0, 0, t),
      this._applyPMREM(r),
      this._cleanup(r),
      r
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = th()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = eh()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(La),
      (e.scissorTest = !1),
      no(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === vr || e.mapping === xr
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (La = this._renderer.getRenderTarget());
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize - 32,
      n = {
        magFilter: st,
        minFilter: st,
        generateMipmaps: !1,
        type: nn,
        format: Nt,
        encoding: an,
        depthBuffer: !1,
      },
      i = Qc(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Qc(e, t, n));
      const { _lodMax: r } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = b0(r)),
        (this._blurMaterial = M0(r, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new jt(this._lodPlanes[0], e);
    this._renderer.compile(t, Ra);
  }
  _sceneToCubeUV(e, t, n, i) {
    const a = new Yt(90, 1, t, n),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      u = h.autoClear,
      d = h.toneMapping;
    h.getClearColor($c), (h.toneMapping = hi), (h.autoClear = !1);
    const f = new Rn({
        name: "PMREM.Background",
        side: Ut,
        depthWrite: !1,
        depthTest: !1,
      }),
      m = new jt(new Cs(), f);
    let v = !1;
    const y = e.background;
    y
      ? y.isColor && (f.color.copy(y), (e.background = null), (v = !0))
      : (f.color.copy($c), (v = !0));
    for (let p = 0; p < 6; p++) {
      const g = p % 3;
      g === 0
        ? (a.up.set(0, l[p], 0), a.lookAt(c[p], 0, 0))
        : g === 1
        ? (a.up.set(0, 0, l[p]), a.lookAt(0, c[p], 0))
        : (a.up.set(0, l[p], 0), a.lookAt(0, 0, c[p]));
      const w = this._cubeSize;
      no(i, g * w, p > 2 ? w : 0, w, w),
        h.setRenderTarget(i),
        v && h.render(m, a),
        h.render(e, a);
    }
    m.geometry.dispose(),
      m.material.dispose(),
      (h.toneMapping = d),
      (h.autoClear = u),
      (e.background = y);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === vr || e.mapping === xr;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = th()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = eh());
    const r = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new jt(this._lodPlanes[0], r),
      a = r.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    no(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, Ra);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const r = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        o = Kc[(i - 1) % Kc.length];
      this._blur(e, i - 1, i, r, o);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, n, i, "latitudinal", r),
      this._halfBlur(o, e, n, n, i, "longitudinal", r);
  }
  _halfBlur(e, t, n, i, r, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      u = new jt(this._lodPlanes[i], c),
      d = c.uniforms,
      f = this._sizeLods[n] - 1,
      m = isFinite(r) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * Ci - 1),
      v = r / m,
      y = isFinite(r) ? 1 + Math.floor(h * v) : Ci;
    y > Ci &&
      console.warn(
        `sigmaRadians, ${r}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Ci}`
      );
    const p = [];
    let g = 0;
    for (let L = 0; L < Ci; ++L) {
      const D = L / v,
        V = Math.exp((-D * D) / 2);
      p.push(V), L === 0 ? (g += V) : L < y && (g += 2 * V);
    }
    for (let L = 0; L < p.length; L++) p[L] = p[L] / g;
    (d.envMap.value = e.texture),
      (d.samples.value = y),
      (d.weights.value = p),
      (d.latitudinal.value = o === "latitudinal"),
      a && (d.poleAxis.value = a);
    const { _lodMax: w } = this;
    (d.dTheta.value = m), (d.mipInt.value = w - n);
    const b = this._sizeLods[i],
      _ = 3 * b * (i > w - hr ? i - w + hr : 0),
      E = 4 * (this._cubeSize - b);
    no(t, _, E, 3 * b, 2 * b), l.setRenderTarget(t), l.render(u, Ra);
  }
}
function b0(s) {
  const e = [],
    t = [],
    n = [];
  let i = s;
  const r = s - hr + 1 + Zc.length;
  for (let o = 0; o < r; o++) {
    const a = Math.pow(2, i);
    t.push(a);
    let l = 1 / a;
    o > s - hr ? (l = Zc[o - s + hr - 1]) : o === 0 && (l = 0), n.push(l);
    const c = 1 / (a - 1),
      h = -c / 2,
      u = 1 + c / 2,
      d = [h, h, u, h, u, u, h, h, u, u, h, u],
      f = 6,
      m = 6,
      v = 3,
      y = 2,
      p = 1,
      g = new Float32Array(v * m * f),
      w = new Float32Array(y * m * f),
      b = new Float32Array(p * m * f);
    for (let E = 0; E < f; E++) {
      const L = ((E % 3) * 2) / 3 - 1,
        D = E > 2 ? 0 : -1,
        V = [
          L,
          D,
          0,
          L + 2 / 3,
          D,
          0,
          L + 2 / 3,
          D + 1,
          0,
          L,
          D,
          0,
          L + 2 / 3,
          D + 1,
          0,
          L,
          D + 1,
          0,
        ];
      g.set(V, v * m * E), w.set(d, y * m * E);
      const F = [E, E, E, E, E, E];
      b.set(F, p * m * E);
    }
    const _ = new tt();
    _.setAttribute("position", new St(g, v)),
      _.setAttribute("uv", new St(w, y)),
      _.setAttribute("faceIndex", new St(b, p)),
      e.push(_),
      i > hr && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Qc(s, e, t) {
  const n = new Bt(s, e, t);
  return (
    (n.texture.mapping = Ho),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function no(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function M0(s, e, t) {
  const n = new Float32Array(Ci),
    i = new P(0, 1, 0);
  return new Vt({
    name: "SphericalGaussianBlur",
    defines: {
      n: Ci,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Ol(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: ci,
    depthTest: !1,
    depthWrite: !1,
  });
}
function eh() {
  return new Vt({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Ol(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: ci,
    depthTest: !1,
    depthWrite: !1,
  });
}
function th() {
  return new Vt({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Ol(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: ci,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Ol() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function S0(s) {
  let e = new WeakMap(),
    t = null;
  function n(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === Eo || l === Qa,
        h = l === vr || l === xr;
      if (c || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let u = e.get(a);
          return (
            t === null && (t = new Jc(s)),
            (u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u)),
            e.set(a, u),
            u.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const u = a.image;
            if ((c && u && u.height > 0) || (h && u && i(u))) {
              t === null && (t = new Jc(s));
              const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, d), a.addEventListener("dispose", r), d.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
    return l === c;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: o };
}
function T0(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          s.getExtension("WEBGL_depth_texture") ||
          s.getExtension("MOZ_WEBGL_depth_texture") ||
          s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          s.getExtension("EXT_texture_filter_anisotropic") ||
          s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          s.getExtension("WEBGL_compressed_texture_s3tc") ||
          s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          s.getExtension("WEBGL_compressed_texture_pvrtc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function (n) {
      n.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + n + " extension not supported."
          ),
        i
      );
    },
  };
}
function E0(s, e, t, n) {
  const i = {},
    r = new WeakMap();
  function o(u) {
    const d = u.target;
    d.index !== null && e.remove(d.index);
    for (const m in d.attributes) e.remove(d.attributes[m]);
    d.removeEventListener("dispose", o), delete i[d.id];
    const f = r.get(d);
    f && (e.remove(f), r.delete(d)),
      n.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(u, d) {
    return (
      i[d.id] === !0 ||
        (d.addEventListener("dispose", o),
        (i[d.id] = !0),
        t.memory.geometries++),
      d
    );
  }
  function l(u) {
    const d = u.attributes;
    for (const m in d) e.update(d[m], 34962);
    const f = u.morphAttributes;
    for (const m in f) {
      const v = f[m];
      for (let y = 0, p = v.length; y < p; y++) e.update(v[y], 34962);
    }
  }
  function c(u) {
    const d = [],
      f = u.index,
      m = u.attributes.position;
    let v = 0;
    if (f !== null) {
      const g = f.array;
      v = f.version;
      for (let w = 0, b = g.length; w < b; w += 3) {
        const _ = g[w + 0],
          E = g[w + 1],
          L = g[w + 2];
        d.push(_, E, E, L, L, _);
      }
    } else {
      const g = m.array;
      v = m.version;
      for (let w = 0, b = g.length / 3 - 1; w < b; w += 3) {
        const _ = w + 0,
          E = w + 1,
          L = w + 2;
        d.push(_, E, E, L, L, _);
      }
    }
    const y = new (Eu(d) ? Lu : Fl)(d, 1);
    y.version = v;
    const p = r.get(u);
    p && e.remove(p), r.set(u, y);
  }
  function h(u) {
    const d = r.get(u);
    if (d) {
      const f = u.index;
      f !== null && d.version < f.version && c(u);
    } else c(u);
    return r.get(u);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function A0(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function o(d) {
    r = d;
  }
  let a, l;
  function c(d) {
    (a = d.type), (l = d.bytesPerElement);
  }
  function h(d, f) {
    s.drawElements(r, f, a, d * l), t.update(f, r, 1);
  }
  function u(d, f, m) {
    if (m === 0) return;
    let v, y;
    if (i) (v = s), (y = "drawElementsInstanced");
    else if (
      ((v = e.get("ANGLE_instanced_arrays")),
      (y = "drawElementsInstancedANGLE"),
      v === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    v[y](r, f, a, d * l, m), t.update(f, r, m);
  }
  (this.setMode = o),
    (this.setIndex = c),
    (this.render = h),
    (this.renderInstances = u);
}
function C0(s) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(r, o, a) {
    switch ((t.calls++, o)) {
      case 4:
        t.triangles += a * (r / 3);
        break;
      case 1:
        t.lines += a * (r / 2);
        break;
      case 3:
        t.lines += a * (r - 1);
        break;
      case 2:
        t.lines += a * r;
        break;
      case 0:
        t.points += a * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
function R0(s, e) {
  return s[0] - e[0];
}
function L0(s, e) {
  return Math.abs(e[1]) - Math.abs(s[1]);
}
function Pa(s, e) {
  let t = 1;
  const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
  n instanceof Int8Array
    ? (t = 127)
    : n instanceof Int16Array
    ? (t = 32767)
    : n instanceof Int32Array
    ? (t = 2147483647)
    : console.error(
        "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
        n
      ),
    s.divideScalar(t);
}
function P0(s, e, t) {
  const n = {},
    i = new Float32Array(8),
    r = new WeakMap(),
    o = new ct(),
    a = [];
  for (let c = 0; c < 8; c++) a[c] = [c, 0];
  function l(c, h, u, d) {
    const f = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const m =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        v = m !== void 0 ? m.length : 0;
      let y = r.get(h);
      if (y === void 0 || y.count !== v) {
        let H = function () {
          N.dispose(), r.delete(h), h.removeEventListener("dispose", H);
        };
        y !== void 0 && y.texture.dispose();
        const w = h.morphAttributes.position !== void 0,
          b = h.morphAttributes.normal !== void 0,
          _ = h.morphAttributes.color !== void 0,
          E = h.morphAttributes.position || [],
          L = h.morphAttributes.normal || [],
          D = h.morphAttributes.color || [];
        let V = 0;
        w === !0 && (V = 1), b === !0 && (V = 2), _ === !0 && (V = 3);
        let F = h.attributes.position.count * V,
          M = 1;
        F > e.maxTextureSize &&
          ((M = Math.ceil(F / e.maxTextureSize)), (F = e.maxTextureSize));
        const A = new Float32Array(F * M * 4 * v),
          N = new Go(A, F, M, v);
        (N.format = Nt), (N.type = tn), (N.needsUpdate = !0);
        const O = V * 4;
        for (let G = 0; G < v; G++) {
          const W = E[G],
            k = L[G],
            Q = D[G],
            ie = F * M * 4 * G;
          for (let re = 0; re < W.count; re++) {
            const ee = re * O;
            w === !0 &&
              (o.fromBufferAttribute(W, re),
              W.normalized === !0 && Pa(o, W),
              (A[ie + ee + 0] = o.x),
              (A[ie + ee + 1] = o.y),
              (A[ie + ee + 2] = o.z),
              (A[ie + ee + 3] = 0)),
              b === !0 &&
                (o.fromBufferAttribute(k, re),
                k.normalized === !0 && Pa(o, k),
                (A[ie + ee + 4] = o.x),
                (A[ie + ee + 5] = o.y),
                (A[ie + ee + 6] = o.z),
                (A[ie + ee + 7] = 0)),
              _ === !0 &&
                (o.fromBufferAttribute(Q, re),
                Q.normalized === !0 && Pa(o, k),
                (A[ie + ee + 8] = o.x),
                (A[ie + ee + 9] = o.y),
                (A[ie + ee + 10] = o.z),
                (A[ie + ee + 11] = Q.itemSize === 4 ? o.w : 1));
          }
        }
        (y = { count: v, texture: N, size: new ae(F, M) }),
          r.set(h, y),
          h.addEventListener("dispose", H);
      }
      let p = 0;
      for (let w = 0; w < f.length; w++) p += f[w];
      const g = h.morphTargetsRelative ? 1 : 1 - p;
      d.getUniforms().setValue(s, "morphTargetBaseInfluence", g),
        d.getUniforms().setValue(s, "morphTargetInfluences", f),
        d.getUniforms().setValue(s, "morphTargetsTexture", y.texture, t),
        d.getUniforms().setValue(s, "morphTargetsTextureSize", y.size);
    } else {
      const m = f === void 0 ? 0 : f.length;
      let v = n[h.id];
      if (v === void 0 || v.length !== m) {
        v = [];
        for (let b = 0; b < m; b++) v[b] = [b, 0];
        n[h.id] = v;
      }
      for (let b = 0; b < m; b++) {
        const _ = v[b];
        (_[0] = b), (_[1] = f[b]);
      }
      v.sort(L0);
      for (let b = 0; b < 8; b++)
        b < m && v[b][1]
          ? ((a[b][0] = v[b][0]), (a[b][1] = v[b][1]))
          : ((a[b][0] = Number.MAX_SAFE_INTEGER), (a[b][1] = 0));
      a.sort(R0);
      const y = h.morphAttributes.position,
        p = h.morphAttributes.normal;
      let g = 0;
      for (let b = 0; b < 8; b++) {
        const _ = a[b],
          E = _[0],
          L = _[1];
        E !== Number.MAX_SAFE_INTEGER && L
          ? (y &&
              h.getAttribute("morphTarget" + b) !== y[E] &&
              h.setAttribute("morphTarget" + b, y[E]),
            p &&
              h.getAttribute("morphNormal" + b) !== p[E] &&
              h.setAttribute("morphNormal" + b, p[E]),
            (i[b] = L),
            (g += L))
          : (y &&
              h.hasAttribute("morphTarget" + b) === !0 &&
              h.deleteAttribute("morphTarget" + b),
            p &&
              h.hasAttribute("morphNormal" + b) === !0 &&
              h.deleteAttribute("morphNormal" + b),
            (i[b] = 0));
      }
      const w = h.morphTargetsRelative ? 1 : 1 - g;
      d.getUniforms().setValue(s, "morphTargetBaseInfluence", w),
        d.getUniforms().setValue(s, "morphTargetInfluences", i);
    }
  }
  return { update: l };
}
function I0(s, e, t, n) {
  let i = new WeakMap();
  function r(l) {
    const c = n.render.frame,
      h = l.geometry,
      u = e.get(l, h);
    return (
      i.get(u) !== c && (e.update(u), i.set(u, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
      u
    );
  }
  function o() {
    i = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: r, dispose: o };
}
const Du = new At(),
  Fu = new Go(),
  Nu = new Dl(),
  Bu = new Wo(),
  nh = [],
  ih = [],
  rh = new Float32Array(16),
  sh = new Float32Array(9),
  oh = new Float32Array(4);
function Lr(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0) return s;
  const i = e * t;
  let r = nh[i];
  if ((r === void 0 && ((r = new Float32Array(i)), (nh[i] = r)), e !== 0)) {
    n.toArray(r, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), s[o].toArray(r, a);
  }
  return r;
}
function Qt(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
  return !0;
}
function $t(s, e) {
  for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
}
function jo(s, e) {
  let t = ih[e];
  t === void 0 && ((t = new Int32Array(e)), (ih[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
  return t;
}
function D0(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
}
function F0(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Qt(t, e)) return;
    s.uniform2fv(this.addr, e), $t(t, e);
  }
}
function N0(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (s.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Qt(t, e)) return;
    s.uniform3fv(this.addr, e), $t(t, e);
  }
}
function B0(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Qt(t, e)) return;
    s.uniform4fv(this.addr, e), $t(t, e);
  }
}
function O0(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Qt(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), $t(t, e);
  } else {
    if (Qt(t, n)) return;
    oh.set(n), s.uniformMatrix2fv(this.addr, !1, oh), $t(t, n);
  }
}
function U0(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Qt(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), $t(t, e);
  } else {
    if (Qt(t, n)) return;
    sh.set(n), s.uniformMatrix3fv(this.addr, !1, sh), $t(t, n);
  }
}
function z0(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Qt(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), $t(t, e);
  } else {
    if (Qt(t, n)) return;
    rh.set(n), s.uniformMatrix4fv(this.addr, !1, rh), $t(t, n);
  }
}
function k0(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
}
function H0(s, e) {
  const t = this.cache;
  Qt(t, e) || (s.uniform2iv(this.addr, e), $t(t, e));
}
function G0(s, e) {
  const t = this.cache;
  Qt(t, e) || (s.uniform3iv(this.addr, e), $t(t, e));
}
function V0(s, e) {
  const t = this.cache;
  Qt(t, e) || (s.uniform4iv(this.addr, e), $t(t, e));
}
function W0(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
}
function X0(s, e) {
  const t = this.cache;
  Qt(t, e) || (s.uniform2uiv(this.addr, e), $t(t, e));
}
function j0(s, e) {
  const t = this.cache;
  Qt(t, e) || (s.uniform3uiv(this.addr, e), $t(t, e));
}
function q0(s, e) {
  const t = this.cache;
  Qt(t, e) || (s.uniform4uiv(this.addr, e), $t(t, e));
}
function Y0(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2D(e || Du, i);
}
function Z0(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || Nu, i);
}
function $0(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || Bu, i);
}
function K0(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || Fu, i);
}
function J0(s) {
  switch (s) {
    case 5126:
      return D0;
    case 35664:
      return F0;
    case 35665:
      return N0;
    case 35666:
      return B0;
    case 35674:
      return O0;
    case 35675:
      return U0;
    case 35676:
      return z0;
    case 5124:
    case 35670:
      return k0;
    case 35667:
    case 35671:
      return H0;
    case 35668:
    case 35672:
      return G0;
    case 35669:
    case 35673:
      return V0;
    case 5125:
      return W0;
    case 36294:
      return X0;
    case 36295:
      return j0;
    case 36296:
      return q0;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Y0;
    case 35679:
    case 36299:
    case 36307:
      return Z0;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return $0;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return K0;
  }
}
function Q0(s, e) {
  s.uniform1fv(this.addr, e);
}
function ev(s, e) {
  const t = Lr(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function tv(s, e) {
  const t = Lr(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function nv(s, e) {
  const t = Lr(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function iv(s, e) {
  const t = Lr(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function rv(s, e) {
  const t = Lr(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function sv(s, e) {
  const t = Lr(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function ov(s, e) {
  s.uniform1iv(this.addr, e);
}
function av(s, e) {
  s.uniform2iv(this.addr, e);
}
function lv(s, e) {
  s.uniform3iv(this.addr, e);
}
function cv(s, e) {
  s.uniform4iv(this.addr, e);
}
function hv(s, e) {
  s.uniform1uiv(this.addr, e);
}
function uv(s, e) {
  s.uniform2uiv(this.addr, e);
}
function dv(s, e) {
  s.uniform3uiv(this.addr, e);
}
function fv(s, e) {
  s.uniform4uiv(this.addr, e);
}
function pv(s, e, t) {
  const n = e.length,
    i = jo(t, n);
  s.uniform1iv(this.addr, i);
  for (let r = 0; r !== n; ++r) t.setTexture2D(e[r] || Du, i[r]);
}
function mv(s, e, t) {
  const n = e.length,
    i = jo(t, n);
  s.uniform1iv(this.addr, i);
  for (let r = 0; r !== n; ++r) t.setTexture3D(e[r] || Nu, i[r]);
}
function gv(s, e, t) {
  const n = e.length,
    i = jo(t, n);
  s.uniform1iv(this.addr, i);
  for (let r = 0; r !== n; ++r) t.setTextureCube(e[r] || Bu, i[r]);
}
function vv(s, e, t) {
  const n = e.length,
    i = jo(t, n);
  s.uniform1iv(this.addr, i);
  for (let r = 0; r !== n; ++r) t.setTexture2DArray(e[r] || Fu, i[r]);
}
function xv(s) {
  switch (s) {
    case 5126:
      return Q0;
    case 35664:
      return ev;
    case 35665:
      return tv;
    case 35666:
      return nv;
    case 35674:
      return iv;
    case 35675:
      return rv;
    case 35676:
      return sv;
    case 5124:
    case 35670:
      return ov;
    case 35667:
    case 35671:
      return av;
    case 35668:
    case 35672:
      return lv;
    case 35669:
    case 35673:
      return cv;
    case 5125:
      return hv;
    case 36294:
      return uv;
    case 36295:
      return dv;
    case 36296:
      return fv;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return pv;
    case 35679:
    case 36299:
    case 36307:
      return mv;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return gv;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return vv;
  }
}
function yv(s, e, t) {
  (this.id = s),
    (this.addr = t),
    (this.cache = []),
    (this.setValue = J0(e.type));
}
function Ou(s, e, t) {
  (this.id = s),
    (this.addr = t),
    (this.cache = []),
    (this.size = e.size),
    (this.setValue = xv(e.type));
}
Ou.prototype.updateCache = function (s) {
  const e = this.cache;
  s instanceof Float32Array &&
    e.length !== s.length &&
    (this.cache = new Float32Array(s.length)),
    $t(e, s);
};
function Uu(s) {
  (this.id = s), (this.seq = []), (this.map = {});
}
Uu.prototype.setValue = function (s, e, t) {
  const n = this.seq;
  for (let i = 0, r = n.length; i !== r; ++i) {
    const o = n[i];
    o.setValue(s, e[o.id], t);
  }
};
const Ia = /(\w+)(\])?(\[|\.)?/g;
function ah(s, e) {
  s.seq.push(e), (s.map[e.id] = e);
}
function _v(s, e, t) {
  const n = s.name,
    i = n.length;
  for (Ia.lastIndex = 0; ; ) {
    const r = Ia.exec(n),
      o = Ia.lastIndex;
    let a = r[1];
    const l = r[2] === "]",
      c = r[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
      ah(t, c === void 0 ? new yv(a, s, e) : new Ou(a, s, e));
      break;
    } else {
      let u = t.map[a];
      u === void 0 && ((u = new Uu(a)), ah(t, u)), (t = u);
    }
  }
}
function ui(s, e) {
  (this.seq = []), (this.map = {});
  const t = s.getProgramParameter(e, 35718);
  for (let n = 0; n < t; ++n) {
    const i = s.getActiveUniform(e, n),
      r = s.getUniformLocation(e, i.name);
    _v(i, r, this);
  }
}
ui.prototype.setValue = function (s, e, t, n) {
  const i = this.map[e];
  i !== void 0 && i.setValue(s, t, n);
};
ui.prototype.setOptional = function (s, e, t) {
  const n = e[t];
  n !== void 0 && this.setValue(s, t, n);
};
ui.upload = function (s, e, t, n) {
  for (let i = 0, r = e.length; i !== r; ++i) {
    const o = e[i],
      a = t[o.id];
    a.needsUpdate !== !1 && o.setValue(s, a.value, n);
  }
};
ui.seqWithValue = function (s, e) {
  const t = [];
  for (let n = 0, i = s.length; n !== i; ++n) {
    const r = s[n];
    r.id in e && t.push(r);
  }
  return t;
};
function lh(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
let wv = 0;
function bv(s) {
  const e = s.split(`
`);
  for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
  return e.join(`
`);
}
function Mv(s) {
  switch (s) {
    case an:
      return ["Linear", "( value )"];
    case it:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", s),
        ["Linear", "( value )"]
      );
  }
}
function ch(s, e, t) {
  const n = s.getShaderParameter(e, 35713),
    i = s.getShaderInfoLog(e).trim();
  return n && i === ""
    ? ""
    : t.toUpperCase() +
        `

` +
        i +
        `

` +
        bv(s.getShaderSource(e));
}
function Sv(s, e) {
  const t = Mv(e);
  return "vec4 " + s + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function Tv(s, e) {
  let t;
  switch (e) {
    case Of:
      t = "Linear";
      break;
    case Uf:
      t = "Reinhard";
      break;
    case zf:
      t = "OptimizedCineon";
      break;
    case kf:
      t = "ACESFilmic";
      break;
    case Hf:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function Ev(s) {
  return [
    s.extensionDerivatives ||
    !!s.envMapCubeUVHeight ||
    s.bumpMap ||
    s.tangentSpaceNormalMap ||
    s.clearcoatNormalMap ||
    s.flatShading ||
    s.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (s.extensionFragDepth || s.logarithmicDepthBuffer) &&
    s.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    s.extensionDrawBuffers && s.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (s.extensionShaderTextureLOD || s.envMap || s.transmission) &&
    s.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(ss).join(`
`);
}
function Av(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function Cv(s, e) {
  const t = {},
    n = s.getProgramParameter(e, 35721);
  for (let i = 0; i < n; i++) {
    const r = s.getActiveAttrib(e, i),
      o = r.name;
    let a = 1;
    r.type === 35674 && (a = 2),
      r.type === 35675 && (a = 3),
      r.type === 35676 && (a = 4),
      (t[o] = {
        type: r.type,
        location: s.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function ss(s) {
  return s !== "";
}
function hh(s, e) {
  return s
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function uh(s, e) {
  return s
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const Rv = /^[ \t]*#include +<([\w\d./]+)>/gm;
function hl(s) {
  return s.replace(Rv, Lv);
}
function Lv(s, e) {
  const t = Qe[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return hl(t);
}
const Pv =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  Iv =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function dh(s) {
  return s.replace(Iv, zu).replace(Pv, Dv);
}
function Dv(s, e, t, n) {
  return (
    console.warn(
      "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
    ),
    zu(s, e, t, n)
  );
}
function zu(s, e, t, n) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function fh(s) {
  let e =
    "precision " +
    s.precision +
    ` float;
precision ` +
    s.precision +
    " int;";
  return (
    s.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : s.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : s.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function Fv(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    s.shadowMapType === mu
      ? (e = "SHADOWMAP_TYPE_PCF")
      : s.shadowMapType === mf
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : s.shadowMapType === rs && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function Nv(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case vr:
      case xr:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Ho:
      case Ll:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Bv(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case xr:
      case Ll:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Ov(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case ko:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Nf:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Bf:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Uv(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e / 32 + 1) + 3,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t,
  };
}
function zv(s, e, t, n) {
  const i = s.getContext(),
    r = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = Fv(t),
    c = Nv(t),
    h = Bv(t),
    u = Ov(t),
    d = Uv(t),
    f = t.isWebGL2 ? "" : Ev(t),
    m = Av(r),
    v = i.createProgram();
  let y,
    p,
    g = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((y = [m].filter(ss).join(`
`)),
      y.length > 0 &&
        (y += `
`),
      (p = [f, m].filter(ss).join(`
`)),
      p.length > 0 &&
        (p += `
`))
    : ((y = [
        fh(t),
        "#define SHADER_NAME " + t.shaderName,
        m,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define MAX_BONES " + t.maxBones,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.displacementMap && t.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.useVertexTexture ? "#define BONE_TEXTURE" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(ss).join(`
`)),
      (p = [
        f,
        fh(t),
        "#define SHADER_NAME " + t.shaderName,
        m,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + u : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== hi ? "#define TONE_MAPPING" : "",
        t.toneMapping !== hi ? Qe.tonemapping_pars_fragment : "",
        t.toneMapping !== hi ? Tv("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Qe.encodings_pars_fragment,
        Sv("linearToOutputTexel", t.outputEncoding),
        t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(ss).join(`
`))),
    (o = hl(o)),
    (o = hh(o, t)),
    (o = uh(o, t)),
    (a = hl(a)),
    (a = hh(a, t)),
    (a = uh(a, t)),
    (o = dh(o)),
    (a = dh(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((g = `#version 300 es
`),
      (y =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        y),
      (p =
        [
          "#define varying in",
          t.glslVersion === Oc
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === Oc ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        p));
  const w = g + y + o,
    b = g + p + a,
    _ = lh(i, 35633, w),
    E = lh(i, 35632, b);
  if (
    (i.attachShader(v, _),
    i.attachShader(v, E),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(v, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(v, 0, "position"),
    i.linkProgram(v),
    s.debug.checkShaderErrors)
  ) {
    const V = i.getProgramInfoLog(v).trim(),
      F = i.getShaderInfoLog(_).trim(),
      M = i.getShaderInfoLog(E).trim();
    let A = !0,
      N = !0;
    if (i.getProgramParameter(v, 35714) === !1) {
      A = !1;
      const O = ch(i, _, "vertex"),
        H = ch(i, E, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " +
          i.getError() +
          " - VALIDATE_STATUS " +
          i.getProgramParameter(v, 35715) +
          `

Program Info Log: ` +
          V +
          `
` +
          O +
          `
` +
          H
      );
    } else
      V !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", V)
        : (F === "" || M === "") && (N = !1);
    N &&
      (this.diagnostics = {
        runnable: A,
        programLog: V,
        vertexShader: { log: F, prefix: y },
        fragmentShader: { log: M, prefix: p },
      });
  }
  i.deleteShader(_), i.deleteShader(E);
  let L;
  this.getUniforms = function () {
    return L === void 0 && (L = new ui(i, v)), L;
  };
  let D;
  return (
    (this.getAttributes = function () {
      return D === void 0 && (D = Cv(i, v)), D;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(v),
        (this.program = void 0);
    }),
    (this.name = t.shaderName),
    (this.id = wv++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = v),
    (this.vertexShader = _),
    (this.fragmentShader = E),
    this
  );
}
let kv = 0;
class Hv {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      r = this._getShaderStage(n),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    return t.has(e) === !1 && t.set(e, new Set()), t.get(e);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    if (t.has(e) === !1) {
      const n = new Gv();
      t.set(e, n);
    }
    return t.get(e);
  }
}
class Gv {
  constructor() {
    (this.id = kv++), (this.usedTimes = 0);
  }
}
function Vv(s, e, t, n, i, r, o) {
  const a = new Ru(),
    l = new Hv(),
    c = [],
    h = i.isWebGL2,
    u = i.logarithmicDepthBuffer,
    d = i.floatVertexTextures,
    f = i.maxVertexUniforms,
    m = i.vertexTextures;
  let v = i.precision;
  const y = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function p(M) {
    const N = M.skeleton.bones;
    if (d) return 1024;
    {
      const H = Math.floor((f - 20) / 4),
        G = Math.min(H, N.length);
      return G < N.length
        ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " +
              N.length +
              " bones. This GPU supports " +
              G +
              "."
          ),
          0)
        : G;
    }
  }
  function g(M, A, N, O, H) {
    const G = O.fog,
      W = H.geometry,
      k = M.isMeshStandardMaterial ? O.environment : null,
      Q = (M.isMeshStandardMaterial ? t : e).get(M.envMap || k),
      ie =
        !!Q && (Q.mapping === Ho || Q.mapping === Ll) ? Q.image.height : null,
      re = y[M.type],
      ee = H.isSkinnedMesh ? p(H) : 0;
    M.precision !== null &&
      ((v = i.getMaxPrecision(M.precision)),
      v !== M.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          M.precision,
          "not supported, using",
          v,
          "instead."
        ));
    const Me =
        W.morphAttributes.position ||
        W.morphAttributes.normal ||
        W.morphAttributes.color,
      Be = Me !== void 0 ? Me.length : 0;
    let Re = 0;
    W.morphAttributes.position !== void 0 && (Re = 1),
      W.morphAttributes.normal !== void 0 && (Re = 2),
      W.morphAttributes.color !== void 0 && (Re = 3);
    let Z, qe, ke, Fe;
    if (re) {
      const pe = Cn[re];
      (Z = pe.vertexShader), (qe = pe.fragmentShader);
    } else
      (Z = M.vertexShader),
        (qe = M.fragmentShader),
        l.update(M),
        (ke = l.getVertexShaderID(M)),
        (Fe = l.getFragmentShaderID(M));
    const Ie = s.getRenderTarget(),
      Ze = M.alphaTest > 0,
      K = M.clearcoat > 0;
    return {
      isWebGL2: h,
      shaderID: re,
      shaderName: M.type,
      vertexShader: Z,
      fragmentShader: qe,
      defines: M.defines,
      customVertexShaderID: ke,
      customFragmentShaderID: Fe,
      isRawShaderMaterial: M.isRawShaderMaterial === !0,
      glslVersion: M.glslVersion,
      precision: v,
      instancing: H.isInstancedMesh === !0,
      instancingColor: H.isInstancedMesh === !0 && H.instanceColor !== null,
      supportsVertexTextures: m,
      outputEncoding:
        Ie === null
          ? s.outputEncoding
          : Ie.isXRRenderTarget === !0
          ? Ie.texture.encoding
          : an,
      map: !!M.map,
      matcap: !!M.matcap,
      envMap: !!Q,
      envMapMode: Q && Q.mapping,
      envMapCubeUVHeight: ie,
      lightMap: !!M.lightMap,
      aoMap: !!M.aoMap,
      emissiveMap: !!M.emissiveMap,
      bumpMap: !!M.bumpMap,
      normalMap: !!M.normalMap,
      objectSpaceNormalMap: M.normalMapType === lp,
      tangentSpaceNormalMap: M.normalMapType === Ii,
      decodeVideoTexture:
        !!M.map && M.map.isVideoTexture === !0 && M.map.encoding === it,
      clearcoat: K,
      clearcoatMap: K && !!M.clearcoatMap,
      clearcoatRoughnessMap: K && !!M.clearcoatRoughnessMap,
      clearcoatNormalMap: K && !!M.clearcoatNormalMap,
      displacementMap: !!M.displacementMap,
      roughnessMap: !!M.roughnessMap,
      metalnessMap: !!M.metalnessMap,
      specularMap: !!M.specularMap,
      specularIntensityMap: !!M.specularIntensityMap,
      specularColorMap: !!M.specularColorMap,
      opaque: M.transparent === !1 && M.blending === fr,
      alphaMap: !!M.alphaMap,
      alphaTest: Ze,
      gradientMap: !!M.gradientMap,
      sheen: M.sheen > 0,
      sheenColorMap: !!M.sheenColorMap,
      sheenRoughnessMap: !!M.sheenRoughnessMap,
      transmission: M.transmission > 0,
      transmissionMap: !!M.transmissionMap,
      thicknessMap: !!M.thicknessMap,
      combine: M.combine,
      vertexTangents: !!M.normalMap && !!W.attributes.tangent,
      vertexColors: M.vertexColors,
      vertexAlphas:
        M.vertexColors === !0 &&
        !!W.attributes.color &&
        W.attributes.color.itemSize === 4,
      vertexUvs:
        !!M.map ||
        !!M.bumpMap ||
        !!M.normalMap ||
        !!M.specularMap ||
        !!M.alphaMap ||
        !!M.emissiveMap ||
        !!M.roughnessMap ||
        !!M.metalnessMap ||
        !!M.clearcoatMap ||
        !!M.clearcoatRoughnessMap ||
        !!M.clearcoatNormalMap ||
        !!M.displacementMap ||
        !!M.transmissionMap ||
        !!M.thicknessMap ||
        !!M.specularIntensityMap ||
        !!M.specularColorMap ||
        !!M.sheenColorMap ||
        !!M.sheenRoughnessMap,
      uvsVertexOnly:
        !(
          !!M.map ||
          !!M.bumpMap ||
          !!M.normalMap ||
          !!M.specularMap ||
          !!M.alphaMap ||
          !!M.emissiveMap ||
          !!M.roughnessMap ||
          !!M.metalnessMap ||
          !!M.clearcoatNormalMap ||
          M.transmission > 0 ||
          !!M.transmissionMap ||
          !!M.thicknessMap ||
          !!M.specularIntensityMap ||
          !!M.specularColorMap ||
          M.sheen > 0 ||
          !!M.sheenColorMap ||
          !!M.sheenRoughnessMap
        ) && !!M.displacementMap,
      fog: !!G,
      useFog: M.fog,
      fogExp2: G && G.isFogExp2,
      flatShading: !!M.flatShading,
      sizeAttenuation: M.sizeAttenuation,
      logarithmicDepthBuffer: u,
      skinning: H.isSkinnedMesh === !0 && ee > 0,
      maxBones: ee,
      useVertexTexture: d,
      morphTargets: W.morphAttributes.position !== void 0,
      morphNormals: W.morphAttributes.normal !== void 0,
      morphColors: W.morphAttributes.color !== void 0,
      morphTargetsCount: Be,
      morphTextureStride: Re,
      numDirLights: A.directional.length,
      numPointLights: A.point.length,
      numSpotLights: A.spot.length,
      numRectAreaLights: A.rectArea.length,
      numHemiLights: A.hemi.length,
      numDirLightShadows: A.directionalShadowMap.length,
      numPointLightShadows: A.pointShadowMap.length,
      numSpotLightShadows: A.spotShadowMap.length,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: M.dithering,
      shadowMapEnabled: s.shadowMap.enabled && N.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: M.toneMapped ? s.toneMapping : hi,
      physicallyCorrectLights: s.physicallyCorrectLights,
      premultipliedAlpha: M.premultipliedAlpha,
      doubleSided: M.side === Li,
      flipSided: M.side === Ut,
      depthPacking: M.depthPacking !== void 0 ? M.depthPacking : !1,
      index0AttributeName: M.index0AttributeName,
      extensionDerivatives: M.extensions && M.extensions.derivatives,
      extensionFragDepth: M.extensions && M.extensions.fragDepth,
      extensionDrawBuffers: M.extensions && M.extensions.drawBuffers,
      extensionShaderTextureLOD: M.extensions && M.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: h || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: M.customProgramCacheKey(),
    };
  }
  function w(M) {
    const A = [];
    if (
      (M.shaderID
        ? A.push(M.shaderID)
        : (A.push(M.customVertexShaderID), A.push(M.customFragmentShaderID)),
      M.defines !== void 0)
    )
      for (const N in M.defines) A.push(N), A.push(M.defines[N]);
    return (
      M.isRawShaderMaterial === !1 &&
        (b(A, M), _(A, M), A.push(s.outputEncoding)),
      A.push(M.customProgramCacheKey),
      A.join()
    );
  }
  function b(M, A) {
    M.push(A.precision),
      M.push(A.outputEncoding),
      M.push(A.envMapMode),
      M.push(A.envMapCubeUVHeight),
      M.push(A.combine),
      M.push(A.vertexUvs),
      M.push(A.fogExp2),
      M.push(A.sizeAttenuation),
      M.push(A.maxBones),
      M.push(A.morphTargetsCount),
      M.push(A.morphAttributeCount),
      M.push(A.numDirLights),
      M.push(A.numPointLights),
      M.push(A.numSpotLights),
      M.push(A.numHemiLights),
      M.push(A.numRectAreaLights),
      M.push(A.numDirLightShadows),
      M.push(A.numPointLightShadows),
      M.push(A.numSpotLightShadows),
      M.push(A.shadowMapType),
      M.push(A.toneMapping),
      M.push(A.numClippingPlanes),
      M.push(A.numClipIntersection);
  }
  function _(M, A) {
    a.disableAll(),
      A.isWebGL2 && a.enable(0),
      A.supportsVertexTextures && a.enable(1),
      A.instancing && a.enable(2),
      A.instancingColor && a.enable(3),
      A.map && a.enable(4),
      A.matcap && a.enable(5),
      A.envMap && a.enable(6),
      A.lightMap && a.enable(7),
      A.aoMap && a.enable(8),
      A.emissiveMap && a.enable(9),
      A.bumpMap && a.enable(10),
      A.normalMap && a.enable(11),
      A.objectSpaceNormalMap && a.enable(12),
      A.tangentSpaceNormalMap && a.enable(13),
      A.clearcoat && a.enable(14),
      A.clearcoatMap && a.enable(15),
      A.clearcoatRoughnessMap && a.enable(16),
      A.clearcoatNormalMap && a.enable(17),
      A.displacementMap && a.enable(18),
      A.specularMap && a.enable(19),
      A.roughnessMap && a.enable(20),
      A.metalnessMap && a.enable(21),
      A.gradientMap && a.enable(22),
      A.alphaMap && a.enable(23),
      A.alphaTest && a.enable(24),
      A.vertexColors && a.enable(25),
      A.vertexAlphas && a.enable(26),
      A.vertexUvs && a.enable(27),
      A.vertexTangents && a.enable(28),
      A.uvsVertexOnly && a.enable(29),
      A.fog && a.enable(30),
      M.push(a.mask),
      a.disableAll(),
      A.useFog && a.enable(0),
      A.flatShading && a.enable(1),
      A.logarithmicDepthBuffer && a.enable(2),
      A.skinning && a.enable(3),
      A.useVertexTexture && a.enable(4),
      A.morphTargets && a.enable(5),
      A.morphNormals && a.enable(6),
      A.morphColors && a.enable(7),
      A.premultipliedAlpha && a.enable(8),
      A.shadowMapEnabled && a.enable(9),
      A.physicallyCorrectLights && a.enable(10),
      A.doubleSided && a.enable(11),
      A.flipSided && a.enable(12),
      A.depthPacking && a.enable(13),
      A.dithering && a.enable(14),
      A.specularIntensityMap && a.enable(15),
      A.specularColorMap && a.enable(16),
      A.transmission && a.enable(17),
      A.transmissionMap && a.enable(18),
      A.thicknessMap && a.enable(19),
      A.sheen && a.enable(20),
      A.sheenColorMap && a.enable(21),
      A.sheenRoughnessMap && a.enable(22),
      A.decodeVideoTexture && a.enable(23),
      A.opaque && a.enable(24),
      M.push(a.mask);
  }
  function E(M) {
    const A = y[M.type];
    let N;
    if (A) {
      const O = Cn[A];
      N = vs.clone(O.uniforms);
    } else N = M.uniforms;
    return N;
  }
  function L(M, A) {
    let N;
    for (let O = 0, H = c.length; O < H; O++) {
      const G = c[O];
      if (G.cacheKey === A) {
        (N = G), ++N.usedTimes;
        break;
      }
    }
    return N === void 0 && ((N = new zv(s, A, M, r)), c.push(N)), N;
  }
  function D(M) {
    if (--M.usedTimes === 0) {
      const A = c.indexOf(M);
      (c[A] = c[c.length - 1]), c.pop(), M.destroy();
    }
  }
  function V(M) {
    l.remove(M);
  }
  function F() {
    l.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: w,
    getUniforms: E,
    acquireProgram: L,
    releaseProgram: D,
    releaseShaderCache: V,
    programs: c,
    dispose: F,
  };
}
function Wv() {
  let s = new WeakMap();
  function e(r) {
    let o = s.get(r);
    return o === void 0 && ((o = {}), s.set(r, o)), o;
  }
  function t(r) {
    s.delete(r);
  }
  function n(r, o, a) {
    s.get(r)[o] = a;
  }
  function i() {
    s = new WeakMap();
  }
  return { get: e, remove: t, update: n, dispose: i };
}
function Xv(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.material.id !== e.material.id
    ? s.material.id - e.material.id
    : s.z !== e.z
    ? s.z - e.z
    : s.id - e.id;
}
function ph(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.z !== e.z
    ? e.z - s.z
    : s.id - e.id;
}
function mh() {
  const s = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function r() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function o(u, d, f, m, v, y) {
    let p = s[e];
    return (
      p === void 0
        ? ((p = {
            id: u.id,
            object: u,
            geometry: d,
            material: f,
            groupOrder: m,
            renderOrder: u.renderOrder,
            z: v,
            group: y,
          }),
          (s[e] = p))
        : ((p.id = u.id),
          (p.object = u),
          (p.geometry = d),
          (p.material = f),
          (p.groupOrder = m),
          (p.renderOrder = u.renderOrder),
          (p.z = v),
          (p.group = y)),
      e++,
      p
    );
  }
  function a(u, d, f, m, v, y) {
    const p = o(u, d, f, m, v, y);
    f.transmission > 0
      ? n.push(p)
      : f.transparent === !0
      ? i.push(p)
      : t.push(p);
  }
  function l(u, d, f, m, v, y) {
    const p = o(u, d, f, m, v, y);
    f.transmission > 0
      ? n.unshift(p)
      : f.transparent === !0
      ? i.unshift(p)
      : t.unshift(p);
  }
  function c(u, d) {
    t.length > 1 && t.sort(u || Xv),
      n.length > 1 && n.sort(d || ph),
      i.length > 1 && i.sort(d || ph);
  }
  function h() {
    for (let u = e, d = s.length; u < d; u++) {
      const f = s[u];
      if (f.id === null) break;
      (f.id = null),
        (f.object = null),
        (f.geometry = null),
        (f.material = null),
        (f.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: r,
    push: a,
    unshift: l,
    finish: h,
    sort: c,
  };
}
function jv() {
  let s = new WeakMap();
  function e(n, i) {
    let r;
    return (
      s.has(n) === !1
        ? ((r = new mh()), s.set(n, [r]))
        : i >= s.get(n).length
        ? ((r = new mh()), s.get(n).push(r))
        : (r = s.get(n)[i]),
      r
    );
  }
  function t() {
    s = new WeakMap();
  }
  return { get: e, dispose: t };
}
function qv() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new P(), color: new ye() };
          break;
        case "SpotLight":
          t = {
            position: new P(),
            direction: new P(),
            color: new ye(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new P(), color: new ye(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new P(), skyColor: new ye(), groundColor: new ye() };
          break;
        case "RectAreaLight":
          t = {
            color: new ye(),
            position: new P(),
            halfWidth: new P(),
            halfHeight: new P(),
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
function Yv() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ae(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ae(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ae(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
let Zv = 0;
function $v(s, e) {
  return (e.castShadow ? 1 : 0) - (s.castShadow ? 1 : 0);
}
function Kv(s, e) {
  const t = new qv(),
    n = Yv(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
    };
  for (let h = 0; h < 9; h++) i.probe.push(new P());
  const r = new P(),
    o = new be(),
    a = new be();
  function l(h, u) {
    let d = 0,
      f = 0,
      m = 0;
    for (let V = 0; V < 9; V++) i.probe[V].set(0, 0, 0);
    let v = 0,
      y = 0,
      p = 0,
      g = 0,
      w = 0,
      b = 0,
      _ = 0,
      E = 0;
    h.sort($v);
    const L = u !== !0 ? Math.PI : 1;
    for (let V = 0, F = h.length; V < F; V++) {
      const M = h[V],
        A = M.color,
        N = M.intensity,
        O = M.distance,
        H = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
      if (M.isAmbientLight)
        (d += A.r * N * L), (f += A.g * N * L), (m += A.b * N * L);
      else if (M.isLightProbe)
        for (let G = 0; G < 9; G++)
          i.probe[G].addScaledVector(M.sh.coefficients[G], N);
      else if (M.isDirectionalLight) {
        const G = t.get(M);
        if (
          (G.color.copy(M.color).multiplyScalar(M.intensity * L), M.castShadow)
        ) {
          const W = M.shadow,
            k = n.get(M);
          (k.shadowBias = W.bias),
            (k.shadowNormalBias = W.normalBias),
            (k.shadowRadius = W.radius),
            (k.shadowMapSize = W.mapSize),
            (i.directionalShadow[v] = k),
            (i.directionalShadowMap[v] = H),
            (i.directionalShadowMatrix[v] = M.shadow.matrix),
            b++;
        }
        (i.directional[v] = G), v++;
      } else if (M.isSpotLight) {
        const G = t.get(M);
        if (
          (G.position.setFromMatrixPosition(M.matrixWorld),
          G.color.copy(A).multiplyScalar(N * L),
          (G.distance = O),
          (G.coneCos = Math.cos(M.angle)),
          (G.penumbraCos = Math.cos(M.angle * (1 - M.penumbra))),
          (G.decay = M.decay),
          M.castShadow)
        ) {
          const W = M.shadow,
            k = n.get(M);
          (k.shadowBias = W.bias),
            (k.shadowNormalBias = W.normalBias),
            (k.shadowRadius = W.radius),
            (k.shadowMapSize = W.mapSize),
            (i.spotShadow[p] = k),
            (i.spotShadowMap[p] = H),
            (i.spotShadowMatrix[p] = M.shadow.matrix),
            E++;
        }
        (i.spot[p] = G), p++;
      } else if (M.isRectAreaLight) {
        const G = t.get(M);
        G.color.copy(A).multiplyScalar(N),
          G.halfWidth.set(M.width * 0.5, 0, 0),
          G.halfHeight.set(0, M.height * 0.5, 0),
          (i.rectArea[g] = G),
          g++;
      } else if (M.isPointLight) {
        const G = t.get(M);
        if (
          (G.color.copy(M.color).multiplyScalar(M.intensity * L),
          (G.distance = M.distance),
          (G.decay = M.decay),
          M.castShadow)
        ) {
          const W = M.shadow,
            k = n.get(M);
          (k.shadowBias = W.bias),
            (k.shadowNormalBias = W.normalBias),
            (k.shadowRadius = W.radius),
            (k.shadowMapSize = W.mapSize),
            (k.shadowCameraNear = W.camera.near),
            (k.shadowCameraFar = W.camera.far),
            (i.pointShadow[y] = k),
            (i.pointShadowMap[y] = H),
            (i.pointShadowMatrix[y] = M.shadow.matrix),
            _++;
        }
        (i.point[y] = G), y++;
      } else if (M.isHemisphereLight) {
        const G = t.get(M);
        G.skyColor.copy(M.color).multiplyScalar(N * L),
          G.groundColor.copy(M.groundColor).multiplyScalar(N * L),
          (i.hemi[w] = G),
          w++;
      }
    }
    g > 0 &&
      (e.isWebGL2 || s.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = Ae.LTC_FLOAT_1), (i.rectAreaLTC2 = Ae.LTC_FLOAT_2))
        : s.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = Ae.LTC_HALF_1), (i.rectAreaLTC2 = Ae.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = d),
      (i.ambient[1] = f),
      (i.ambient[2] = m);
    const D = i.hash;
    (D.directionalLength !== v ||
      D.pointLength !== y ||
      D.spotLength !== p ||
      D.rectAreaLength !== g ||
      D.hemiLength !== w ||
      D.numDirectionalShadows !== b ||
      D.numPointShadows !== _ ||
      D.numSpotShadows !== E) &&
      ((i.directional.length = v),
      (i.spot.length = p),
      (i.rectArea.length = g),
      (i.point.length = y),
      (i.hemi.length = w),
      (i.directionalShadow.length = b),
      (i.directionalShadowMap.length = b),
      (i.pointShadow.length = _),
      (i.pointShadowMap.length = _),
      (i.spotShadow.length = E),
      (i.spotShadowMap.length = E),
      (i.directionalShadowMatrix.length = b),
      (i.pointShadowMatrix.length = _),
      (i.spotShadowMatrix.length = E),
      (D.directionalLength = v),
      (D.pointLength = y),
      (D.spotLength = p),
      (D.rectAreaLength = g),
      (D.hemiLength = w),
      (D.numDirectionalShadows = b),
      (D.numPointShadows = _),
      (D.numSpotShadows = E),
      (i.version = Zv++));
  }
  function c(h, u) {
    let d = 0,
      f = 0,
      m = 0,
      v = 0,
      y = 0;
    const p = u.matrixWorldInverse;
    for (let g = 0, w = h.length; g < w; g++) {
      const b = h[g];
      if (b.isDirectionalLight) {
        const _ = i.directional[d];
        _.direction.setFromMatrixPosition(b.matrixWorld),
          r.setFromMatrixPosition(b.target.matrixWorld),
          _.direction.sub(r),
          _.direction.transformDirection(p),
          d++;
      } else if (b.isSpotLight) {
        const _ = i.spot[m];
        _.position.setFromMatrixPosition(b.matrixWorld),
          _.position.applyMatrix4(p),
          _.direction.setFromMatrixPosition(b.matrixWorld),
          r.setFromMatrixPosition(b.target.matrixWorld),
          _.direction.sub(r),
          _.direction.transformDirection(p),
          m++;
      } else if (b.isRectAreaLight) {
        const _ = i.rectArea[v];
        _.position.setFromMatrixPosition(b.matrixWorld),
          _.position.applyMatrix4(p),
          a.identity(),
          o.copy(b.matrixWorld),
          o.premultiply(p),
          a.extractRotation(o),
          _.halfWidth.set(b.width * 0.5, 0, 0),
          _.halfHeight.set(0, b.height * 0.5, 0),
          _.halfWidth.applyMatrix4(a),
          _.halfHeight.applyMatrix4(a),
          v++;
      } else if (b.isPointLight) {
        const _ = i.point[f];
        _.position.setFromMatrixPosition(b.matrixWorld),
          _.position.applyMatrix4(p),
          f++;
      } else if (b.isHemisphereLight) {
        const _ = i.hemi[y];
        _.direction.setFromMatrixPosition(b.matrixWorld),
          _.direction.transformDirection(p),
          _.direction.normalize(),
          y++;
      }
    }
  }
  return { setup: l, setupView: c, state: i };
}
function gh(s, e) {
  const t = new Kv(s, e),
    n = [],
    i = [];
  function r() {
    (n.length = 0), (i.length = 0);
  }
  function o(u) {
    n.push(u);
  }
  function a(u) {
    i.push(u);
  }
  function l(u) {
    t.setup(n, u);
  }
  function c(u) {
    t.setupView(n, u);
  }
  return {
    init: r,
    state: { lightsArray: n, shadowsArray: i, lights: t },
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a,
  };
}
function Jv(s, e) {
  let t = new WeakMap();
  function n(r, o = 0) {
    let a;
    return (
      t.has(r) === !1
        ? ((a = new gh(s, e)), t.set(r, [a]))
        : o >= t.get(r).length
        ? ((a = new gh(s, e)), t.get(r).push(a))
        : (a = t.get(r)[o]),
      a
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: n, dispose: i };
}
class Ul extends Et {
  constructor(e) {
    super();
    (this.type = "MeshDepthMaterial"),
      (this.depthPacking = op),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
Ul.prototype.isMeshDepthMaterial = !0;
class zl extends Et {
  constructor(e) {
    super();
    (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new P()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.referencePosition.copy(e.referencePosition),
      (this.nearDistance = e.nearDistance),
      (this.farDistance = e.farDistance),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
zl.prototype.isMeshDistanceMaterial = !0;
const Qv = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  ex = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function ku(s, e, t) {
  let n = new Xo();
  const i = new ae(),
    r = new ae(),
    o = new ct(),
    a = new Ul({ depthPacking: ap }),
    l = new zl(),
    c = {},
    h = t.maxTextureSize,
    u = { 0: Ut, 1: gr, 2: Li },
    d = new Vt({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new ae() },
        radius: { value: 4 },
      },
      vertexShader: Qv,
      fragmentShader: ex,
    }),
    f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new tt();
  m.setAttribute(
    "position",
    new St(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const v = new jt(m, d),
    y = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = mu),
    (this.render = function (b, _, E) {
      if (
        y.enabled === !1 ||
        (y.autoUpdate === !1 && y.needsUpdate === !1) ||
        b.length === 0
      )
        return;
      const L = s.getRenderTarget(),
        D = s.getActiveCubeFace(),
        V = s.getActiveMipmapLevel(),
        F = s.state;
      F.setBlending(ci),
        F.buffers.color.setClear(1, 1, 1, 1),
        F.buffers.depth.setTest(!0),
        F.setScissorTest(!1);
      for (let M = 0, A = b.length; M < A; M++) {
        const N = b[M],
          O = N.shadow;
        if (O === void 0) {
          console.warn("THREE.WebGLShadowMap:", N, "has no shadow.");
          continue;
        }
        if (O.autoUpdate === !1 && O.needsUpdate === !1) continue;
        i.copy(O.mapSize);
        const H = O.getFrameExtents();
        if (
          (i.multiply(H),
          r.copy(O.mapSize),
          (i.x > h || i.y > h) &&
            (i.x > h &&
              ((r.x = Math.floor(h / H.x)),
              (i.x = r.x * H.x),
              (O.mapSize.x = r.x)),
            i.y > h &&
              ((r.y = Math.floor(h / H.y)),
              (i.y = r.y * H.y),
              (O.mapSize.y = r.y))),
          O.map === null && !O.isPointLightShadow && this.type === rs)
        ) {
          const W = { minFilter: st, magFilter: st, format: Nt };
          (O.map = new Bt(i.x, i.y, W)),
            (O.map.texture.name = N.name + ".shadowMap"),
            (O.mapPass = new Bt(i.x, i.y, W)),
            O.camera.updateProjectionMatrix();
        }
        if (O.map === null) {
          const W = { minFilter: zt, magFilter: zt, format: Nt };
          (O.map = new Bt(i.x, i.y, W)),
            (O.map.texture.name = N.name + ".shadowMap"),
            O.camera.updateProjectionMatrix();
        }
        s.setRenderTarget(O.map), s.clear();
        const G = O.getViewportCount();
        for (let W = 0; W < G; W++) {
          const k = O.getViewport(W);
          o.set(r.x * k.x, r.y * k.y, r.x * k.z, r.y * k.w),
            F.viewport(o),
            O.updateMatrices(N, W),
            (n = O.getFrustum()),
            w(_, E, O.camera, N, this.type);
        }
        !O.isPointLightShadow && this.type === rs && p(O, E),
          (O.needsUpdate = !1);
      }
      (y.needsUpdate = !1), s.setRenderTarget(L, D, V);
    });
  function p(b, _) {
    const E = e.update(v);
    d.defines.VSM_SAMPLES !== b.blurSamples &&
      ((d.defines.VSM_SAMPLES = b.blurSamples),
      (f.defines.VSM_SAMPLES = b.blurSamples),
      (d.needsUpdate = !0),
      (f.needsUpdate = !0)),
      (d.uniforms.shadow_pass.value = b.map.texture),
      (d.uniforms.resolution.value = b.mapSize),
      (d.uniforms.radius.value = b.radius),
      s.setRenderTarget(b.mapPass),
      s.clear(),
      s.renderBufferDirect(_, null, E, d, v, null),
      (f.uniforms.shadow_pass.value = b.mapPass.texture),
      (f.uniforms.resolution.value = b.mapSize),
      (f.uniforms.radius.value = b.radius),
      s.setRenderTarget(b.map),
      s.clear(),
      s.renderBufferDirect(_, null, E, f, v, null);
  }
  function g(b, _, E, L, D, V) {
    let F = null;
    const M =
      E.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
    if (
      (M !== void 0 ? (F = M) : (F = E.isPointLight === !0 ? l : a),
      (s.localClippingEnabled &&
        _.clipShadows === !0 &&
        _.clippingPlanes.length !== 0) ||
        (_.displacementMap && _.displacementScale !== 0) ||
        (_.alphaMap && _.alphaTest > 0))
    ) {
      const A = F.uuid,
        N = _.uuid;
      let O = c[A];
      O === void 0 && ((O = {}), (c[A] = O));
      let H = O[N];
      H === void 0 && ((H = F.clone()), (O[N] = H)), (F = H);
    }
    return (
      (F.visible = _.visible),
      (F.wireframe = _.wireframe),
      V === rs
        ? (F.side = _.shadowSide !== null ? _.shadowSide : _.side)
        : (F.side = _.shadowSide !== null ? _.shadowSide : u[_.side]),
      (F.alphaMap = _.alphaMap),
      (F.alphaTest = _.alphaTest),
      (F.clipShadows = _.clipShadows),
      (F.clippingPlanes = _.clippingPlanes),
      (F.clipIntersection = _.clipIntersection),
      (F.displacementMap = _.displacementMap),
      (F.displacementScale = _.displacementScale),
      (F.displacementBias = _.displacementBias),
      (F.wireframeLinewidth = _.wireframeLinewidth),
      (F.linewidth = _.linewidth),
      E.isPointLight === !0 &&
        F.isMeshDistanceMaterial === !0 &&
        (F.referencePosition.setFromMatrixPosition(E.matrixWorld),
        (F.nearDistance = L),
        (F.farDistance = D)),
      F
    );
  }
  function w(b, _, E, L, D) {
    if (b.visible === !1) return;
    if (
      b.layers.test(_.layers) &&
      (b.isMesh || b.isLine || b.isPoints) &&
      (b.castShadow || (b.receiveShadow && D === rs)) &&
      (!b.frustumCulled || n.intersectsObject(b))
    ) {
      b.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, b.matrixWorld);
      const M = e.update(b),
        A = b.material;
      if (Array.isArray(A)) {
        const N = M.groups;
        for (let O = 0, H = N.length; O < H; O++) {
          const G = N[O],
            W = A[G.materialIndex];
          if (W && W.visible) {
            const k = g(b, W, L, E.near, E.far, D);
            s.renderBufferDirect(E, null, M, k, b, G);
          }
        }
      } else if (A.visible) {
        const N = g(b, A, L, E.near, E.far, D);
        s.renderBufferDirect(E, null, M, N, b, null);
      }
    }
    const F = b.children;
    for (let M = 0, A = F.length; M < A; M++) w(F[M], _, E, L, D);
  }
}
function tx(s, e, t) {
  const n = t.isWebGL2;
  function i() {
    let B = !1;
    const ve = new ct();
    let Te = null;
    const Ve = new ct(0, 0, 0, 0);
    return {
      setMask: function (me) {
        Te !== me && !B && (s.colorMask(me, me, me, me), (Te = me));
      },
      setLocked: function (me) {
        B = me;
      },
      setClear: function (me, oe, Ye, ue, Ct) {
        Ct === !0 && ((me *= ue), (oe *= ue), (Ye *= ue)),
          ve.set(me, oe, Ye, ue),
          Ve.equals(ve) === !1 && (s.clearColor(me, oe, Ye, ue), Ve.copy(ve));
      },
      reset: function () {
        (B = !1), (Te = null), Ve.set(-1, 0, 0, 0);
      },
    };
  }
  function r() {
    let B = !1,
      ve = null,
      Te = null,
      Ve = null;
    return {
      setTest: function (me) {
        me ? Re(2929) : Z(2929);
      },
      setMask: function (me) {
        ve !== me && !B && (s.depthMask(me), (ve = me));
      },
      setFunc: function (me) {
        if (Te !== me) {
          if (me)
            switch (me) {
              case Cf:
                s.depthFunc(512);
                break;
              case Rf:
                s.depthFunc(519);
                break;
              case Lf:
                s.depthFunc(513);
                break;
              case Ja:
                s.depthFunc(515);
                break;
              case Pf:
                s.depthFunc(514);
                break;
              case If:
                s.depthFunc(518);
                break;
              case Df:
                s.depthFunc(516);
                break;
              case Ff:
                s.depthFunc(517);
                break;
              default:
                s.depthFunc(515);
            }
          else s.depthFunc(515);
          Te = me;
        }
      },
      setLocked: function (me) {
        B = me;
      },
      setClear: function (me) {
        Ve !== me && (s.clearDepth(me), (Ve = me));
      },
      reset: function () {
        (B = !1), (ve = null), (Te = null), (Ve = null);
      },
    };
  }
  function o() {
    let B = !1,
      ve = null,
      Te = null,
      Ve = null,
      me = null,
      oe = null,
      Ye = null,
      ue = null,
      Ct = null;
    return {
      setTest: function (dt) {
        B || (dt ? Re(2960) : Z(2960));
      },
      setMask: function (dt) {
        ve !== dt && !B && (s.stencilMask(dt), (ve = dt));
      },
      setFunc: function (dt, hn, un) {
        (Te !== dt || Ve !== hn || me !== un) &&
          (s.stencilFunc(dt, hn, un), (Te = dt), (Ve = hn), (me = un));
      },
      setOp: function (dt, hn, un) {
        (oe !== dt || Ye !== hn || ue !== un) &&
          (s.stencilOp(dt, hn, un), (oe = dt), (Ye = hn), (ue = un));
      },
      setLocked: function (dt) {
        B = dt;
      },
      setClear: function (dt) {
        Ct !== dt && (s.clearStencil(dt), (Ct = dt));
      },
      reset: function () {
        (B = !1),
          (ve = null),
          (Te = null),
          (Ve = null),
          (me = null),
          (oe = null),
          (Ye = null),
          (ue = null),
          (Ct = null);
      },
    };
  }
  const a = new i(),
    l = new r(),
    c = new o();
  let h = {},
    u = {},
    d = new WeakMap(),
    f = [],
    m = null,
    v = !1,
    y = null,
    p = null,
    g = null,
    w = null,
    b = null,
    _ = null,
    E = null,
    L = !1,
    D = null,
    V = null,
    F = null,
    M = null,
    A = null;
  const N = s.getParameter(35661);
  let O = !1,
    H = 0;
  const G = s.getParameter(7938);
  G.indexOf("WebGL") !== -1
    ? ((H = parseFloat(/^WebGL (\d)/.exec(G)[1])), (O = H >= 1))
    : G.indexOf("OpenGL ES") !== -1 &&
      ((H = parseFloat(/^OpenGL ES (\d)/.exec(G)[1])), (O = H >= 2));
  let W = null,
    k = {};
  const Q = s.getParameter(3088),
    ie = s.getParameter(2978),
    re = new ct().fromArray(Q),
    ee = new ct().fromArray(ie);
  function Me(B, ve, Te) {
    const Ve = new Uint8Array(4),
      me = s.createTexture();
    s.bindTexture(B, me),
      s.texParameteri(B, 10241, 9728),
      s.texParameteri(B, 10240, 9728);
    for (let oe = 0; oe < Te; oe++)
      s.texImage2D(ve + oe, 0, 6408, 1, 1, 0, 6408, 5121, Ve);
    return me;
  }
  const Be = {};
  (Be[3553] = Me(3553, 3553, 1)),
    (Be[34067] = Me(34067, 34069, 6)),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    Re(2929),
    l.setFunc(Ja),
    pe(!1),
    De(vc),
    Re(2884),
    K(ci);
  function Re(B) {
    h[B] !== !0 && (s.enable(B), (h[B] = !0));
  }
  function Z(B) {
    h[B] !== !1 && (s.disable(B), (h[B] = !1));
  }
  function qe(B, ve) {
    return u[B] !== ve
      ? (s.bindFramebuffer(B, ve),
        (u[B] = ve),
        n && (B === 36009 && (u[36160] = ve), B === 36160 && (u[36009] = ve)),
        !0)
      : !1;
  }
  function ke(B, ve) {
    let Te = f,
      Ve = !1;
    if (B)
      if (
        ((Te = d.get(ve)),
        Te === void 0 && ((Te = []), d.set(ve, Te)),
        B.isWebGLMultipleRenderTargets)
      ) {
        const me = B.texture;
        if (Te.length !== me.length || Te[0] !== 36064) {
          for (let oe = 0, Ye = me.length; oe < Ye; oe++) Te[oe] = 36064 + oe;
          (Te.length = me.length), (Ve = !0);
        }
      } else Te[0] !== 36064 && ((Te[0] = 36064), (Ve = !0));
    else Te[0] !== 1029 && ((Te[0] = 1029), (Ve = !0));
    Ve &&
      (t.isWebGL2
        ? s.drawBuffers(Te)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Te));
  }
  function Fe(B) {
    return m !== B ? (s.useProgram(B), (m = B), !0) : !1;
  }
  const Ie = { [sr]: 32774, [vf]: 32778, [xf]: 32779 };
  if (n) (Ie[_c] = 32775), (Ie[wc] = 32776);
  else {
    const B = e.get("EXT_blend_minmax");
    B !== null && ((Ie[_c] = B.MIN_EXT), (Ie[wc] = B.MAX_EXT));
  }
  const Ze = {
    [yf]: 0,
    [_f]: 1,
    [wf]: 768,
    [vu]: 770,
    [Af]: 776,
    [Tf]: 774,
    [Mf]: 772,
    [bf]: 769,
    [xu]: 771,
    [Ef]: 775,
    [Sf]: 773,
  };
  function K(B, ve, Te, Ve, me, oe, Ye, ue) {
    if (B === ci) {
      v === !0 && (Z(3042), (v = !1));
      return;
    }
    if ((v === !1 && (Re(3042), (v = !0)), B !== gf)) {
      if (B !== y || ue !== L) {
        if (
          ((p !== sr || b !== sr) &&
            (s.blendEquation(32774), (p = sr), (b = sr)),
          ue)
        )
          switch (B) {
            case fr:
              s.blendFuncSeparate(1, 771, 1, 771);
              break;
            case To:
              s.blendFunc(1, 1);
              break;
            case xc:
              s.blendFuncSeparate(0, 769, 0, 1);
              break;
            case yc:
              s.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }
        else
          switch (B) {
            case fr:
              s.blendFuncSeparate(770, 771, 1, 771);
              break;
            case To:
              s.blendFunc(770, 1);
              break;
            case xc:
              s.blendFuncSeparate(0, 769, 0, 1);
              break;
            case yc:
              s.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }
        (g = null), (w = null), (_ = null), (E = null), (y = B), (L = ue);
      }
      return;
    }
    (me = me || ve),
      (oe = oe || Te),
      (Ye = Ye || Ve),
      (ve !== p || me !== b) &&
        (s.blendEquationSeparate(Ie[ve], Ie[me]), (p = ve), (b = me)),
      (Te !== g || Ve !== w || oe !== _ || Ye !== E) &&
        (s.blendFuncSeparate(Ze[Te], Ze[Ve], Ze[oe], Ze[Ye]),
        (g = Te),
        (w = Ve),
        (_ = oe),
        (E = Ye)),
      (y = B),
      (L = null);
  }
  function de(B, ve) {
    B.side === Li ? Z(2884) : Re(2884);
    let Te = B.side === Ut;
    ve && (Te = !Te),
      pe(Te),
      B.blending === fr && B.transparent === !1
        ? K(ci)
        : K(
            B.blending,
            B.blendEquation,
            B.blendSrc,
            B.blendDst,
            B.blendEquationAlpha,
            B.blendSrcAlpha,
            B.blendDstAlpha,
            B.premultipliedAlpha
          ),
      l.setFunc(B.depthFunc),
      l.setTest(B.depthTest),
      l.setMask(B.depthWrite),
      a.setMask(B.colorWrite);
    const Ve = B.stencilWrite;
    c.setTest(Ve),
      Ve &&
        (c.setMask(B.stencilWriteMask),
        c.setFunc(B.stencilFunc, B.stencilRef, B.stencilFuncMask),
        c.setOp(B.stencilFail, B.stencilZFail, B.stencilZPass)),
      We(B.polygonOffset, B.polygonOffsetFactor, B.polygonOffsetUnits),
      B.alphaToCoverage === !0 ? Re(32926) : Z(32926);
  }
  function pe(B) {
    D !== B && (B ? s.frontFace(2304) : s.frontFace(2305), (D = B));
  }
  function De(B) {
    B !== ff
      ? (Re(2884),
        B !== V &&
          (B === vc
            ? s.cullFace(1029)
            : B === pf
            ? s.cullFace(1028)
            : s.cullFace(1032)))
      : Z(2884),
      (V = B);
  }
  function Ee(B) {
    B !== F && (O && s.lineWidth(B), (F = B));
  }
  function We(B, ve, Te) {
    B
      ? (Re(32823),
        (M !== ve || A !== Te) && (s.polygonOffset(ve, Te), (M = ve), (A = Te)))
      : Z(32823);
  }
  function ze(B) {
    B ? Re(3089) : Z(3089);
  }
  function $e(B) {
    B === void 0 && (B = 33984 + N - 1),
      W !== B && (s.activeTexture(B), (W = B));
  }
  function ut(B, ve) {
    W === null && $e();
    let Te = k[W];
    Te === void 0 && ((Te = { type: void 0, texture: void 0 }), (k[W] = Te)),
      (Te.type !== B || Te.texture !== ve) &&
        (s.bindTexture(B, ve || Be[B]), (Te.type = B), (Te.texture = ve));
  }
  function R() {
    const B = k[W];
    B !== void 0 &&
      B.type !== void 0 &&
      (s.bindTexture(B.type, null), (B.type = void 0), (B.texture = void 0));
  }
  function T() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function te() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ce() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function _e() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function Le() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function He() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ne() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function U() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function fe(B) {
    re.equals(B) === !1 && (s.scissor(B.x, B.y, B.z, B.w), re.copy(B));
  }
  function Ce(B) {
    ee.equals(B) === !1 && (s.viewport(B.x, B.y, B.z, B.w), ee.copy(B));
  }
  function Se() {
    s.disable(3042),
      s.disable(2884),
      s.disable(2929),
      s.disable(32823),
      s.disable(3089),
      s.disable(2960),
      s.disable(32926),
      s.blendEquation(32774),
      s.blendFunc(1, 0),
      s.blendFuncSeparate(1, 0, 1, 0),
      s.colorMask(!0, !0, !0, !0),
      s.clearColor(0, 0, 0, 0),
      s.depthMask(!0),
      s.depthFunc(513),
      s.clearDepth(1),
      s.stencilMask(4294967295),
      s.stencilFunc(519, 0, 4294967295),
      s.stencilOp(7680, 7680, 7680),
      s.clearStencil(0),
      s.cullFace(1029),
      s.frontFace(2305),
      s.polygonOffset(0, 0),
      s.activeTexture(33984),
      s.bindFramebuffer(36160, null),
      n === !0 &&
        (s.bindFramebuffer(36009, null), s.bindFramebuffer(36008, null)),
      s.useProgram(null),
      s.lineWidth(1),
      s.scissor(0, 0, s.canvas.width, s.canvas.height),
      s.viewport(0, 0, s.canvas.width, s.canvas.height),
      (h = {}),
      (W = null),
      (k = {}),
      (u = {}),
      (d = new WeakMap()),
      (f = []),
      (m = null),
      (v = !1),
      (y = null),
      (p = null),
      (g = null),
      (w = null),
      (b = null),
      (_ = null),
      (E = null),
      (L = !1),
      (D = null),
      (V = null),
      (F = null),
      (M = null),
      (A = null),
      re.set(0, 0, s.canvas.width, s.canvas.height),
      ee.set(0, 0, s.canvas.width, s.canvas.height),
      a.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: a, depth: l, stencil: c },
    enable: Re,
    disable: Z,
    bindFramebuffer: qe,
    drawBuffers: ke,
    useProgram: Fe,
    setBlending: K,
    setMaterial: de,
    setFlipSided: pe,
    setCullFace: De,
    setLineWidth: Ee,
    setPolygonOffset: We,
    setScissorTest: ze,
    activeTexture: $e,
    bindTexture: ut,
    unbindTexture: R,
    compressedTexImage2D: T,
    texImage2D: ne,
    texImage3D: U,
    texStorage2D: Le,
    texStorage3D: He,
    texSubImage2D: te,
    texSubImage3D: ce,
    compressedTexSubImage2D: _e,
    scissor: fe,
    viewport: Ce,
    reset: Se,
  };
}
function nx(s, e, t, n, i, r, o) {
  const a = i.isWebGL2,
    l = i.maxTextures,
    c = i.maxCubemapSize,
    h = i.maxTextureSize,
    u = i.maxSamples,
    d = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    f = new WeakMap();
  let m;
  const v = new WeakMap();
  let y = !1;
  try {
    y =
      typeof OffscreenCanvas != "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function p(R, T) {
    return y ? new OffscreenCanvas(R, T) : gs("canvas");
  }
  function g(R, T, te, ce) {
    let _e = 1;
    if (
      ((R.width > ce || R.height > ce) &&
        (_e = ce / Math.max(R.width, R.height)),
      _e < 1 || T === !0)
    )
      if (
        (typeof HTMLImageElement != "undefined" &&
          R instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement != "undefined" &&
          R instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap != "undefined" && R instanceof ImageBitmap)
      ) {
        const Le = T ? Lo : Math.floor,
          He = Le(_e * R.width),
          ne = Le(_e * R.height);
        m === void 0 && (m = p(He, ne));
        const U = te ? p(He, ne) : m;
        return (
          (U.width = He),
          (U.height = ne),
          U.getContext("2d").drawImage(R, 0, 0, He, ne),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              R.width +
              "x" +
              R.height +
              ") to (" +
              He +
              "x" +
              ne +
              ")."
          ),
          U
        );
      } else
        return (
          "data" in R &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                R.width +
                "x" +
                R.height +
                ")."
            ),
          R
        );
    return R;
  }
  function w(R) {
    return cl(R.width) && cl(R.height);
  }
  function b(R) {
    return a
      ? !1
      : R.wrapS !== Zt ||
          R.wrapT !== Zt ||
          (R.minFilter !== zt && R.minFilter !== st);
  }
  function _(R, T) {
    return R.generateMipmaps && T && R.minFilter !== zt && R.minFilter !== st;
  }
  function E(R) {
    s.generateMipmap(R);
  }
  function L(R, T, te, ce, _e = !1) {
    if (a === !1) return T;
    if (R !== null) {
      if (s[R] !== void 0) return s[R];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          R +
          "'"
      );
    }
    let Le = T;
    return (
      T === 6403 &&
        (te === 5126 && (Le = 33326),
        te === 5131 && (Le = 33325),
        te === 5121 && (Le = 33321)),
      T === 33319 &&
        (te === 5126 && (Le = 33328),
        te === 5131 && (Le = 33327),
        te === 5121 && (Le = 33323)),
      T === 6408 &&
        (te === 5126 && (Le = 34836),
        te === 5131 && (Le = 34842),
        te === 5121 && (Le = ce === it && _e === !1 ? 35907 : 32856),
        te === 32819 && (Le = 32854),
        te === 32820 && (Le = 32855)),
      (Le === 33325 ||
        Le === 33326 ||
        Le === 33327 ||
        Le === 33328 ||
        Le === 34842 ||
        Le === 34836) &&
        e.get("EXT_color_buffer_float"),
      Le
    );
  }
  function D(R, T, te) {
    return _(R, te) === !0 ||
      (R.isFramebufferTexture && R.minFilter !== zt && R.minFilter !== st)
      ? Math.log2(Math.max(T.width, T.height)) + 1
      : R.mipmaps !== void 0 && R.mipmaps.length > 0
      ? R.mipmaps.length
      : R.isCompressedTexture && Array.isArray(R.image)
      ? T.mipmaps.length
      : 1;
  }
  function V(R) {
    return R === zt || R === el || R === tl ? 9728 : 9729;
  }
  function F(R) {
    const T = R.target;
    T.removeEventListener("dispose", F), A(T), T.isVideoTexture && f.delete(T);
  }
  function M(R) {
    const T = R.target;
    T.removeEventListener("dispose", M), O(T);
  }
  function A(R) {
    const T = n.get(R);
    if (T.__webglInit === void 0) return;
    const te = R.source,
      ce = v.get(te);
    if (ce) {
      const _e = ce[T.__cacheKey];
      _e.usedTimes--,
        _e.usedTimes === 0 && N(R),
        Object.keys(ce).length === 0 && v.delete(te);
    }
    n.remove(R);
  }
  function N(R) {
    const T = n.get(R);
    s.deleteTexture(T.__webglTexture);
    const te = R.source,
      ce = v.get(te);
    delete ce[T.__cacheKey], o.memory.textures--;
  }
  function O(R) {
    const T = R.texture,
      te = n.get(R),
      ce = n.get(T);
    if (
      (ce.__webglTexture !== void 0 &&
        (s.deleteTexture(ce.__webglTexture), o.memory.textures--),
      R.depthTexture && R.depthTexture.dispose(),
      R.isWebGLCubeRenderTarget)
    )
      for (let _e = 0; _e < 6; _e++)
        s.deleteFramebuffer(te.__webglFramebuffer[_e]),
          te.__webglDepthbuffer &&
            s.deleteRenderbuffer(te.__webglDepthbuffer[_e]);
    else
      s.deleteFramebuffer(te.__webglFramebuffer),
        te.__webglDepthbuffer && s.deleteRenderbuffer(te.__webglDepthbuffer),
        te.__webglMultisampledFramebuffer &&
          s.deleteFramebuffer(te.__webglMultisampledFramebuffer),
        te.__webglColorRenderbuffer &&
          s.deleteRenderbuffer(te.__webglColorRenderbuffer),
        te.__webglDepthRenderbuffer &&
          s.deleteRenderbuffer(te.__webglDepthRenderbuffer);
    if (R.isWebGLMultipleRenderTargets)
      for (let _e = 0, Le = T.length; _e < Le; _e++) {
        const He = n.get(T[_e]);
        He.__webglTexture &&
          (s.deleteTexture(He.__webglTexture), o.memory.textures--),
          n.remove(T[_e]);
      }
    n.remove(T), n.remove(R);
  }
  let H = 0;
  function G() {
    H = 0;
  }
  function W() {
    const R = H;
    return (
      R >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            R +
            " texture units while this GPU supports only " +
            l
        ),
      (H += 1),
      R
    );
  }
  function k(R) {
    const T = [];
    return (
      T.push(R.wrapS),
      T.push(R.wrapT),
      T.push(R.magFilter),
      T.push(R.minFilter),
      T.push(R.anisotropy),
      T.push(R.internalFormat),
      T.push(R.format),
      T.push(R.type),
      T.push(R.generateMipmaps),
      T.push(R.premultiplyAlpha),
      T.push(R.flipY),
      T.push(R.unpackAlignment),
      T.push(R.encoding),
      T.join()
    );
  }
  function Q(R, T) {
    const te = n.get(R);
    if (
      (R.isVideoTexture && $e(R),
      R.isRenderTargetTexture === !1 &&
        R.version > 0 &&
        te.__version !== R.version)
    ) {
      const ce = R.image;
      if (ce === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (ce.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        qe(te, R, T);
        return;
      }
    }
    t.activeTexture(33984 + T), t.bindTexture(3553, te.__webglTexture);
  }
  function ie(R, T) {
    const te = n.get(R);
    if (R.version > 0 && te.__version !== R.version) {
      qe(te, R, T);
      return;
    }
    t.activeTexture(33984 + T), t.bindTexture(35866, te.__webglTexture);
  }
  function re(R, T) {
    const te = n.get(R);
    if (R.version > 0 && te.__version !== R.version) {
      qe(te, R, T);
      return;
    }
    t.activeTexture(33984 + T), t.bindTexture(32879, te.__webglTexture);
  }
  function ee(R, T) {
    const te = n.get(R);
    if (R.version > 0 && te.__version !== R.version) {
      ke(te, R, T);
      return;
    }
    t.activeTexture(33984 + T), t.bindTexture(34067, te.__webglTexture);
  }
  const Me = { [pi]: 10497, [Zt]: 33071, [Ao]: 33648 },
    Be = {
      [zt]: 9728,
      [el]: 9984,
      [tl]: 9986,
      [st]: 9729,
      [_u]: 9985,
      [yi]: 9987,
    };
  function Re(R, T, te) {
    if (
      (te
        ? (s.texParameteri(R, 10242, Me[T.wrapS]),
          s.texParameteri(R, 10243, Me[T.wrapT]),
          (R === 32879 || R === 35866) &&
            s.texParameteri(R, 32882, Me[T.wrapR]),
          s.texParameteri(R, 10240, Be[T.magFilter]),
          s.texParameteri(R, 10241, Be[T.minFilter]))
        : (s.texParameteri(R, 10242, 33071),
          s.texParameteri(R, 10243, 33071),
          (R === 32879 || R === 35866) && s.texParameteri(R, 32882, 33071),
          (T.wrapS !== Zt || T.wrapT !== Zt) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          s.texParameteri(R, 10240, V(T.magFilter)),
          s.texParameteri(R, 10241, V(T.minFilter)),
          T.minFilter !== zt &&
            T.minFilter !== st &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const ce = e.get("EXT_texture_filter_anisotropic");
      if (
        (T.type === tn && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          T.type === nn &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (T.anisotropy > 1 || n.get(T).__currentAnisotropy) &&
        (s.texParameterf(
          R,
          ce.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(T.anisotropy, i.getMaxAnisotropy())
        ),
        (n.get(T).__currentAnisotropy = T.anisotropy));
    }
  }
  function Z(R, T) {
    let te = !1;
    R.__webglInit === void 0 &&
      ((R.__webglInit = !0), T.addEventListener("dispose", F));
    const ce = T.source;
    let _e = v.get(ce);
    _e === void 0 && ((_e = {}), v.set(ce, _e));
    const Le = k(T);
    if (Le !== R.__cacheKey) {
      _e[Le] === void 0 &&
        ((_e[Le] = { texture: s.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (te = !0)),
        _e[Le].usedTimes++;
      const He = _e[R.__cacheKey];
      He !== void 0 &&
        (_e[R.__cacheKey].usedTimes--, He.usedTimes === 0 && N(T)),
        (R.__cacheKey = Le),
        (R.__webglTexture = _e[Le].texture);
    }
    return te;
  }
  function qe(R, T, te) {
    let ce = 3553;
    T.isDataArrayTexture && (ce = 35866), T.isData3DTexture && (ce = 32879);
    const _e = Z(R, T),
      Le = T.source;
    if (
      (t.activeTexture(33984 + te),
      t.bindTexture(ce, R.__webglTexture),
      Le.version !== Le.__currentVersion || _e === !0)
    ) {
      s.pixelStorei(37440, T.flipY),
        s.pixelStorei(37441, T.premultiplyAlpha),
        s.pixelStorei(3317, T.unpackAlignment),
        s.pixelStorei(37443, 0);
      const He = b(T) && w(T.image) === !1;
      let ne = g(T.image, He, !1, h);
      ne = ut(T, ne);
      const U = w(ne) || a,
        fe = r.convert(T.format, T.encoding);
      let Ce = r.convert(T.type),
        Se = L(T.internalFormat, fe, Ce, T.encoding, T.isVideoTexture);
      Re(ce, T, U);
      let B;
      const ve = T.mipmaps,
        Te = a && T.isVideoTexture !== !0,
        Ve = R.__version === void 0,
        me = D(T, ne, U);
      if (T.isDepthTexture)
        (Se = 6402),
          a
            ? T.type === tn
              ? (Se = 36012)
              : T.type === yo
              ? (Se = 33190)
              : T.type === pr
              ? (Se = 35056)
              : (Se = 33189)
            : T.type === tn &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          T.format === Ri &&
            Se === 6402 &&
            T.type !== ds &&
            T.type !== yo &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (T.type = ds),
            (Ce = r.convert(T.type))),
          T.format === yr &&
            Se === 6402 &&
            ((Se = 34041),
            T.type !== pr &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (T.type = pr),
              (Ce = r.convert(T.type)))),
          Te && Ve
            ? t.texStorage2D(3553, 1, Se, ne.width, ne.height)
            : t.texImage2D(3553, 0, Se, ne.width, ne.height, 0, fe, Ce, null);
      else if (T.isDataTexture)
        if (ve.length > 0 && U) {
          Te && Ve && t.texStorage2D(3553, me, Se, ve[0].width, ve[0].height);
          for (let oe = 0, Ye = ve.length; oe < Ye; oe++)
            (B = ve[oe]),
              Te
                ? t.texSubImage2D(
                    3553,
                    oe,
                    0,
                    0,
                    B.width,
                    B.height,
                    fe,
                    Ce,
                    B.data
                  )
                : t.texImage2D(
                    3553,
                    oe,
                    Se,
                    B.width,
                    B.height,
                    0,
                    fe,
                    Ce,
                    B.data
                  );
          T.generateMipmaps = !1;
        } else
          Te
            ? (Ve && t.texStorage2D(3553, me, Se, ne.width, ne.height),
              t.texSubImage2D(
                3553,
                0,
                0,
                0,
                ne.width,
                ne.height,
                fe,
                Ce,
                ne.data
              ))
            : t.texImage2D(
                3553,
                0,
                Se,
                ne.width,
                ne.height,
                0,
                fe,
                Ce,
                ne.data
              );
      else if (T.isCompressedTexture) {
        Te && Ve && t.texStorage2D(3553, me, Se, ve[0].width, ve[0].height);
        for (let oe = 0, Ye = ve.length; oe < Ye; oe++)
          (B = ve[oe]),
            T.format !== Nt
              ? fe !== null
                ? Te
                  ? t.compressedTexSubImage2D(
                      3553,
                      oe,
                      0,
                      0,
                      B.width,
                      B.height,
                      fe,
                      B.data
                    )
                  : t.compressedTexImage2D(
                      3553,
                      oe,
                      Se,
                      B.width,
                      B.height,
                      0,
                      B.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                  )
              : Te
              ? t.texSubImage2D(
                  3553,
                  oe,
                  0,
                  0,
                  B.width,
                  B.height,
                  fe,
                  Ce,
                  B.data
                )
              : t.texImage2D(
                  3553,
                  oe,
                  Se,
                  B.width,
                  B.height,
                  0,
                  fe,
                  Ce,
                  B.data
                );
      } else if (T.isDataArrayTexture)
        Te
          ? (Ve && t.texStorage3D(35866, me, Se, ne.width, ne.height, ne.depth),
            t.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              ne.width,
              ne.height,
              ne.depth,
              fe,
              Ce,
              ne.data
            ))
          : t.texImage3D(
              35866,
              0,
              Se,
              ne.width,
              ne.height,
              ne.depth,
              0,
              fe,
              Ce,
              ne.data
            );
      else if (T.isData3DTexture)
        Te
          ? (Ve && t.texStorage3D(32879, me, Se, ne.width, ne.height, ne.depth),
            t.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              ne.width,
              ne.height,
              ne.depth,
              fe,
              Ce,
              ne.data
            ))
          : t.texImage3D(
              32879,
              0,
              Se,
              ne.width,
              ne.height,
              ne.depth,
              0,
              fe,
              Ce,
              ne.data
            );
      else if (T.isFramebufferTexture)
        Te && Ve
          ? t.texStorage2D(3553, me, Se, ne.width, ne.height)
          : t.texImage2D(3553, 0, Se, ne.width, ne.height, 0, fe, Ce, null);
      else if (ve.length > 0 && U) {
        Te && Ve && t.texStorage2D(3553, me, Se, ve[0].width, ve[0].height);
        for (let oe = 0, Ye = ve.length; oe < Ye; oe++)
          (B = ve[oe]),
            Te
              ? t.texSubImage2D(3553, oe, 0, 0, fe, Ce, B)
              : t.texImage2D(3553, oe, Se, fe, Ce, B);
        T.generateMipmaps = !1;
      } else
        Te
          ? (Ve && t.texStorage2D(3553, me, Se, ne.width, ne.height),
            t.texSubImage2D(3553, 0, 0, 0, fe, Ce, ne))
          : t.texImage2D(3553, 0, Se, fe, Ce, ne);
      _(T, U) && E(ce),
        (Le.__currentVersion = Le.version),
        T.onUpdate && T.onUpdate(T);
    }
    R.__version = T.version;
  }
  function ke(R, T, te) {
    if (T.image.length !== 6) return;
    const ce = Z(R, T),
      _e = T.source;
    if (
      (t.activeTexture(33984 + te),
      t.bindTexture(34067, R.__webglTexture),
      _e.version !== _e.__currentVersion || ce === !0)
    ) {
      s.pixelStorei(37440, T.flipY),
        s.pixelStorei(37441, T.premultiplyAlpha),
        s.pixelStorei(3317, T.unpackAlignment),
        s.pixelStorei(37443, 0);
      const Le = T.isCompressedTexture || T.image[0].isCompressedTexture,
        He = T.image[0] && T.image[0].isDataTexture,
        ne = [];
      for (let oe = 0; oe < 6; oe++)
        !Le && !He
          ? (ne[oe] = g(T.image[oe], !1, !0, c))
          : (ne[oe] = He ? T.image[oe].image : T.image[oe]),
          (ne[oe] = ut(T, ne[oe]));
      const U = ne[0],
        fe = w(U) || a,
        Ce = r.convert(T.format, T.encoding),
        Se = r.convert(T.type),
        B = L(T.internalFormat, Ce, Se, T.encoding),
        ve = a && T.isVideoTexture !== !0,
        Te = R.__version === void 0;
      let Ve = D(T, U, fe);
      Re(34067, T, fe);
      let me;
      if (Le) {
        ve && Te && t.texStorage2D(34067, Ve, B, U.width, U.height);
        for (let oe = 0; oe < 6; oe++) {
          me = ne[oe].mipmaps;
          for (let Ye = 0; Ye < me.length; Ye++) {
            const ue = me[Ye];
            T.format !== Nt
              ? Ce !== null
                ? ve
                  ? t.compressedTexSubImage2D(
                      34069 + oe,
                      Ye,
                      0,
                      0,
                      ue.width,
                      ue.height,
                      Ce,
                      ue.data
                    )
                  : t.compressedTexImage2D(
                      34069 + oe,
                      Ye,
                      B,
                      ue.width,
                      ue.height,
                      0,
                      ue.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : ve
              ? t.texSubImage2D(
                  34069 + oe,
                  Ye,
                  0,
                  0,
                  ue.width,
                  ue.height,
                  Ce,
                  Se,
                  ue.data
                )
              : t.texImage2D(
                  34069 + oe,
                  Ye,
                  B,
                  ue.width,
                  ue.height,
                  0,
                  Ce,
                  Se,
                  ue.data
                );
          }
        }
      } else {
        (me = T.mipmaps),
          ve &&
            Te &&
            (me.length > 0 && Ve++,
            t.texStorage2D(34067, Ve, B, ne[0].width, ne[0].height));
        for (let oe = 0; oe < 6; oe++)
          if (He) {
            ve
              ? t.texSubImage2D(
                  34069 + oe,
                  0,
                  0,
                  0,
                  ne[oe].width,
                  ne[oe].height,
                  Ce,
                  Se,
                  ne[oe].data
                )
              : t.texImage2D(
                  34069 + oe,
                  0,
                  B,
                  ne[oe].width,
                  ne[oe].height,
                  0,
                  Ce,
                  Se,
                  ne[oe].data
                );
            for (let Ye = 0; Ye < me.length; Ye++) {
              const Ct = me[Ye].image[oe].image;
              ve
                ? t.texSubImage2D(
                    34069 + oe,
                    Ye + 1,
                    0,
                    0,
                    Ct.width,
                    Ct.height,
                    Ce,
                    Se,
                    Ct.data
                  )
                : t.texImage2D(
                    34069 + oe,
                    Ye + 1,
                    B,
                    Ct.width,
                    Ct.height,
                    0,
                    Ce,
                    Se,
                    Ct.data
                  );
            }
          } else {
            ve
              ? t.texSubImage2D(34069 + oe, 0, 0, 0, Ce, Se, ne[oe])
              : t.texImage2D(34069 + oe, 0, B, Ce, Se, ne[oe]);
            for (let Ye = 0; Ye < me.length; Ye++) {
              const ue = me[Ye];
              ve
                ? t.texSubImage2D(
                    34069 + oe,
                    Ye + 1,
                    0,
                    0,
                    Ce,
                    Se,
                    ue.image[oe]
                  )
                : t.texImage2D(34069 + oe, Ye + 1, B, Ce, Se, ue.image[oe]);
            }
          }
      }
      _(T, fe) && E(34067),
        (_e.__currentVersion = _e.version),
        T.onUpdate && T.onUpdate(T);
    }
    R.__version = T.version;
  }
  function Fe(R, T, te, ce, _e) {
    const Le = r.convert(te.format, te.encoding),
      He = r.convert(te.type),
      ne = L(te.internalFormat, Le, He, te.encoding);
    n.get(T).__hasExternalTextures ||
      (_e === 32879 || _e === 35866
        ? t.texImage3D(_e, 0, ne, T.width, T.height, T.depth, 0, Le, He, null)
        : t.texImage2D(_e, 0, ne, T.width, T.height, 0, Le, He, null)),
      t.bindFramebuffer(36160, R),
      ze(T)
        ? d.framebufferTexture2DMultisampleEXT(
            36160,
            ce,
            _e,
            n.get(te).__webglTexture,
            0,
            We(T)
          )
        : s.framebufferTexture2D(36160, ce, _e, n.get(te).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function Ie(R, T, te) {
    if ((s.bindRenderbuffer(36161, R), T.depthBuffer && !T.stencilBuffer)) {
      let ce = 33189;
      if (te || ze(T)) {
        const _e = T.depthTexture;
        _e &&
          _e.isDepthTexture &&
          (_e.type === tn ? (ce = 36012) : _e.type === yo && (ce = 33190));
        const Le = We(T);
        ze(T)
          ? d.renderbufferStorageMultisampleEXT(
              36161,
              Le,
              ce,
              T.width,
              T.height
            )
          : s.renderbufferStorageMultisample(36161, Le, ce, T.width, T.height);
      } else s.renderbufferStorage(36161, ce, T.width, T.height);
      s.framebufferRenderbuffer(36160, 36096, 36161, R);
    } else if (T.depthBuffer && T.stencilBuffer) {
      const ce = We(T);
      te && ze(T) === !1
        ? s.renderbufferStorageMultisample(36161, ce, 35056, T.width, T.height)
        : ze(T)
        ? d.renderbufferStorageMultisampleEXT(
            36161,
            ce,
            35056,
            T.width,
            T.height
          )
        : s.renderbufferStorage(36161, 34041, T.width, T.height),
        s.framebufferRenderbuffer(36160, 33306, 36161, R);
    } else {
      const ce =
          T.isWebGLMultipleRenderTargets === !0 ? T.texture[0] : T.texture,
        _e = r.convert(ce.format, ce.encoding),
        Le = r.convert(ce.type),
        He = L(ce.internalFormat, _e, Le, ce.encoding),
        ne = We(T);
      te && ze(T) === !1
        ? s.renderbufferStorageMultisample(36161, ne, He, T.width, T.height)
        : ze(T)
        ? d.renderbufferStorageMultisampleEXT(36161, ne, He, T.width, T.height)
        : s.renderbufferStorage(36161, He, T.width, T.height);
    }
    s.bindRenderbuffer(36161, null);
  }
  function Ze(R, T) {
    if (T && T.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(36160, R),
      !(T.depthTexture && T.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!n.get(T.depthTexture).__webglTexture ||
      T.depthTexture.image.width !== T.width ||
      T.depthTexture.image.height !== T.height) &&
      ((T.depthTexture.image.width = T.width),
      (T.depthTexture.image.height = T.height),
      (T.depthTexture.needsUpdate = !0)),
      Q(T.depthTexture, 0);
    const ce = n.get(T.depthTexture).__webglTexture,
      _e = We(T);
    if (T.depthTexture.format === Ri)
      ze(T)
        ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ce, 0, _e)
        : s.framebufferTexture2D(36160, 36096, 3553, ce, 0);
    else if (T.depthTexture.format === yr)
      ze(T)
        ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ce, 0, _e)
        : s.framebufferTexture2D(36160, 33306, 3553, ce, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function K(R) {
    const T = n.get(R),
      te = R.isWebGLCubeRenderTarget === !0;
    if (R.depthTexture && !T.__autoAllocateDepthBuffer) {
      if (te)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Ze(T.__webglFramebuffer, R);
    } else if (te) {
      T.__webglDepthbuffer = [];
      for (let ce = 0; ce < 6; ce++)
        t.bindFramebuffer(36160, T.__webglFramebuffer[ce]),
          (T.__webglDepthbuffer[ce] = s.createRenderbuffer()),
          Ie(T.__webglDepthbuffer[ce], R, !1);
    } else
      t.bindFramebuffer(36160, T.__webglFramebuffer),
        (T.__webglDepthbuffer = s.createRenderbuffer()),
        Ie(T.__webglDepthbuffer, R, !1);
    t.bindFramebuffer(36160, null);
  }
  function de(R, T, te) {
    const ce = n.get(R);
    T !== void 0 && Fe(ce.__webglFramebuffer, R, R.texture, 36064, 3553),
      te !== void 0 && K(R);
  }
  function pe(R) {
    const T = R.texture,
      te = n.get(R),
      ce = n.get(T);
    R.addEventListener("dispose", M),
      R.isWebGLMultipleRenderTargets !== !0 &&
        (ce.__webglTexture === void 0 &&
          (ce.__webglTexture = s.createTexture()),
        (ce.__version = T.version),
        o.memory.textures++);
    const _e = R.isWebGLCubeRenderTarget === !0,
      Le = R.isWebGLMultipleRenderTargets === !0,
      He = w(R) || a;
    if (_e) {
      te.__webglFramebuffer = [];
      for (let ne = 0; ne < 6; ne++)
        te.__webglFramebuffer[ne] = s.createFramebuffer();
    } else if (((te.__webglFramebuffer = s.createFramebuffer()), Le))
      if (i.drawBuffers) {
        const ne = R.texture;
        for (let U = 0, fe = ne.length; U < fe; U++) {
          const Ce = n.get(ne[U]);
          Ce.__webglTexture === void 0 &&
            ((Ce.__webglTexture = s.createTexture()), o.memory.textures++);
        }
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
        );
    else if (a && R.samples > 0 && ze(R) === !1) {
      (te.__webglMultisampledFramebuffer = s.createFramebuffer()),
        (te.__webglColorRenderbuffer = s.createRenderbuffer()),
        s.bindRenderbuffer(36161, te.__webglColorRenderbuffer);
      const ne = r.convert(T.format, T.encoding),
        U = r.convert(T.type),
        fe = L(T.internalFormat, ne, U, T.encoding),
        Ce = We(R);
      s.renderbufferStorageMultisample(36161, Ce, fe, R.width, R.height),
        t.bindFramebuffer(36160, te.__webglMultisampledFramebuffer),
        s.framebufferRenderbuffer(
          36160,
          36064,
          36161,
          te.__webglColorRenderbuffer
        ),
        s.bindRenderbuffer(36161, null),
        R.depthBuffer &&
          ((te.__webglDepthRenderbuffer = s.createRenderbuffer()),
          Ie(te.__webglDepthRenderbuffer, R, !0)),
        t.bindFramebuffer(36160, null);
    }
    if (_e) {
      t.bindTexture(34067, ce.__webglTexture), Re(34067, T, He);
      for (let ne = 0; ne < 6; ne++)
        Fe(te.__webglFramebuffer[ne], R, T, 36064, 34069 + ne);
      _(T, He) && E(34067), t.unbindTexture();
    } else if (Le) {
      const ne = R.texture;
      for (let U = 0, fe = ne.length; U < fe; U++) {
        const Ce = ne[U],
          Se = n.get(Ce);
        t.bindTexture(3553, Se.__webglTexture),
          Re(3553, Ce, He),
          Fe(te.__webglFramebuffer, R, Ce, 36064 + U, 3553),
          _(Ce, He) && E(3553);
      }
      t.unbindTexture();
    } else {
      let ne = 3553;
      (R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) &&
        (a
          ? (ne = R.isWebGL3DRenderTarget ? 32879 : 35866)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(ne, ce.__webglTexture),
        Re(ne, T, He),
        Fe(te.__webglFramebuffer, R, T, 36064, ne),
        _(T, He) && E(ne),
        t.unbindTexture();
    }
    R.depthBuffer && K(R);
  }
  function De(R) {
    const T = w(R) || a,
      te = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture];
    for (let ce = 0, _e = te.length; ce < _e; ce++) {
      const Le = te[ce];
      if (_(Le, T)) {
        const He = R.isWebGLCubeRenderTarget ? 34067 : 3553,
          ne = n.get(Le).__webglTexture;
        t.bindTexture(He, ne), E(He), t.unbindTexture();
      }
    }
  }
  function Ee(R) {
    if (a && R.samples > 0 && ze(R) === !1) {
      const T = R.width,
        te = R.height;
      let ce = 16384;
      const _e = [36064],
        Le = R.stencilBuffer ? 33306 : 36096;
      R.depthBuffer && _e.push(Le);
      const He = n.get(R),
        ne = He.__ignoreDepthValues !== void 0 ? He.__ignoreDepthValues : !1;
      ne === !1 &&
        (R.depthBuffer && (ce |= 256), R.stencilBuffer && (ce |= 1024)),
        t.bindFramebuffer(36008, He.__webglMultisampledFramebuffer),
        t.bindFramebuffer(36009, He.__webglFramebuffer),
        ne === !0 &&
          (s.invalidateFramebuffer(36008, [Le]),
          s.invalidateFramebuffer(36009, [Le])),
        s.blitFramebuffer(0, 0, T, te, 0, 0, T, te, ce, 9728),
        s.invalidateFramebuffer(36008, _e),
        t.bindFramebuffer(36008, null),
        t.bindFramebuffer(36009, He.__webglMultisampledFramebuffer);
    }
  }
  function We(R) {
    return Math.min(u, R.samples);
  }
  function ze(R) {
    const T = n.get(R);
    return (
      a &&
      R.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      T.__useRenderToTexture !== !1
    );
  }
  function $e(R) {
    const T = o.render.frame;
    f.get(R) !== T && (f.set(R, T), R.update());
  }
  function ut(R, T) {
    const te = R.encoding,
      ce = R.format,
      _e = R.type;
    return (
      R.isCompressedTexture === !0 ||
        R.isVideoTexture === !0 ||
        R.format === ll ||
        (te !== an &&
          (te === it
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && ce === Nt
                ? ((R.format = ll),
                  (R.minFilter = st),
                  (R.generateMipmaps = !1))
                : (T = Di.sRGBToLinear(T))
              : (ce !== Nt || _e !== mi) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                te
              ))),
      T
    );
  }
  (this.allocateTextureUnit = W),
    (this.resetTextureUnits = G),
    (this.setTexture2D = Q),
    (this.setTexture2DArray = ie),
    (this.setTexture3D = re),
    (this.setTextureCube = ee),
    (this.rebindTextures = de),
    (this.setupRenderTarget = pe),
    (this.updateRenderTargetMipmap = De),
    (this.updateMultisampleRenderTarget = Ee),
    (this.setupDepthRenderbuffer = K),
    (this.setupFrameBufferTexture = Fe),
    (this.useMultisampledRTT = ze);
}
function ix(s, e, t) {
  const n = t.isWebGL2;
  function i(r, o = null) {
    let a;
    if (r === mi) return 5121;
    if (r === Xf) return 32819;
    if (r === jf) return 32820;
    if (r === Gf) return 5120;
    if (r === Vf) return 5122;
    if (r === ds) return 5123;
    if (r === Wf) return 5124;
    if (r === yo) return 5125;
    if (r === tn) return 5126;
    if (r === nn)
      return n
        ? 5131
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (r === qf) return 6406;
    if (r === Nt) return 6408;
    if (r === Zf) return 6409;
    if (r === $f) return 6410;
    if (r === Ri) return 6402;
    if (r === yr) return 34041;
    if (r === wu) return 6403;
    if (r === Yf)
      return (
        console.warn(
          "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
        ),
        6408
      );
    if (r === ll)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (r === Kf) return 36244;
    if (r === Jf) return 33319;
    if (r === Qf) return 33320;
    if (r === ep) return 36249;
    if (r === _o || r === ra || r === sa || r === wo)
      if (o === it)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (r === _o) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === ra) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === sa) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === wo) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (r === _o) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === ra) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === sa) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === wo) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === nl || r === bc || r === il || r === Mc)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (r === nl) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === bc) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === il) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === Mc) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === bu)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (r === rl || r === sl)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (r === rl)
          return o === it ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (r === sl)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === ol ||
      r === Sc ||
      r === Tc ||
      r === Ec ||
      r === Ac ||
      r === Cc ||
      r === Rc ||
      r === Lc ||
      r === Pc ||
      r === Ic ||
      r === Dc ||
      r === Fc ||
      r === Nc ||
      r === Bc
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (r === ol)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === Sc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === Tc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === Ec)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === Ac)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === Cc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === Rc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === Lc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === Pc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === Ic)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === Dc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === Fc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === Nc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === Bc)
          return o === it
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === al)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (r === al)
          return o === it
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (r === pr)
      return n
        ? 34042
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: i };
}
class Hu extends Yt {
  constructor(e = []) {
    super();
    this.cameras = e;
  }
}
Hu.prototype.isArrayCamera = !0;
class Ln extends at {
  constructor() {
    super();
    this.type = "Group";
  }
}
Ln.prototype.isGroup = !0;
const rx = { type: "move" };
class Da {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Ln()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Ln()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new P()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new P())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Ln()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new P()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new P())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      r = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred")
      if (
        (a !== null &&
          ((i = t.getPose(e.targetRaySpace, n)),
          i !== null &&
            (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            i.linearVelocity
              ? ((a.hasLinearVelocity = !0),
                a.linearVelocity.copy(i.linearVelocity))
              : (a.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((a.hasAngularVelocity = !0),
                a.angularVelocity.copy(i.angularVelocity))
              : (a.hasAngularVelocity = !1),
            this.dispatchEvent(rx))),
        c && e.hand)
      ) {
        o = !0;
        for (const v of e.hand.values()) {
          const y = t.getJointPose(v, n);
          if (c.joints[v.jointName] === void 0) {
            const g = new Ln();
            (g.matrixAutoUpdate = !1),
              (g.visible = !1),
              (c.joints[v.jointName] = g),
              c.add(g);
          }
          const p = c.joints[v.jointName];
          y !== null &&
            (p.matrix.fromArray(y.transform.matrix),
            p.matrix.decompose(p.position, p.rotation, p.scale),
            (p.jointRadius = y.radius)),
            (p.visible = y !== null);
        }
        const h = c.joints["index-finger-tip"],
          u = c.joints["thumb-tip"],
          d = h.position.distanceTo(u.position),
          f = 0.02,
          m = 0.005;
        c.inputState.pinching && d > f + m
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            d <= f - m &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((r = t.getPose(e.gripSpace, n)),
          r !== null &&
            (l.matrix.fromArray(r.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            r.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(r.linearVelocity))
              : (l.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(r.angularVelocity))
              : (l.hasAngularVelocity = !1)));
    return (
      a !== null && (a.visible = i !== null),
      l !== null && (l.visible = r !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
}
class Gu extends At {
  constructor(e, t, n, i, r, o, a, l, c, h) {
    if (((h = h !== void 0 ? h : Ri), h !== Ri && h !== yr))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && h === Ri && (n = ds), n === void 0 && h === yr && (n = pr);
    super(null, i, r, o, a, l, h, n, c);
    (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : zt),
      (this.minFilter = l !== void 0 ? l : zt),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
Gu.prototype.isDepthTexture = !0;
class sx extends _i {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      r = 1,
      o = null,
      a = "local-floor",
      l = null,
      c = null,
      h = null,
      u = null,
      d = null;
    const f = t.getContextAttributes();
    let m = null,
      v = null;
    const y = [],
      p = new Map(),
      g = new Yt();
    g.layers.enable(1), (g.viewport = new ct());
    const w = new Yt();
    w.layers.enable(2), (w.viewport = new ct());
    const b = [g, w],
      _ = new Hu();
    _.layers.enable(1), _.layers.enable(2);
    let E = null,
      L = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (k) {
        let Q = y[k];
        return (
          Q === void 0 && ((Q = new Da()), (y[k] = Q)), Q.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (k) {
        let Q = y[k];
        return Q === void 0 && ((Q = new Da()), (y[k] = Q)), Q.getGripSpace();
      }),
      (this.getHand = function (k) {
        let Q = y[k];
        return Q === void 0 && ((Q = new Da()), (y[k] = Q)), Q.getHandSpace();
      });
    function D(k) {
      const Q = p.get(k.inputSource);
      Q && Q.dispatchEvent({ type: k.type, data: k.inputSource });
    }
    function V() {
      p.forEach(function (k, Q) {
        k.disconnect(Q);
      }),
        p.clear(),
        (E = null),
        (L = null),
        e.setRenderTarget(m),
        (u = null),
        (h = null),
        (c = null),
        (i = null),
        (v = null),
        W.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (k) {
      (r = k),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (k) {
        (a = k),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return o;
      }),
      (this.getBaseLayer = function () {
        return h !== null ? h : u;
      }),
      (this.getBinding = function () {
        return c;
      }),
      (this.getFrame = function () {
        return d;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (k) {
        if (((i = k), i !== null)) {
          if (
            ((m = e.getRenderTarget()),
            i.addEventListener("select", D),
            i.addEventListener("selectstart", D),
            i.addEventListener("selectend", D),
            i.addEventListener("squeeze", D),
            i.addEventListener("squeezestart", D),
            i.addEventListener("squeezeend", D),
            i.addEventListener("end", V),
            i.addEventListener("inputsourceschange", F),
            f.xrCompatible !== !0 && (await t.makeXRCompatible()),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const Q = {
              antialias: i.renderState.layers === void 0 ? f.antialias : !0,
              alpha: f.alpha,
              depth: f.depth,
              stencil: f.stencil,
              framebufferScaleFactor: r,
            };
            (u = new XRWebGLLayer(i, t, Q)),
              i.updateRenderState({ baseLayer: u }),
              (v = new Bt(u.framebufferWidth, u.framebufferHeight, {
                format: Nt,
                type: mi,
                encoding: e.outputEncoding,
              }));
          } else {
            let Q = null,
              ie = null,
              re = null;
            f.depth &&
              ((re = f.stencil ? 35056 : 33190),
              (Q = f.stencil ? yr : Ri),
              (ie = f.stencil ? pr : ds));
            const ee = {
              colorFormat: e.outputEncoding === it ? 35907 : 32856,
              depthFormat: re,
              scaleFactor: r,
            };
            (c = new XRWebGLBinding(i, t)),
              (h = c.createProjectionLayer(ee)),
              i.updateRenderState({ layers: [h] }),
              (v = new Bt(h.textureWidth, h.textureHeight, {
                format: Nt,
                type: mi,
                depthTexture: new Gu(
                  h.textureWidth,
                  h.textureHeight,
                  ie,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Q
                ),
                stencilBuffer: f.stencil,
                encoding: e.outputEncoding,
                samples: f.antialias ? 4 : 0,
              }));
            const Me = e.properties.get(v);
            Me.__ignoreDepthValues = h.ignoreDepthValues;
          }
          (v.isXRRenderTarget = !0),
            this.setFoveation(1),
            (o = await i.requestReferenceSpace(a)),
            W.setContext(i),
            W.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      });
    function F(k) {
      const Q = i.inputSources;
      for (let ie = 0; ie < y.length; ie++) p.set(Q[ie], y[ie]);
      for (let ie = 0; ie < k.removed.length; ie++) {
        const re = k.removed[ie],
          ee = p.get(re);
        ee &&
          (ee.dispatchEvent({ type: "disconnected", data: re }), p.delete(re));
      }
      for (let ie = 0; ie < k.added.length; ie++) {
        const re = k.added[ie],
          ee = p.get(re);
        ee && ee.dispatchEvent({ type: "connected", data: re });
      }
    }
    const M = new P(),
      A = new P();
    function N(k, Q, ie) {
      M.setFromMatrixPosition(Q.matrixWorld),
        A.setFromMatrixPosition(ie.matrixWorld);
      const re = M.distanceTo(A),
        ee = Q.projectionMatrix.elements,
        Me = ie.projectionMatrix.elements,
        Be = ee[14] / (ee[10] - 1),
        Re = ee[14] / (ee[10] + 1),
        Z = (ee[9] + 1) / ee[5],
        qe = (ee[9] - 1) / ee[5],
        ke = (ee[8] - 1) / ee[0],
        Fe = (Me[8] + 1) / Me[0],
        Ie = Be * ke,
        Ze = Be * Fe,
        K = re / (-ke + Fe),
        de = K * -ke;
      Q.matrixWorld.decompose(k.position, k.quaternion, k.scale),
        k.translateX(de),
        k.translateZ(K),
        k.matrixWorld.compose(k.position, k.quaternion, k.scale),
        k.matrixWorldInverse.copy(k.matrixWorld).invert();
      const pe = Be + K,
        De = Re + K,
        Ee = Ie - de,
        We = Ze + (re - de),
        ze = ((Z * Re) / De) * pe,
        $e = ((qe * Re) / De) * pe;
      k.projectionMatrix.makePerspective(Ee, We, ze, $e, pe, De);
    }
    function O(k, Q) {
      Q === null
        ? k.matrixWorld.copy(k.matrix)
        : k.matrixWorld.multiplyMatrices(Q.matrixWorld, k.matrix),
        k.matrixWorldInverse.copy(k.matrixWorld).invert();
    }
    (this.updateCamera = function (k) {
      if (i === null) return;
      (_.near = w.near = g.near = k.near),
        (_.far = w.far = g.far = k.far),
        (E !== _.near || L !== _.far) &&
          (i.updateRenderState({ depthNear: _.near, depthFar: _.far }),
          (E = _.near),
          (L = _.far));
      const Q = k.parent,
        ie = _.cameras;
      O(_, Q);
      for (let ee = 0; ee < ie.length; ee++) O(ie[ee], Q);
      _.matrixWorld.decompose(_.position, _.quaternion, _.scale),
        k.position.copy(_.position),
        k.quaternion.copy(_.quaternion),
        k.scale.copy(_.scale),
        k.matrix.copy(_.matrix),
        k.matrixWorld.copy(_.matrixWorld);
      const re = k.children;
      for (let ee = 0, Me = re.length; ee < Me; ee++)
        re[ee].updateMatrixWorld(!0);
      ie.length === 2
        ? N(_, g, w)
        : _.projectionMatrix.copy(g.projectionMatrix);
    }),
      (this.getCamera = function () {
        return _;
      }),
      (this.getFoveation = function () {
        if (h !== null) return h.fixedFoveation;
        if (u !== null) return u.fixedFoveation;
      }),
      (this.setFoveation = function (k) {
        h !== null && (h.fixedFoveation = k),
          u !== null && u.fixedFoveation !== void 0 && (u.fixedFoveation = k);
      });
    let H = null;
    function G(k, Q) {
      if (((l = Q.getViewerPose(o)), (d = Q), l !== null)) {
        const re = l.views;
        u !== null &&
          (e.setRenderTargetFramebuffer(v, u.framebuffer),
          e.setRenderTarget(v));
        let ee = !1;
        re.length !== _.cameras.length && ((_.cameras.length = 0), (ee = !0));
        for (let Me = 0; Me < re.length; Me++) {
          const Be = re[Me];
          let Re = null;
          if (u !== null) Re = u.getViewport(Be);
          else {
            const qe = c.getViewSubImage(h, Be);
            (Re = qe.viewport),
              Me === 0 &&
                (e.setRenderTargetTextures(
                  v,
                  qe.colorTexture,
                  h.ignoreDepthValues ? void 0 : qe.depthStencilTexture
                ),
                e.setRenderTarget(v));
          }
          const Z = b[Me];
          Z.matrix.fromArray(Be.transform.matrix),
            Z.projectionMatrix.fromArray(Be.projectionMatrix),
            Z.viewport.set(Re.x, Re.y, Re.width, Re.height),
            Me === 0 && _.matrix.copy(Z.matrix),
            ee === !0 && _.cameras.push(Z);
        }
      }
      const ie = i.inputSources;
      for (let re = 0; re < y.length; re++) {
        const ee = y[re],
          Me = ie[re];
        ee.update(Me, Q, o);
      }
      H && H(k, Q), (d = null);
    }
    const W = new Iu();
    W.setAnimationLoop(G),
      (this.setAnimationLoop = function (k) {
        H = k;
      }),
      (this.dispose = function () {});
  }
}
function ox(s) {
  function e(p, g) {
    p.fogColor.value.copy(g.color),
      g.isFog
        ? ((p.fogNear.value = g.near), (p.fogFar.value = g.far))
        : g.isFogExp2 && (p.fogDensity.value = g.density);
  }
  function t(p, g, w, b, _) {
    g.isMeshBasicMaterial
      ? n(p, g)
      : g.isMeshLambertMaterial
      ? (n(p, g), l(p, g))
      : g.isMeshToonMaterial
      ? (n(p, g), h(p, g))
      : g.isMeshPhongMaterial
      ? (n(p, g), c(p, g))
      : g.isMeshStandardMaterial
      ? (n(p, g), g.isMeshPhysicalMaterial ? d(p, g, _) : u(p, g))
      : g.isMeshMatcapMaterial
      ? (n(p, g), f(p, g))
      : g.isMeshDepthMaterial
      ? (n(p, g), m(p, g))
      : g.isMeshDistanceMaterial
      ? (n(p, g), v(p, g))
      : g.isMeshNormalMaterial
      ? (n(p, g), y(p, g))
      : g.isLineBasicMaterial
      ? (i(p, g), g.isLineDashedMaterial && r(p, g))
      : g.isPointsMaterial
      ? o(p, g, w, b)
      : g.isSpriteMaterial
      ? a(p, g)
      : g.isShadowMaterial
      ? (p.color.value.copy(g.color), (p.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function n(p, g) {
    (p.opacity.value = g.opacity),
      g.color && p.diffuse.value.copy(g.color),
      g.emissive &&
        p.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && (p.map.value = g.map),
      g.alphaMap && (p.alphaMap.value = g.alphaMap),
      g.specularMap && (p.specularMap.value = g.specularMap),
      g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
    const w = s.get(g).envMap;
    w &&
      ((p.envMap.value = w),
      (p.flipEnvMap.value =
        w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1),
      (p.reflectivity.value = g.reflectivity),
      (p.ior.value = g.ior),
      (p.refractionRatio.value = g.refractionRatio)),
      g.lightMap &&
        ((p.lightMap.value = g.lightMap),
        (p.lightMapIntensity.value = g.lightMapIntensity)),
      g.aoMap &&
        ((p.aoMap.value = g.aoMap),
        (p.aoMapIntensity.value = g.aoMapIntensity));
    let b;
    g.map
      ? (b = g.map)
      : g.specularMap
      ? (b = g.specularMap)
      : g.displacementMap
      ? (b = g.displacementMap)
      : g.normalMap
      ? (b = g.normalMap)
      : g.bumpMap
      ? (b = g.bumpMap)
      : g.roughnessMap
      ? (b = g.roughnessMap)
      : g.metalnessMap
      ? (b = g.metalnessMap)
      : g.alphaMap
      ? (b = g.alphaMap)
      : g.emissiveMap
      ? (b = g.emissiveMap)
      : g.clearcoatMap
      ? (b = g.clearcoatMap)
      : g.clearcoatNormalMap
      ? (b = g.clearcoatNormalMap)
      : g.clearcoatRoughnessMap
      ? (b = g.clearcoatRoughnessMap)
      : g.specularIntensityMap
      ? (b = g.specularIntensityMap)
      : g.specularColorMap
      ? (b = g.specularColorMap)
      : g.transmissionMap
      ? (b = g.transmissionMap)
      : g.thicknessMap
      ? (b = g.thicknessMap)
      : g.sheenColorMap
      ? (b = g.sheenColorMap)
      : g.sheenRoughnessMap && (b = g.sheenRoughnessMap),
      b !== void 0 &&
        (b.isWebGLRenderTarget && (b = b.texture),
        b.matrixAutoUpdate === !0 && b.updateMatrix(),
        p.uvTransform.value.copy(b.matrix));
    let _;
    g.aoMap ? (_ = g.aoMap) : g.lightMap && (_ = g.lightMap),
      _ !== void 0 &&
        (_.isWebGLRenderTarget && (_ = _.texture),
        _.matrixAutoUpdate === !0 && _.updateMatrix(),
        p.uv2Transform.value.copy(_.matrix));
  }
  function i(p, g) {
    p.diffuse.value.copy(g.color), (p.opacity.value = g.opacity);
  }
  function r(p, g) {
    (p.dashSize.value = g.dashSize),
      (p.totalSize.value = g.dashSize + g.gapSize),
      (p.scale.value = g.scale);
  }
  function o(p, g, w, b) {
    p.diffuse.value.copy(g.color),
      (p.opacity.value = g.opacity),
      (p.size.value = g.size * w),
      (p.scale.value = b * 0.5),
      g.map && (p.map.value = g.map),
      g.alphaMap && (p.alphaMap.value = g.alphaMap),
      g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
    let _;
    g.map ? (_ = g.map) : g.alphaMap && (_ = g.alphaMap),
      _ !== void 0 &&
        (_.matrixAutoUpdate === !0 && _.updateMatrix(),
        p.uvTransform.value.copy(_.matrix));
  }
  function a(p, g) {
    p.diffuse.value.copy(g.color),
      (p.opacity.value = g.opacity),
      (p.rotation.value = g.rotation),
      g.map && (p.map.value = g.map),
      g.alphaMap && (p.alphaMap.value = g.alphaMap),
      g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
    let w;
    g.map ? (w = g.map) : g.alphaMap && (w = g.alphaMap),
      w !== void 0 &&
        (w.matrixAutoUpdate === !0 && w.updateMatrix(),
        p.uvTransform.value.copy(w.matrix));
  }
  function l(p, g) {
    g.emissiveMap && (p.emissiveMap.value = g.emissiveMap);
  }
  function c(p, g) {
    p.specular.value.copy(g.specular),
      (p.shininess.value = Math.max(g.shininess, 1e-4)),
      g.emissiveMap && (p.emissiveMap.value = g.emissiveMap),
      g.bumpMap &&
        ((p.bumpMap.value = g.bumpMap),
        (p.bumpScale.value = g.bumpScale),
        g.side === Ut && (p.bumpScale.value *= -1)),
      g.normalMap &&
        ((p.normalMap.value = g.normalMap),
        p.normalScale.value.copy(g.normalScale),
        g.side === Ut && p.normalScale.value.negate()),
      g.displacementMap &&
        ((p.displacementMap.value = g.displacementMap),
        (p.displacementScale.value = g.displacementScale),
        (p.displacementBias.value = g.displacementBias));
  }
  function h(p, g) {
    g.gradientMap && (p.gradientMap.value = g.gradientMap),
      g.emissiveMap && (p.emissiveMap.value = g.emissiveMap),
      g.bumpMap &&
        ((p.bumpMap.value = g.bumpMap),
        (p.bumpScale.value = g.bumpScale),
        g.side === Ut && (p.bumpScale.value *= -1)),
      g.normalMap &&
        ((p.normalMap.value = g.normalMap),
        p.normalScale.value.copy(g.normalScale),
        g.side === Ut && p.normalScale.value.negate()),
      g.displacementMap &&
        ((p.displacementMap.value = g.displacementMap),
        (p.displacementScale.value = g.displacementScale),
        (p.displacementBias.value = g.displacementBias));
  }
  function u(p, g) {
    (p.roughness.value = g.roughness),
      (p.metalness.value = g.metalness),
      g.roughnessMap && (p.roughnessMap.value = g.roughnessMap),
      g.metalnessMap && (p.metalnessMap.value = g.metalnessMap),
      g.emissiveMap && (p.emissiveMap.value = g.emissiveMap),
      g.bumpMap &&
        ((p.bumpMap.value = g.bumpMap),
        (p.bumpScale.value = g.bumpScale),
        g.side === Ut && (p.bumpScale.value *= -1)),
      g.normalMap &&
        ((p.normalMap.value = g.normalMap),
        p.normalScale.value.copy(g.normalScale),
        g.side === Ut && p.normalScale.value.negate()),
      g.displacementMap &&
        ((p.displacementMap.value = g.displacementMap),
        (p.displacementScale.value = g.displacementScale),
        (p.displacementBias.value = g.displacementBias)),
      s.get(g).envMap && (p.envMapIntensity.value = g.envMapIntensity);
  }
  function d(p, g, w) {
    u(p, g),
      (p.ior.value = g.ior),
      g.sheen > 0 &&
        (p.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (p.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap && (p.sheenColorMap.value = g.sheenColorMap),
        g.sheenRoughnessMap &&
          (p.sheenRoughnessMap.value = g.sheenRoughnessMap)),
      g.clearcoat > 0 &&
        ((p.clearcoat.value = g.clearcoat),
        (p.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap && (p.clearcoatMap.value = g.clearcoatMap),
        g.clearcoatRoughnessMap &&
          (p.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
        g.clearcoatNormalMap &&
          (p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          (p.clearcoatNormalMap.value = g.clearcoatNormalMap),
          g.side === Ut && p.clearcoatNormalScale.value.negate())),
      g.transmission > 0 &&
        ((p.transmission.value = g.transmission),
        (p.transmissionSamplerMap.value = w.texture),
        p.transmissionSamplerSize.value.set(w.width, w.height),
        g.transmissionMap && (p.transmissionMap.value = g.transmissionMap),
        (p.thickness.value = g.thickness),
        g.thicknessMap && (p.thicknessMap.value = g.thicknessMap),
        (p.attenuationDistance.value = g.attenuationDistance),
        p.attenuationColor.value.copy(g.attenuationColor)),
      (p.specularIntensity.value = g.specularIntensity),
      p.specularColor.value.copy(g.specularColor),
      g.specularIntensityMap &&
        (p.specularIntensityMap.value = g.specularIntensityMap),
      g.specularColorMap && (p.specularColorMap.value = g.specularColorMap);
  }
  function f(p, g) {
    g.matcap && (p.matcap.value = g.matcap),
      g.bumpMap &&
        ((p.bumpMap.value = g.bumpMap),
        (p.bumpScale.value = g.bumpScale),
        g.side === Ut && (p.bumpScale.value *= -1)),
      g.normalMap &&
        ((p.normalMap.value = g.normalMap),
        p.normalScale.value.copy(g.normalScale),
        g.side === Ut && p.normalScale.value.negate()),
      g.displacementMap &&
        ((p.displacementMap.value = g.displacementMap),
        (p.displacementScale.value = g.displacementScale),
        (p.displacementBias.value = g.displacementBias));
  }
  function m(p, g) {
    g.displacementMap &&
      ((p.displacementMap.value = g.displacementMap),
      (p.displacementScale.value = g.displacementScale),
      (p.displacementBias.value = g.displacementBias));
  }
  function v(p, g) {
    g.displacementMap &&
      ((p.displacementMap.value = g.displacementMap),
      (p.displacementScale.value = g.displacementScale),
      (p.displacementBias.value = g.displacementBias)),
      p.referencePosition.value.copy(g.referencePosition),
      (p.nearDistance.value = g.nearDistance),
      (p.farDistance.value = g.farDistance);
  }
  function y(p, g) {
    g.bumpMap &&
      ((p.bumpMap.value = g.bumpMap),
      (p.bumpScale.value = g.bumpScale),
      g.side === Ut && (p.bumpScale.value *= -1)),
      g.normalMap &&
        ((p.normalMap.value = g.normalMap),
        p.normalScale.value.copy(g.normalScale),
        g.side === Ut && p.normalScale.value.negate()),
      g.displacementMap &&
        ((p.displacementMap.value = g.displacementMap),
        (p.displacementScale.value = g.displacementScale),
        (p.displacementBias.value = g.displacementBias));
  }
  return { refreshFogUniforms: e, refreshMaterialUniforms: t };
}
function ax() {
  const s = gs("canvas");
  return (s.style.display = "block"), s;
}
function mt(s = {}) {
  const e = s.canvas !== void 0 ? s.canvas : ax(),
    t = s.context !== void 0 ? s.context : null,
    n = s.depth !== void 0 ? s.depth : !0,
    i = s.stencil !== void 0 ? s.stencil : !0,
    r = s.antialias !== void 0 ? s.antialias : !1,
    o = s.premultipliedAlpha !== void 0 ? s.premultipliedAlpha : !0,
    a = s.preserveDrawingBuffer !== void 0 ? s.preserveDrawingBuffer : !1,
    l = s.powerPreference !== void 0 ? s.powerPreference : "default",
    c =
      s.failIfMajorPerformanceCaveat !== void 0
        ? s.failIfMajorPerformanceCaveat
        : !1;
  let h;
  s.context !== void 0
    ? (h = t.getContextAttributes().alpha)
    : (h = s.alpha !== void 0 ? s.alpha : !1);
  let u = null,
    d = null;
  const f = [],
    m = [];
  (this.domElement = e),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.outputEncoding = an),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = hi),
    (this.toneMappingExposure = 1);
  const v = this;
  let y = !1,
    p = 0,
    g = 0,
    w = null,
    b = -1,
    _ = null;
  const E = new ct(),
    L = new ct();
  let D = null,
    V = e.width,
    F = e.height,
    M = 1,
    A = null,
    N = null;
  const O = new ct(0, 0, V, F),
    H = new ct(0, 0, V, F);
  let G = !1;
  const W = new Xo();
  let k = !1,
    Q = !1,
    ie = null;
  const re = new be(),
    ee = new ae(),
    Me = new P(),
    Be = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function Re() {
    return w === null ? M : 1;
  }
  let Z = t;
  function qe(C, q) {
    for (let J = 0; J < C.length; J++) {
      const $ = C[J],
        Y = e.getContext($, q);
      if (Y !== null) return Y;
    }
    return null;
  }
  try {
    const C = {
      alpha: !0,
      depth: n,
      stencil: i,
      antialias: r,
      premultipliedAlpha: o,
      preserveDrawingBuffer: a,
      powerPreference: l,
      failIfMajorPerformanceCaveat: c,
    };
    if (
      ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Rl}`),
      e.addEventListener("webglcontextlost", B, !1),
      e.addEventListener("webglcontextrestored", ve, !1),
      Z === null)
    ) {
      const q = ["webgl2", "webgl", "experimental-webgl"];
      if ((v.isWebGL1Renderer === !0 && q.shift(), (Z = qe(q, C)), Z === null))
        throw qe(q)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    Z.getShaderPrecisionFormat === void 0 &&
      (Z.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (C) {
    throw (console.error("THREE.WebGLRenderer: " + C.message), C);
  }
  let ke,
    Fe,
    Ie,
    Ze,
    K,
    de,
    pe,
    De,
    Ee,
    We,
    ze,
    $e,
    ut,
    R,
    T,
    te,
    ce,
    _e,
    Le,
    He,
    ne,
    U,
    fe;
  function Ce() {
    (ke = new T0(Z)),
      (Fe = new y0(Z, ke, s)),
      ke.init(Fe),
      (U = new ix(Z, ke, Fe)),
      (Ie = new tx(Z, ke, Fe)),
      (Ze = new C0(Z)),
      (K = new Wv()),
      (de = new nx(Z, ke, Ie, K, Fe, U, Ze)),
      (pe = new w0(v)),
      (De = new S0(v)),
      (Ee = new Gp(Z, Fe)),
      (fe = new v0(Z, ke, Ee, Fe)),
      (We = new E0(Z, Ee, Ze, fe)),
      (ze = new I0(Z, We, Ee, Ze)),
      (Le = new P0(Z, Fe, de)),
      (te = new _0(K)),
      ($e = new Vv(v, pe, De, ke, Fe, fe, te)),
      (ut = new ox(K)),
      (R = new jv()),
      (T = new Jv(ke, Fe)),
      (_e = new g0(v, pe, Ie, ze, h, o)),
      (ce = new ku(v, ze, Fe)),
      (He = new x0(Z, ke, Ze, Fe)),
      (ne = new A0(Z, ke, Ze, Fe)),
      (Ze.programs = $e.programs),
      (v.capabilities = Fe),
      (v.extensions = ke),
      (v.properties = K),
      (v.renderLists = R),
      (v.shadowMap = ce),
      (v.state = Ie),
      (v.info = Ze);
  }
  Ce();
  const Se = new sx(v, Z);
  (this.xr = Se),
    (this.getContext = function () {
      return Z;
    }),
    (this.getContextAttributes = function () {
      return Z.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      const C = ke.get("WEBGL_lose_context");
      C && C.loseContext();
    }),
    (this.forceContextRestore = function () {
      const C = ke.get("WEBGL_lose_context");
      C && C.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return M;
    }),
    (this.setPixelRatio = function (C) {
      C !== void 0 && ((M = C), this.setSize(V, F, !1));
    }),
    (this.getSize = function (C) {
      return C.set(V, F);
    }),
    (this.setSize = function (C, q, J) {
      if (Se.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
        );
        return;
      }
      (V = C),
        (F = q),
        (e.width = Math.floor(C * M)),
        (e.height = Math.floor(q * M)),
        J !== !1 && ((e.style.width = C + "px"), (e.style.height = q + "px")),
        this.setViewport(0, 0, C, q);
    }),
    (this.getDrawingBufferSize = function (C) {
      return C.set(V * M, F * M).floor();
    }),
    (this.setDrawingBufferSize = function (C, q, J) {
      (V = C),
        (F = q),
        (M = J),
        (e.width = Math.floor(C * J)),
        (e.height = Math.floor(q * J)),
        this.setViewport(0, 0, C, q);
    }),
    (this.getCurrentViewport = function (C) {
      return C.copy(E);
    }),
    (this.getViewport = function (C) {
      return C.copy(O);
    }),
    (this.setViewport = function (C, q, J, $) {
      C.isVector4 ? O.set(C.x, C.y, C.z, C.w) : O.set(C, q, J, $),
        Ie.viewport(E.copy(O).multiplyScalar(M).floor());
    }),
    (this.getScissor = function (C) {
      return C.copy(H);
    }),
    (this.setScissor = function (C, q, J, $) {
      C.isVector4 ? H.set(C.x, C.y, C.z, C.w) : H.set(C, q, J, $),
        Ie.scissor(L.copy(H).multiplyScalar(M).floor());
    }),
    (this.getScissorTest = function () {
      return G;
    }),
    (this.setScissorTest = function (C) {
      Ie.setScissorTest((G = C));
    }),
    (this.setOpaqueSort = function (C) {
      A = C;
    }),
    (this.setTransparentSort = function (C) {
      N = C;
    }),
    (this.getClearColor = function (C) {
      return C.copy(_e.getClearColor());
    }),
    (this.setClearColor = function () {
      _e.setClearColor.apply(_e, arguments);
    }),
    (this.getClearAlpha = function () {
      return _e.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      _e.setClearAlpha.apply(_e, arguments);
    }),
    (this.clear = function (C = !0, q = !0, J = !0) {
      let $ = 0;
      C && ($ |= 16384), q && ($ |= 256), J && ($ |= 1024), Z.clear($);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      e.removeEventListener("webglcontextlost", B, !1),
        e.removeEventListener("webglcontextrestored", ve, !1),
        R.dispose(),
        T.dispose(),
        K.dispose(),
        pe.dispose(),
        De.dispose(),
        ze.dispose(),
        fe.dispose(),
        $e.dispose(),
        Se.dispose(),
        Se.removeEventListener("sessionstart", ue),
        Se.removeEventListener("sessionend", Ct),
        ie && (ie.dispose(), (ie = null)),
        dt.stop();
    });
  function B(C) {
    C.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (y = !0);
  }
  function ve() {
    console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
    const C = Ze.autoReset,
      q = ce.enabled,
      J = ce.autoUpdate,
      $ = ce.needsUpdate,
      Y = ce.type;
    Ce(),
      (Ze.autoReset = C),
      (ce.enabled = q),
      (ce.autoUpdate = J),
      (ce.needsUpdate = $),
      (ce.type = Y);
  }
  function Te(C) {
    const q = C.target;
    q.removeEventListener("dispose", Te), Ve(q);
  }
  function Ve(C) {
    me(C), K.remove(C);
  }
  function me(C) {
    const q = K.get(C).programs;
    q !== void 0 &&
      (q.forEach(function (J) {
        $e.releaseProgram(J);
      }),
      C.isShaderMaterial && $e.releaseShaderCache(C));
  }
  (this.renderBufferDirect = function (C, q, J, $, Y, je) {
    q === null && (q = Be);
    const Ke = Y.isMesh && Y.matrixWorld.determinant() < 0,
      x = ta(C, q, J, $, Y);
    Ie.setMaterial($, Ke);
    let S = J.index;
    const I = J.attributes.position;
    if (S === null) {
      if (I === void 0 || I.count === 0) return;
    } else if (S.count === 0) return;
    let z = 1;
    $.wireframe === !0 && ((S = We.getWireframeAttribute(J)), (z = 2)),
      fe.setup(Y, $, x, J, S);
    let j,
      X = He;
    S !== null && ((j = Ee.get(S)), (X = ne), X.setIndex(j));
    const he = S !== null ? S.count : I.count,
      ge = J.drawRange.start * z,
      xe = J.drawRange.count * z,
      le = je !== null ? je.start * z : 0,
      se = je !== null ? je.count * z : 1 / 0,
      Pe = Math.max(ge, le),
      we = Math.min(he, ge + xe, le + se) - 1,
      Oe = Math.max(0, we - Pe + 1);
    if (Oe !== 0) {
      if (Y.isMesh)
        $.wireframe === !0
          ? (Ie.setLineWidth($.wireframeLinewidth * Re()), X.setMode(1))
          : X.setMode(4);
      else if (Y.isLine) {
        let Xe = $.linewidth;
        Xe === void 0 && (Xe = 1),
          Ie.setLineWidth(Xe * Re()),
          Y.isLineSegments
            ? X.setMode(1)
            : Y.isLineLoop
            ? X.setMode(2)
            : X.setMode(3);
      } else Y.isPoints ? X.setMode(0) : Y.isSprite && X.setMode(4);
      if (Y.isInstancedMesh) X.renderInstances(Pe, Oe, Y.count);
      else if (J.isInstancedBufferGeometry) {
        const Xe = Math.min(J.instanceCount, J._maxInstanceCount);
        X.renderInstances(Pe, Oe, Xe);
      } else X.render(Pe, Oe);
    }
  }),
    (this.compile = function (C, q) {
      (d = T.get(C)),
        d.init(),
        m.push(d),
        C.traverseVisible(function (J) {
          J.isLight &&
            J.layers.test(q.layers) &&
            (d.pushLight(J), J.castShadow && d.pushShadow(J));
        }),
        d.setupLights(v.physicallyCorrectLights),
        C.traverse(function (J) {
          const $ = J.material;
          if ($)
            if (Array.isArray($))
              for (let Y = 0; Y < $.length; Y++) {
                const je = $[Y];
                jr(je, C, J);
              }
            else jr($, C, J);
        }),
        m.pop(),
        (d = null);
    });
  let oe = null;
  function Ye(C) {
    oe && oe(C);
  }
  function ue() {
    dt.stop();
  }
  function Ct() {
    dt.start();
  }
  const dt = new Iu();
  dt.setAnimationLoop(Ye),
    typeof window != "undefined" && dt.setContext(window),
    (this.setAnimationLoop = function (C) {
      (oe = C), Se.setAnimationLoop(C), C === null ? dt.stop() : dt.start();
    }),
    Se.addEventListener("sessionstart", ue),
    Se.addEventListener("sessionend", Ct),
    (this.render = function (C, q) {
      if (q !== void 0 && q.isCamera !== !0) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
        return;
      }
      if (y === !0) return;
      C.autoUpdate === !0 && C.updateMatrixWorld(),
        q.parent === null && q.updateMatrixWorld(),
        Se.enabled === !0 &&
          Se.isPresenting === !0 &&
          (Se.cameraAutoUpdate === !0 && Se.updateCamera(q),
          (q = Se.getCamera())),
        C.isScene === !0 && C.onBeforeRender(v, C, q, w),
        (d = T.get(C, m.length)),
        d.init(),
        m.push(d),
        re.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse),
        W.setFromProjectionMatrix(re),
        (Q = this.localClippingEnabled),
        (k = te.init(this.clippingPlanes, Q, q)),
        (u = R.get(C, f.length)),
        u.init(),
        f.push(u),
        hn(C, q, 0, v.sortObjects),
        u.finish(),
        v.sortObjects === !0 && u.sort(A, N),
        k === !0 && te.beginShadows();
      const J = d.state.shadowsArray;
      if (
        (ce.render(J, C, q),
        k === !0 && te.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        _e.render(u, C),
        d.setupLights(v.physicallyCorrectLights),
        q.isArrayCamera)
      ) {
        const $ = q.cameras;
        for (let Y = 0, je = $.length; Y < je; Y++) {
          const Ke = $[Y];
          un(u, C, Ke, Ke.viewport);
        }
      } else un(u, C, q);
      w !== null &&
        (de.updateMultisampleRenderTarget(w), de.updateRenderTargetMipmap(w)),
        C.isScene === !0 && C.onAfterRender(v, C, q),
        fe.resetDefaultState(),
        (b = -1),
        (_ = null),
        m.pop(),
        m.length > 0 ? (d = m[m.length - 1]) : (d = null),
        f.pop(),
        f.length > 0 ? (u = f[f.length - 1]) : (u = null);
    });
  function hn(C, q, J, $) {
    if (C.visible === !1) return;
    if (C.layers.test(q.layers)) {
      if (C.isGroup) J = C.renderOrder;
      else if (C.isLOD) C.autoUpdate === !0 && C.update(q);
      else if (C.isLight) d.pushLight(C), C.castShadow && d.pushShadow(C);
      else if (C.isSprite) {
        if (!C.frustumCulled || W.intersectsSprite(C)) {
          $ && Me.setFromMatrixPosition(C.matrixWorld).applyMatrix4(re);
          const Ke = ze.update(C),
            x = C.material;
          x.visible && u.push(C, Ke, x, J, Me.z, null);
        }
      } else if (
        (C.isMesh || C.isLine || C.isPoints) &&
        (C.isSkinnedMesh &&
          C.skeleton.frame !== Ze.render.frame &&
          (C.skeleton.update(), (C.skeleton.frame = Ze.render.frame)),
        !C.frustumCulled || W.intersectsObject(C))
      ) {
        $ && Me.setFromMatrixPosition(C.matrixWorld).applyMatrix4(re);
        const Ke = ze.update(C),
          x = C.material;
        if (Array.isArray(x)) {
          const S = Ke.groups;
          for (let I = 0, z = S.length; I < z; I++) {
            const j = S[I],
              X = x[j.materialIndex];
            X && X.visible && u.push(C, Ke, X, J, Me.z, j);
          }
        } else x.visible && u.push(C, Ke, x, J, Me.z, null);
      }
    }
    const je = C.children;
    for (let Ke = 0, x = je.length; Ke < x; Ke++) hn(je[Ke], q, J, $);
  }
  function un(C, q, J, $) {
    const Y = C.opaque,
      je = C.transmissive,
      Ke = C.transparent;
    d.setupLightsView(J),
      je.length > 0 && Qo(Y, q, J),
      $ && Ie.viewport(E.copy($)),
      Y.length > 0 && Oi(Y, q, J),
      je.length > 0 && Oi(je, q, J),
      Ke.length > 0 && Oi(Ke, q, J),
      Ie.buffers.depth.setTest(!0),
      Ie.buffers.depth.setMask(!0),
      Ie.buffers.color.setMask(!0),
      Ie.setPolygonOffset(!1);
  }
  function Qo(C, q, J) {
    const $ = Fe.isWebGL2;
    ie === null &&
      (ie = new Bt(1, 1, {
        generateMipmaps: !0,
        type: U.convert(nn) !== null ? nn : mi,
        minFilter: yi,
        samples: $ && r === !0 ? 4 : 0,
      })),
      v.getDrawingBufferSize(ee),
      $ ? ie.setSize(ee.x, ee.y) : ie.setSize(Lo(ee.x), Lo(ee.y));
    const Y = v.getRenderTarget();
    v.setRenderTarget(ie), v.clear();
    const je = v.toneMapping;
    (v.toneMapping = hi),
      Oi(C, q, J),
      (v.toneMapping = je),
      de.updateMultisampleRenderTarget(ie),
      de.updateRenderTargetMipmap(ie),
      v.setRenderTarget(Y);
  }
  function Oi(C, q, J) {
    const $ = q.isScene === !0 ? q.overrideMaterial : null;
    for (let Y = 0, je = C.length; Y < je; Y++) {
      const Ke = C[Y],
        x = Ke.object,
        S = Ke.geometry,
        I = $ === null ? Ke.material : $,
        z = Ke.group;
      x.layers.test(J.layers) && ea(x, q, J, S, I, z);
    }
  }
  function ea(C, q, J, $, Y, je) {
    C.onBeforeRender(v, q, J, $, Y, je),
      C.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, C.matrixWorld),
      C.normalMatrix.getNormalMatrix(C.modelViewMatrix),
      Y.onBeforeRender(v, q, J, $, C, je),
      Y.transparent === !0 && Y.side === Li
        ? ((Y.side = Ut),
          (Y.needsUpdate = !0),
          v.renderBufferDirect(J, q, $, Y, C, je),
          (Y.side = gr),
          (Y.needsUpdate = !0),
          v.renderBufferDirect(J, q, $, Y, C, je),
          (Y.side = Li))
        : v.renderBufferDirect(J, q, $, Y, C, je),
      C.onAfterRender(v, q, J, $, Y, je);
  }
  function jr(C, q, J) {
    q.isScene !== !0 && (q = Be);
    const $ = K.get(C),
      Y = d.state.lights,
      je = d.state.shadowsArray,
      Ke = Y.state.version,
      x = $e.getParameters(C, Y.state, je, q, J),
      S = $e.getProgramCacheKey(x);
    let I = $.programs;
    ($.environment = C.isMeshStandardMaterial ? q.environment : null),
      ($.fog = q.fog),
      ($.envMap = (C.isMeshStandardMaterial ? De : pe).get(
        C.envMap || $.environment
      )),
      I === void 0 &&
        (C.addEventListener("dispose", Te), (I = new Map()), ($.programs = I));
    let z = I.get(S);
    if (z !== void 0) {
      if ($.currentProgram === z && $.lightsStateVersion === Ke)
        return Ns(C, x), z;
    } else
      (x.uniforms = $e.getUniforms(C)),
        C.onBuild(J, x, v),
        C.onBeforeCompile(x, v),
        (z = $e.acquireProgram(x, S)),
        I.set(S, z),
        ($.uniforms = x.uniforms);
    const j = $.uniforms;
    ((!C.isShaderMaterial && !C.isRawShaderMaterial) || C.clipping === !0) &&
      (j.clippingPlanes = te.uniform),
      Ns(C, x),
      ($.needsLights = ia(C)),
      ($.lightsStateVersion = Ke),
      $.needsLights &&
        ((j.ambientLightColor.value = Y.state.ambient),
        (j.lightProbe.value = Y.state.probe),
        (j.directionalLights.value = Y.state.directional),
        (j.directionalLightShadows.value = Y.state.directionalShadow),
        (j.spotLights.value = Y.state.spot),
        (j.spotLightShadows.value = Y.state.spotShadow),
        (j.rectAreaLights.value = Y.state.rectArea),
        (j.ltc_1.value = Y.state.rectAreaLTC1),
        (j.ltc_2.value = Y.state.rectAreaLTC2),
        (j.pointLights.value = Y.state.point),
        (j.pointLightShadows.value = Y.state.pointShadow),
        (j.hemisphereLights.value = Y.state.hemi),
        (j.directionalShadowMap.value = Y.state.directionalShadowMap),
        (j.directionalShadowMatrix.value = Y.state.directionalShadowMatrix),
        (j.spotShadowMap.value = Y.state.spotShadowMap),
        (j.spotShadowMatrix.value = Y.state.spotShadowMatrix),
        (j.pointShadowMap.value = Y.state.pointShadowMap),
        (j.pointShadowMatrix.value = Y.state.pointShadowMatrix));
    const X = z.getUniforms(),
      he = ui.seqWithValue(X.seq, j);
    return ($.currentProgram = z), ($.uniformsList = he), z;
  }
  function Ns(C, q) {
    const J = K.get(C);
    (J.outputEncoding = q.outputEncoding),
      (J.instancing = q.instancing),
      (J.skinning = q.skinning),
      (J.morphTargets = q.morphTargets),
      (J.morphNormals = q.morphNormals),
      (J.morphColors = q.morphColors),
      (J.morphTargetsCount = q.morphTargetsCount),
      (J.numClippingPlanes = q.numClippingPlanes),
      (J.numIntersection = q.numClipIntersection),
      (J.vertexAlphas = q.vertexAlphas),
      (J.vertexTangents = q.vertexTangents),
      (J.toneMapping = q.toneMapping);
  }
  function ta(C, q, J, $, Y) {
    q.isScene !== !0 && (q = Be), de.resetTextureUnits();
    const je = q.fog,
      Ke = $.isMeshStandardMaterial ? q.environment : null,
      x =
        w === null
          ? v.outputEncoding
          : w.isXRRenderTarget === !0
          ? w.texture.encoding
          : an,
      S = ($.isMeshStandardMaterial ? De : pe).get($.envMap || Ke),
      I =
        $.vertexColors === !0 &&
        !!J.attributes.color &&
        J.attributes.color.itemSize === 4,
      z = !!$.normalMap && !!J.attributes.tangent,
      j = !!J.morphAttributes.position,
      X = !!J.morphAttributes.normal,
      he = !!J.morphAttributes.color,
      ge = $.toneMapped ? v.toneMapping : hi,
      xe =
        J.morphAttributes.position ||
        J.morphAttributes.normal ||
        J.morphAttributes.color,
      le = xe !== void 0 ? xe.length : 0,
      se = K.get($),
      Pe = d.state.lights;
    if (k === !0 && (Q === !0 || C !== _)) {
      const yt = C === _ && $.id === b;
      te.setState($, C, yt);
    }
    let we = !1;
    $.version === se.__version
      ? ((se.needsLights && se.lightsStateVersion !== Pe.state.version) ||
          se.outputEncoding !== x ||
          (Y.isInstancedMesh && se.instancing === !1) ||
          (!Y.isInstancedMesh && se.instancing === !0) ||
          (Y.isSkinnedMesh && se.skinning === !1) ||
          (!Y.isSkinnedMesh && se.skinning === !0) ||
          se.envMap !== S ||
          ($.fog && se.fog !== je) ||
          (se.numClippingPlanes !== void 0 &&
            (se.numClippingPlanes !== te.numPlanes ||
              se.numIntersection !== te.numIntersection)) ||
          se.vertexAlphas !== I ||
          se.vertexTangents !== z ||
          se.morphTargets !== j ||
          se.morphNormals !== X ||
          se.morphColors !== he ||
          se.toneMapping !== ge ||
          (Fe.isWebGL2 === !0 && se.morphTargetsCount !== le)) &&
        (we = !0)
      : ((we = !0), (se.__version = $.version));
    let Oe = se.currentProgram;
    we === !0 && (Oe = jr($, q, Y));
    let Xe = !1,
      Ne = !1,
      Ue = !1;
    const Ge = Oe.getUniforms(),
      pt = se.uniforms;
    if (
      (Ie.useProgram(Oe.program) && ((Xe = !0), (Ne = !0), (Ue = !0)),
      $.id !== b && ((b = $.id), (Ne = !0)),
      Xe || _ !== C)
    ) {
      if (
        (Ge.setValue(Z, "projectionMatrix", C.projectionMatrix),
        Fe.logarithmicDepthBuffer &&
          Ge.setValue(Z, "logDepthBufFC", 2 / (Math.log(C.far + 1) / Math.LN2)),
        _ !== C && ((_ = C), (Ne = !0), (Ue = !0)),
        $.isShaderMaterial ||
          $.isMeshPhongMaterial ||
          $.isMeshToonMaterial ||
          $.isMeshStandardMaterial ||
          $.envMap)
      ) {
        const yt = Ge.map.cameraPosition;
        yt !== void 0 &&
          yt.setValue(Z, Me.setFromMatrixPosition(C.matrixWorld));
      }
      ($.isMeshPhongMaterial ||
        $.isMeshToonMaterial ||
        $.isMeshLambertMaterial ||
        $.isMeshBasicMaterial ||
        $.isMeshStandardMaterial ||
        $.isShaderMaterial) &&
        Ge.setValue(Z, "isOrthographic", C.isOrthographicCamera === !0),
        ($.isMeshPhongMaterial ||
          $.isMeshToonMaterial ||
          $.isMeshLambertMaterial ||
          $.isMeshBasicMaterial ||
          $.isMeshStandardMaterial ||
          $.isShaderMaterial ||
          $.isShadowMaterial ||
          Y.isSkinnedMesh) &&
          Ge.setValue(Z, "viewMatrix", C.matrixWorldInverse);
    }
    if (Y.isSkinnedMesh) {
      Ge.setOptional(Z, Y, "bindMatrix"),
        Ge.setOptional(Z, Y, "bindMatrixInverse");
      const yt = Y.skeleton;
      yt &&
        (Fe.floatVertexTextures
          ? (yt.boneTexture === null && yt.computeBoneTexture(),
            Ge.setValue(Z, "boneTexture", yt.boneTexture, de),
            Ge.setValue(Z, "boneTextureSize", yt.boneTextureSize))
          : Ge.setOptional(Z, yt, "boneMatrices"));
    }
    const xt = J.morphAttributes;
    return (
      (xt.position !== void 0 ||
        xt.normal !== void 0 ||
        (xt.color !== void 0 && Fe.isWebGL2 === !0)) &&
        Le.update(Y, J, $, Oe),
      (Ne || se.receiveShadow !== Y.receiveShadow) &&
        ((se.receiveShadow = Y.receiveShadow),
        Ge.setValue(Z, "receiveShadow", Y.receiveShadow)),
      Ne &&
        (Ge.setValue(Z, "toneMappingExposure", v.toneMappingExposure),
        se.needsLights && na(pt, Ue),
        je && $.fog && ut.refreshFogUniforms(pt, je),
        ut.refreshMaterialUniforms(pt, $, M, F, ie),
        ui.upload(Z, se.uniformsList, pt, de)),
      $.isShaderMaterial &&
        $.uniformsNeedUpdate === !0 &&
        (ui.upload(Z, se.uniformsList, pt, de), ($.uniformsNeedUpdate = !1)),
      $.isSpriteMaterial && Ge.setValue(Z, "center", Y.center),
      Ge.setValue(Z, "modelViewMatrix", Y.modelViewMatrix),
      Ge.setValue(Z, "normalMatrix", Y.normalMatrix),
      Ge.setValue(Z, "modelMatrix", Y.matrixWorld),
      Oe
    );
    console.log(modelViewMatrix)
  }
  function na(C, q) {
    (C.ambientLightColor.needsUpdate = q),
      (C.lightProbe.needsUpdate = q),
      (C.directionalLights.needsUpdate = q),
      (C.directionalLightShadows.needsUpdate = q),
      (C.pointLights.needsUpdate = q),
      (C.pointLightShadows.needsUpdate = q),
      (C.spotLights.needsUpdate = q),
      (C.spotLightShadows.needsUpdate = q),
      (C.rectAreaLights.needsUpdate = q),
      (C.hemisphereLights.needsUpdate = q);
  }
  function ia(C) {
    return (
      C.isMeshLambertMaterial ||
      C.isMeshToonMaterial ||
      C.isMeshPhongMaterial ||
      C.isMeshStandardMaterial ||
      C.isShadowMaterial ||
      (C.isShaderMaterial && C.lights === !0)
    );
  }
  (this.getActiveCubeFace = function () {
    return p;
  }),
    (this.getActiveMipmapLevel = function () {
      return g;
    }),
    (this.getRenderTarget = function () {
      return w;
    }),
    (this.setRenderTargetTextures = function (C, q, J) {
      (K.get(C.texture).__webglTexture = q),
        (K.get(C.depthTexture).__webglTexture = J);
      const $ = K.get(C);
      ($.__hasExternalTextures = !0),
        $.__hasExternalTextures &&
          (($.__autoAllocateDepthBuffer = J === void 0),
          $.__autoAllocateDepthBuffer ||
            (ke.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              ($.__useRenderToTexture = !1))));
    }),
    (this.setRenderTargetFramebuffer = function (C, q) {
      const J = K.get(C);
      (J.__webglFramebuffer = q), (J.__useDefaultFramebuffer = q === void 0);
    }),
    (this.setRenderTarget = function (C, q = 0, J = 0) {
      (w = C), (p = q), (g = J);
      let $ = !0;
      if (C) {
        const S = K.get(C);
        S.__useDefaultFramebuffer !== void 0
          ? (Ie.bindFramebuffer(36160, null), ($ = !1))
          : S.__webglFramebuffer === void 0
          ? de.setupRenderTarget(C)
          : S.__hasExternalTextures &&
            de.rebindTextures(
              C,
              K.get(C.texture).__webglTexture,
              K.get(C.depthTexture).__webglTexture
            );
      }
      let Y = null,
        je = !1,
        Ke = !1;
      if (C) {
        const S = C.texture;
        (S.isData3DTexture || S.isDataArrayTexture) && (Ke = !0);
        const I = K.get(C).__webglFramebuffer;
        C.isWebGLCubeRenderTarget
          ? ((Y = I[q]), (je = !0))
          : Fe.isWebGL2 && C.samples > 0 && de.useMultisampledRTT(C) === !1
          ? (Y = K.get(C).__webglMultisampledFramebuffer)
          : (Y = I),
          E.copy(C.viewport),
          L.copy(C.scissor),
          (D = C.scissorTest);
      } else
        E.copy(O).multiplyScalar(M).floor(),
          L.copy(H).multiplyScalar(M).floor(),
          (D = G);
      if (
        (Ie.bindFramebuffer(36160, Y) &&
          Fe.drawBuffers &&
          $ &&
          Ie.drawBuffers(C, Y),
        Ie.viewport(E),
        Ie.scissor(L),
        Ie.setScissorTest(D),
        je)
      ) {
        const S = K.get(C.texture);
        Z.framebufferTexture2D(36160, 36064, 34069 + q, S.__webglTexture, J);
      } else if (Ke) {
        const S = K.get(C.texture),
          I = q || 0;
        Z.framebufferTextureLayer(36160, 36064, S.__webglTexture, J || 0, I);
      }
      b = -1;
    }),
    (this.readRenderTargetPixels = function (C, q, J, $, Y, je, Ke) {
      if (!(C && C.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
        return;
      }
      let x = K.get(C).__webglFramebuffer;
      if ((C.isWebGLCubeRenderTarget && Ke !== void 0 && (x = x[Ke]), x)) {
        Ie.bindFramebuffer(36160, x);
        try {
          const S = C.texture,
            I = S.format,
            z = S.type;
          if (I !== Nt && U.convert(I) !== Z.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            );
            return;
          }
          const j =
            z === nn &&
            (ke.has("EXT_color_buffer_half_float") ||
              (Fe.isWebGL2 && ke.has("EXT_color_buffer_float")));
          if (
            z !== mi &&
            U.convert(z) !== Z.getParameter(35738) &&
            !(
              z === tn &&
              (Fe.isWebGL2 ||
                ke.has("OES_texture_float") ||
                ke.has("WEBGL_color_buffer_float"))
            ) &&
            !j
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
            return;
          }
          Z.checkFramebufferStatus(36160) === 36053
            ? q >= 0 &&
              q <= C.width - $ &&
              J >= 0 &&
              J <= C.height - Y &&
              Z.readPixels(q, J, $, Y, U.convert(I), U.convert(z), je)
            : console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
              );
        } finally {
          const S = w !== null ? K.get(w).__webglFramebuffer : null;
          Ie.bindFramebuffer(36160, S);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (C, q, J = 0) {
      if (q.isFramebufferTexture !== !0) {
        console.error(
          "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
        );
        return;
      }
      const $ = Math.pow(2, -J),
        Y = Math.floor(q.image.width * $),
        je = Math.floor(q.image.height * $);
      de.setTexture2D(q, 0),
        Z.copyTexSubImage2D(3553, J, 0, 0, C.x, C.y, Y, je),
        Ie.unbindTexture();
    }),
    (this.copyTextureToTexture = function (C, q, J, $ = 0) {
      const Y = q.image.width,
        je = q.image.height,
        Ke = U.convert(J.format),
        x = U.convert(J.type);
      de.setTexture2D(J, 0),
        Z.pixelStorei(37440, J.flipY),
        Z.pixelStorei(37441, J.premultiplyAlpha),
        Z.pixelStorei(3317, J.unpackAlignment),
        q.isDataTexture
          ? Z.texSubImage2D(3553, $, C.x, C.y, Y, je, Ke, x, q.image.data)
          : q.isCompressedTexture
          ? Z.compressedTexSubImage2D(
              3553,
              $,
              C.x,
              C.y,
              q.mipmaps[0].width,
              q.mipmaps[0].height,
              Ke,
              q.mipmaps[0].data
            )
          : Z.texSubImage2D(3553, $, C.x, C.y, Ke, x, q.image),
        $ === 0 && J.generateMipmaps && Z.generateMipmap(3553),
        Ie.unbindTexture();
    }),
    (this.copyTextureToTexture3D = function (C, q, J, $, Y = 0) {
      if (v.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
        );
        return;
      }
      const je = C.max.x - C.min.x + 1,
        Ke = C.max.y - C.min.y + 1,
        x = C.max.z - C.min.z + 1,
        S = U.convert($.format),
        I = U.convert($.type);
      let z;
      if ($.isData3DTexture) de.setTexture3D($, 0), (z = 32879);
      else if ($.isDataArrayTexture) de.setTexture2DArray($, 0), (z = 35866);
      else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
        );
        return;
      }
      Z.pixelStorei(37440, $.flipY),
        Z.pixelStorei(37441, $.premultiplyAlpha),
        Z.pixelStorei(3317, $.unpackAlignment);
      const j = Z.getParameter(3314),
        X = Z.getParameter(32878),
        he = Z.getParameter(3316),
        ge = Z.getParameter(3315),
        xe = Z.getParameter(32877),
        le = J.isCompressedTexture ? J.mipmaps[0] : J.image;
      Z.pixelStorei(3314, le.width),
        Z.pixelStorei(32878, le.height),
        Z.pixelStorei(3316, C.min.x),
        Z.pixelStorei(3315, C.min.y),
        Z.pixelStorei(32877, C.min.z),
        J.isDataTexture || J.isData3DTexture
          ? Z.texSubImage3D(z, Y, q.x, q.y, q.z, je, Ke, x, S, I, le.data)
          : J.isCompressedTexture
          ? (console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
            ),
            Z.compressedTexSubImage3D(
              z,
              Y,
              q.x,
              q.y,
              q.z,
              je,
              Ke,
              x,
              S,
              le.data
            ))
          : Z.texSubImage3D(z, Y, q.x, q.y, q.z, je, Ke, x, S, I, le),
        Z.pixelStorei(3314, j),
        Z.pixelStorei(32878, X),
        Z.pixelStorei(3316, he),
        Z.pixelStorei(3315, ge),
        Z.pixelStorei(32877, xe),
        Y === 0 && $.generateMipmaps && Z.generateMipmap(z),
        Ie.unbindTexture();
    }),
    (this.initTexture = function (C) {
      de.setTexture2D(C, 0), Ie.unbindTexture();
    }),
    (this.resetState = function () {
      (p = 0), (g = 0), (w = null), Ie.reset(), fe.reset();
    }),
    typeof __THREE_DEVTOOLS__ != "undefined" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
mt.prototype.isWebGLRenderer = !0;
class lx extends mt {}
lx.prototype.isWebGL1Renderer = !0;
class Vu extends at {
  constructor() {
    super();
    (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.autoUpdate = e.autoUpdate),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
}
Vu.prototype.isScene = !0;
class Pr {
  constructor(e, t) {
    (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = ps),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = gn());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
Pr.prototype.isInterleavedBuffer = !0;
const Rt = new P();
class br {
  constructor(e, t, n, i = !1) {
    (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i === !0);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      (Rt.x = this.getX(t)),
        (Rt.y = this.getY(t)),
        (Rt.z = this.getZ(t)),
        Rt.applyMatrix4(e),
        this.setXYZ(t, Rt.x, Rt.y, Rt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (Rt.x = this.getX(t)),
        (Rt.y = this.getY(t)),
        (Rt.z = this.getZ(t)),
        Rt.applyNormalMatrix(e),
        this.setXYZ(t, Rt.x, Rt.y, Rt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (Rt.x = this.getX(t)),
        (Rt.y = this.getY(t)),
        (Rt.z = this.getZ(t)),
        Rt.transformDirection(e),
        this.setXYZ(t, Rt.x, Rt.y, Rt.z);
    return this;
  }
  setX(e, t) {
    return (this.data.array[e * this.data.stride + this.offset] = t), this;
  }
  setY(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
  }
  setZ(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
  }
  setW(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
  }
  getX(e) {
    return this.data.array[e * this.data.stride + this.offset];
  }
  getY(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  }
  getZ(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  }
  getW(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = r),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
      }
      return new St(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new br(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
br.prototype.isInterleavedBufferAttribute = !0;
class kl extends Et {
  constructor(e) {
    super();
    (this.type = "SpriteMaterial"),
      (this.color = new ye(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      this
    );
  }
}
kl.prototype.isSpriteMaterial = !0;
let er;
const Kr = new P(),
  tr = new P(),
  nr = new P(),
  ir = new ae(),
  Jr = new ae(),
  Wu = new be(),
  io = new P(),
  Qr = new P(),
  ro = new P(),
  vh = new ae(),
  Fa = new ae(),
  xh = new ae();
class cx extends at {
  constructor(e) {
    super();
    if (((this.type = "Sprite"), er === void 0)) {
      er = new tt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new Pr(t, 5);
      er.setIndex([0, 1, 2, 0, 2, 3]),
        er.setAttribute("position", new br(n, 3, 0, !1)),
        er.setAttribute("uv", new br(n, 2, 3, !1));
    }
    (this.geometry = er),
      (this.material = e !== void 0 ? e : new kl()),
      (this.center = new ae(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      tr.setFromMatrixScale(this.matrixWorld),
      Wu.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      nr.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        tr.multiplyScalar(-nr.z);
    const n = this.material.rotation;
    let i, r;
    n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
    const o = this.center;
    so(io.set(-0.5, -0.5, 0), nr, o, tr, i, r),
      so(Qr.set(0.5, -0.5, 0), nr, o, tr, i, r),
      so(ro.set(0.5, 0.5, 0), nr, o, tr, i, r),
      vh.set(0, 0),
      Fa.set(1, 0),
      xh.set(1, 1);
    let a = e.ray.intersectTriangle(io, Qr, ro, !1, Kr);
    if (
      a === null &&
      (so(Qr.set(-0.5, 0.5, 0), nr, o, tr, i, r),
      Fa.set(0, 1),
      (a = e.ray.intersectTriangle(io, ro, Qr, !1, Kr)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(Kr);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: Kr.clone(),
        uv: Ft.getUV(Kr, io, Qr, ro, vh, Fa, xh, new ae()),
        face: null,
        object: this,
      });
  }
  copy(e) {
    return (
      super.copy(e),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
cx.prototype.isSprite = !0;
function so(s, e, t, n, i, r) {
  ir.subVectors(s, t).addScalar(0.5).multiply(n),
    i !== void 0
      ? ((Jr.x = r * ir.x - i * ir.y), (Jr.y = i * ir.x + r * ir.y))
      : Jr.copy(ir),
    s.copy(e),
    (s.x += Jr.x),
    (s.y += Jr.y),
    s.applyMatrix4(Wu);
}
const yh = new P(),
  _h = new ct(),
  wh = new ct(),
  hx = new P(),
  bh = new be();
class qo extends jt {
  constructor(e, t) {
    super(e, t);
    (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new be()),
      (this.bindMatrixInverse = new be());
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new ct(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      (e.x = t.getX(n)),
        (e.y = t.getY(n)),
        (e.z = t.getZ(n)),
        (e.w = t.getW(n));
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  boneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    _h.fromBufferAttribute(i.attributes.skinIndex, e),
      wh.fromBufferAttribute(i.attributes.skinWeight, e),
      yh.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const o = wh.getComponent(r);
      if (o !== 0) {
        const a = _h.getComponent(r);
        bh.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
          t.addScaledVector(hx.copy(yh).applyMatrix4(bh), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
qo.prototype.isSkinnedMesh = !0;
class xs extends at {
  constructor() {
    super();
    this.type = "Bone";
  }
}
xs.prototype.isBone = !0;
class Hl extends At {
  constructor(e = null, t = 1, n = 1, i, r, o, a, l, c = zt, h = zt, u, d) {
    super(null, o, a, l, c, h, i, r, u, d);
    (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
Hl.prototype.isDataTexture = !0;
const Mh = new be(),
  ux = new be();
class Yo {
  constructor(e = [], t = []) {
    (this.uuid = gn()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new be());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new be();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r] ? e[r].matrixWorld : ux;
      Mh.multiplyMatrices(a, t[r]), Mh.toArray(n, r * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Yo(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Tu(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Hl(t, e, e, Nt, tn);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const r = e.bones[n];
      let o = t[r];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", r),
        (o = new xs())),
        this.bones.push(o),
        this.boneInverses.push(new be().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const a = n[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class ul extends St {
  constructor(e, t, n, i = 1) {
    typeof n == "number" &&
      ((i = n),
      (n = !1),
      console.error(
        "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
      ));
    super(e, t, n);
    this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
ul.prototype.isInstancedBufferAttribute = !0;
const Sh = new be(),
  Th = new be(),
  oo = [],
  es = new jt();
class dx extends jt {
  constructor(e, t, n) {
    super(e, t);
    (this.instanceMatrix = new ul(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.frustumCulled = !1);
  }
  copy(e) {
    return (
      super.copy(e),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((es.geometry = this.geometry),
      (es.material = this.material),
      es.material !== void 0)
    )
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Sh),
          Th.multiplyMatrices(n, Sh),
          (es.matrixWorld = Th),
          es.raycast(e, oo);
        for (let o = 0, a = oo.length; o < a; o++) {
          const l = oo[o];
          (l.instanceId = r), (l.object = this), t.push(l);
        }
        oo.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new ul(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
dx.prototype.isInstancedMesh = !0;
class Nn extends Et {
  constructor(e) {
    super();
    (this.type = "LineBasicMaterial"),
      (this.color = new ye(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      this
    );
  }
}
Nn.prototype.isLineBasicMaterial = !0;
const Eh = new P(),
  Ah = new P(),
  Ch = new be(),
  Na = new Rr(),
  ao = new Fi();
class Rs extends at {
  constructor(e = new tt(), t = new Nn()) {
    super();
    (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        const t = e.attributes.position,
          n = [0];
        for (let i = 1, r = t.count; i < r; i++)
          Eh.fromBufferAttribute(t, i - 1),
            Ah.fromBufferAttribute(t, i),
            (n[i] = n[i - 1]),
            (n[i] += Eh.distanceTo(Ah));
        e.setAttribute("lineDistance", new Je(n, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else
      e.isGeometry &&
        console.error(
          "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Line.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      ao.copy(n.boundingSphere),
      ao.applyMatrix4(i),
      (ao.radius += r),
      e.ray.intersectsSphere(ao) === !1)
    )
      return;
    Ch.copy(i).invert(), Na.copy(e.ray).applyMatrix4(Ch);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = new P(),
      h = new P(),
      u = new P(),
      d = new P(),
      f = this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const m = n.index,
        y = n.attributes.position;
      if (m !== null) {
        const p = Math.max(0, o.start),
          g = Math.min(m.count, o.start + o.count);
        for (let w = p, b = g - 1; w < b; w += f) {
          const _ = m.getX(w),
            E = m.getX(w + 1);
          if (
            (c.fromBufferAttribute(y, _),
            h.fromBufferAttribute(y, E),
            Na.distanceSqToSegment(c, h, d, u) > l)
          )
            continue;
          d.applyMatrix4(this.matrixWorld);
          const D = e.ray.origin.distanceTo(d);
          D < e.near ||
            D > e.far ||
            t.push({
              distance: D,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: w,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        const p = Math.max(0, o.start),
          g = Math.min(y.count, o.start + o.count);
        for (let w = p, b = g - 1; w < b; w += f) {
          if (
            (c.fromBufferAttribute(y, w),
            h.fromBufferAttribute(y, w + 1),
            Na.distanceSqToSegment(c, h, d, u) > l)
          )
            continue;
          d.applyMatrix4(this.matrixWorld);
          const E = e.ray.origin.distanceTo(d);
          E < e.near ||
            E > e.far ||
            t.push({
              distance: E,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: w,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    } else
      n.isGeometry &&
        console.error(
          "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = r);
          }
        }
      }
    } else {
      const t = e.morphTargets;
      t !== void 0 &&
        t.length > 0 &&
        console.error(
          "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  }
}
Rs.prototype.isLine = !0;
const Rh = new P(),
  Lh = new P();
class Ir extends Rs {
  constructor(e, t) {
    super(e, t);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        const t = e.attributes.position,
          n = [];
        for (let i = 0, r = t.count; i < r; i += 2)
          Rh.fromBufferAttribute(t, i),
            Lh.fromBufferAttribute(t, i + 1),
            (n[i] = i === 0 ? 0 : n[i - 1]),
            (n[i + 1] = n[i] + Rh.distanceTo(Lh));
        e.setAttribute("lineDistance", new Je(n, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else
      e.isGeometry &&
        console.error(
          "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    return this;
  }
}
Ir.prototype.isLineSegments = !0;
class Xu extends Rs {
  constructor(e, t) {
    super(e, t);
    this.type = "LineLoop";
  }
}
Xu.prototype.isLineLoop = !0;
class Zo extends Et {
  constructor(e) {
    super();
    (this.type = "PointsMaterial"),
      (this.color = new ye(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      this
    );
  }
}
Zo.prototype.isPointsMaterial = !0;
const Ph = new be(),
  dl = new Rr(),
  lo = new Fi(),
  co = new P();
class ju extends at {
  constructor(e = new tt(), t = new Zo()) {
    super();
    (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Points.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      lo.copy(n.boundingSphere),
      lo.applyMatrix4(i),
      (lo.radius += r),
      e.ray.intersectsSphere(lo) === !1)
    )
      return;
    Ph.copy(i).invert(), dl.copy(e.ray).applyMatrix4(Ph);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a;
    if (n.isBufferGeometry) {
      const c = n.index,
        u = n.attributes.position;
      if (c !== null) {
        const d = Math.max(0, o.start),
          f = Math.min(c.count, o.start + o.count);
        for (let m = d, v = f; m < v; m++) {
          const y = c.getX(m);
          co.fromBufferAttribute(u, y), Ih(co, y, l, i, e, t, this);
        }
      } else {
        const d = Math.max(0, o.start),
          f = Math.min(u.count, o.start + o.count);
        for (let m = d, v = f; m < v; m++)
          co.fromBufferAttribute(u, m), Ih(co, m, l, i, e, t, this);
      }
    } else
      console.error(
        "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
      );
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = r);
          }
        }
      }
    } else {
      const t = e.morphTargets;
      t !== void 0 &&
        t.length > 0 &&
        console.error(
          "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  }
}
ju.prototype.isPoints = !0;
function Ih(s, e, t, n, i, r, o) {
  const a = dl.distanceSqToPoint(s);
  if (a < t) {
    const l = new P();
    dl.closestPointToPoint(s, l), l.applyMatrix4(n);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class fx extends At {
  constructor(e, t, n, i, r, o, a, l, c) {
    super(e, t, n, i, r, o, a, l, c);
    (this.minFilter = o !== void 0 ? o : st),
      (this.magFilter = r !== void 0 ? r : st),
      (this.generateMipmaps = !1);
    const h = this;
    function u() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
fx.prototype.isVideoTexture = !0;
class px extends At {
  constructor(e, t, n) {
    super({ width: e, height: t });
    (this.format = n),
      (this.magFilter = zt),
      (this.minFilter = zt),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
px.prototype.isFramebufferTexture = !0;
class fl extends At {
  constructor(e, t, n, i, r, o, a, l, c, h, u, d) {
    super(null, o, a, l, c, h, i, r, u, d);
    (this.image = { width: t, height: n }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
fl.prototype.isCompressedTexture = !0;
class mx extends At {
  constructor(e, t, n, i, r, o, a, l, c) {
    super(e, t, n, i, r, o, a, l, c);
    this.needsUpdate = !0;
  }
}
mx.prototype.isCanvasTexture = !0;
class qu extends tt {
  constructor(e = 1, t = 8, n = 0, i = Math.PI * 2) {
    super();
    (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const r = [],
      o = [],
      a = [],
      l = [],
      c = new P(),
      h = new ae();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const f = n + (u / t) * i;
      (c.x = e * Math.cos(f)),
        (c.y = e * Math.sin(f)),
        o.push(c.x, c.y, c.z),
        a.push(0, 0, 1),
        (h.x = (o[d] / e + 1) / 2),
        (h.y = (o[d + 1] / e + 1) / 2),
        l.push(h.x, h.y);
    }
    for (let u = 1; u <= t; u++) r.push(u, u + 1, 0);
    this.setIndex(r),
      this.setAttribute("position", new Je(o, 3)),
      this.setAttribute("normal", new Je(a, 3)),
      this.setAttribute("uv", new Je(l, 2));
  }
  static fromJSON(e) {
    return new qu(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Gl extends tt {
  constructor(
    e = 1,
    t = 1,
    n = 1,
    i = 8,
    r = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super();
    (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: i,
        heightSegments: r,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const c = this;
    (i = Math.floor(i)), (r = Math.floor(r));
    const h = [],
      u = [],
      d = [],
      f = [];
    let m = 0;
    const v = [],
      y = n / 2;
    let p = 0;
    g(),
      o === !1 && (e > 0 && w(!0), t > 0 && w(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Je(u, 3)),
      this.setAttribute("normal", new Je(d, 3)),
      this.setAttribute("uv", new Je(f, 2));
    function g() {
      const b = new P(),
        _ = new P();
      let E = 0;
      const L = (t - e) / n;
      for (let D = 0; D <= r; D++) {
        const V = [],
          F = D / r,
          M = F * (t - e) + e;
        for (let A = 0; A <= i; A++) {
          const N = A / i,
            O = N * l + a,
            H = Math.sin(O),
            G = Math.cos(O);
          (_.x = M * H),
            (_.y = -F * n + y),
            (_.z = M * G),
            u.push(_.x, _.y, _.z),
            b.set(H, L, G).normalize(),
            d.push(b.x, b.y, b.z),
            f.push(N, 1 - F),
            V.push(m++);
        }
        v.push(V);
      }
      for (let D = 0; D < i; D++)
        for (let V = 0; V < r; V++) {
          const F = v[V][D],
            M = v[V + 1][D],
            A = v[V + 1][D + 1],
            N = v[V][D + 1];
          h.push(F, M, N), h.push(M, A, N), (E += 6);
        }
      c.addGroup(p, E, 0), (p += E);
    }
    function w(b) {
      const _ = m,
        E = new ae(),
        L = new P();
      let D = 0;
      const V = b === !0 ? e : t,
        F = b === !0 ? 1 : -1;
      for (let A = 1; A <= i; A++)
        u.push(0, y * F, 0), d.push(0, F, 0), f.push(0.5, 0.5), m++;
      const M = m;
      for (let A = 0; A <= i; A++) {
        const O = (A / i) * l + a,
          H = Math.cos(O),
          G = Math.sin(O);
        (L.x = V * G),
          (L.y = y * F),
          (L.z = V * H),
          u.push(L.x, L.y, L.z),
          d.push(0, F, 0),
          (E.x = H * 0.5 + 0.5),
          (E.y = G * 0.5 * F + 0.5),
          f.push(E.x, E.y),
          m++;
      }
      for (let A = 0; A < i; A++) {
        const N = _ + A,
          O = M + A;
        b === !0 ? h.push(O, O + 1, N) : h.push(O + 1, O, N), (D += 3);
      }
      c.addGroup(p, D, b === !0 ? 1 : 2), (p += D);
    }
  }
  static fromJSON(e) {
    return new Gl(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Yu extends Gl {
  constructor(e = 1, t = 1, n = 8, i = 1, r = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, n, i, r, o, a);
    (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: i,
        openEnded: r,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new Yu(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
new P();
new P();
new P();
new Ft();
class ln {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n,
      i = this.getPoint(0),
      r = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (n = this.getPoint(o / e)), (r += n.distanceTo(i)), t.push(r), (i = n);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const r = n.length;
    let o;
    t ? (o = t) : (o = e * n[r - 1]);
    let a = 0,
      l = r - 1,
      c;
    for (; a <= l; )
      if (((i = Math.floor(a + (l - a) / 2)), (c = n[i] - o), c < 0)) a = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), n[i] === o)) return i / (r - 1);
    const h = n[i],
      d = n[i + 1] - h,
      f = (o - h) / d;
    return (i + f) / (r - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      r = e + 1e-4;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const o = this.getPoint(i),
      a = this.getPoint(r),
      l = t || (o.isVector2 ? new ae() : new P());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new P(),
      i = [],
      r = [],
      o = [],
      a = new P(),
      l = new be();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      i[f] = this.getTangentAt(m, new P());
    }
    (r[0] = new P()), (o[0] = new P());
    let c = Number.MAX_VALUE;
    const h = Math.abs(i[0].x),
      u = Math.abs(i[0].y),
      d = Math.abs(i[0].z);
    h <= c && ((c = h), n.set(1, 0, 0)),
      u <= c && ((c = u), n.set(0, 1, 0)),
      d <= c && n.set(0, 0, 1),
      a.crossVectors(i[0], n).normalize(),
      r[0].crossVectors(i[0], a),
      o[0].crossVectors(i[0], r[0]);
    for (let f = 1; f <= e; f++) {
      if (
        ((r[f] = r[f - 1].clone()),
        (o[f] = o[f - 1].clone()),
        a.crossVectors(i[f - 1], i[f]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const m = Math.acos(Kt(i[f - 1].dot(i[f]), -1, 1));
        r[f].applyMatrix4(l.makeRotationAxis(a, m));
      }
      o[f].crossVectors(i[f], r[f]);
    }
    if (t === !0) {
      let f = Math.acos(Kt(r[0].dot(r[e]), -1, 1));
      (f /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        r[m].applyMatrix4(l.makeRotationAxis(i[m], f * m)),
          o[m].crossVectors(i[m], r[m]);
    }
    return { tangents: i, normals: r, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class $o extends ln {
  constructor(
    e = 0,
    t = 0,
    n = 1,
    i = 1,
    r = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super();
    (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = r),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, t) {
    const n = t || new ae(),
      i = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += i;
    for (; r > i; ) r -= i;
    r < Number.EPSILON && (o ? (r = 0) : (r = i)),
      this.aClockwise === !0 && !o && (r === i ? (r = -i) : (r = r - i));
    const a = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(a),
      c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        u = Math.sin(this.aRotation),
        d = l - this.aX,
        f = c - this.aY;
      (l = d * h - f * u + this.aX), (c = d * u + f * h + this.aY);
    }
    return n.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
$o.prototype.isEllipseCurve = !0;
class Zu extends $o {
  constructor(e, t, n, i, r, o) {
    super(e, t, n, n, i, r, o);
    this.type = "ArcCurve";
  }
}
Zu.prototype.isArcCurve = !0;
function Vl() {
  let s = 0,
    e = 0,
    t = 0,
    n = 0;
  function i(r, o, a, l) {
    (s = r),
      (e = a),
      (t = -3 * r + 3 * o - 2 * a - l),
      (n = 2 * r - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (r, o, a, l, c) {
      i(o, a, c * (a - r), c * (l - o));
    },
    initNonuniformCatmullRom: function (r, o, a, l, c, h, u) {
      let d = (o - r) / c - (a - r) / (c + h) + (a - o) / h,
        f = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
      (d *= h), (f *= h), i(o, a, d, f);
    },
    calc: function (r) {
      const o = r * r,
        a = o * r;
      return s + e * r + t * o + n * a;
    },
  };
}
const ho = new P(),
  Ba = new Vl(),
  Oa = new Vl(),
  Ua = new Vl();
class $u extends ln {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super();
    (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = i);
  }
  getPoint(e, t = new P()) {
    const n = t,
      i = this.points,
      r = i.length,
      o = (r - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r)
      : l === 0 && a === r - 1 && ((a = r - 2), (l = 1));
    let c, h;
    this.closed || a > 0
      ? (c = i[(a - 1) % r])
      : (ho.subVectors(i[0], i[1]).add(i[0]), (c = ho));
    const u = i[a % r],
      d = i[(a + 1) % r];
    if (
      (this.closed || a + 2 < r
        ? (h = i[(a + 2) % r])
        : (ho.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (h = ho)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(u), f),
        v = Math.pow(u.distanceToSquared(d), f),
        y = Math.pow(d.distanceToSquared(h), f);
      v < 1e-4 && (v = 1),
        m < 1e-4 && (m = v),
        y < 1e-4 && (y = v),
        Ba.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, v, y),
        Oa.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, v, y),
        Ua.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, v, y);
    } else
      this.curveType === "catmullrom" &&
        (Ba.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
        Oa.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
        Ua.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
    return n.set(Ba.calc(l), Oa.calc(l), Ua.calc(l)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new P().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
$u.prototype.isCatmullRomCurve3 = !0;
function Dh(s, e, t, n, i) {
  const r = (n - e) * 0.5,
    o = (i - t) * 0.5,
    a = s * s,
    l = s * a;
  return (
    (2 * t - 2 * n + r + o) * l + (-3 * t + 3 * n - 2 * r - o) * a + r * s + t
  );
}
function gx(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function vx(s, e) {
  return 2 * (1 - s) * s * e;
}
function xx(s, e) {
  return s * s * e;
}
function ls(s, e, t, n) {
  return gx(s, e) + vx(s, t) + xx(s, n);
}
function yx(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function _x(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function wx(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function bx(s, e) {
  return s * s * s * e;
}
function cs(s, e, t, n, i) {
  return yx(s, e) + _x(s, t) + wx(s, n) + bx(s, i);
}
class Wl extends ln {
  constructor(e = new ae(), t = new ae(), n = new ae(), i = new ae()) {
    super();
    (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new ae()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      o = this.v2,
      a = this.v3;
    return n.set(cs(e, i.x, r.x, o.x, a.x), cs(e, i.y, r.y, o.y, a.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
Wl.prototype.isCubicBezierCurve = !0;
class Ku extends ln {
  constructor(e = new P(), t = new P(), n = new P(), i = new P()) {
    super();
    (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new P()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      n.set(
        cs(e, i.x, r.x, o.x, a.x),
        cs(e, i.y, r.y, o.y, a.y),
        cs(e, i.z, r.z, o.z, a.z)
      ),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
Ku.prototype.isCubicBezierCurve3 = !0;
class Ko extends ln {
  constructor(e = new ae(), t = new ae()) {
    super();
    (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
  }
  getPoint(e, t = new ae()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const n = t || new ae();
    return n.copy(this.v2).sub(this.v1).normalize(), n;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
Ko.prototype.isLineCurve = !0;
class Mx extends ln {
  constructor(e = new P(), t = new P()) {
    super();
    (this.type = "LineCurve3"),
      (this.isLineCurve3 = !0),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new P()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class Xl extends ln {
  constructor(e = new ae(), t = new ae(), n = new ae()) {
    super();
    (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new ae()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      o = this.v2;
    return n.set(ls(e, i.x, r.x, o.x), ls(e, i.y, r.y, o.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
Xl.prototype.isQuadraticBezierCurve = !0;
class Ju extends ln {
  constructor(e = new P(), t = new P(), n = new P()) {
    super();
    (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new P()) {
    const n = t,
      i = this.v0,
      r = this.v1,
      o = this.v2;
    return (
      n.set(ls(e, i.x, r.x, o.x), ls(e, i.y, r.y, o.y), ls(e, i.z, r.z, o.z)), n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
Ju.prototype.isQuadraticBezierCurve3 = !0;
class jl extends ln {
  constructor(e = []) {
    super();
    (this.type = "SplineCurve"), (this.points = e);
  }
  getPoint(e, t = new ae()) {
    const n = t,
      i = this.points,
      r = (i.length - 1) * e,
      o = Math.floor(r),
      a = r - o,
      l = i[o === 0 ? o : o - 1],
      c = i[o],
      h = i[o > i.length - 2 ? i.length - 1 : o + 1],
      u = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return n.set(Dh(a, l.x, c.x, h.x, u.x), Dh(a, l.y, c.y, h.y, u.y)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new ae().fromArray(i));
    }
    return this;
  }
}
jl.prototype.isSplineCurve = !0;
var Qu = Object.freeze({
  __proto__: null,
  ArcCurve: Zu,
  CatmullRomCurve3: $u,
  CubicBezierCurve: Wl,
  CubicBezierCurve3: Ku,
  EllipseCurve: $o,
  LineCurve: Ko,
  LineCurve3: Mx,
  QuadraticBezierCurve: Xl,
  QuadraticBezierCurve3: Ju,
  SplineCurve: jl,
});
class Sx extends ln {
  constructor() {
    super();
    (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new Ko(t, e));
  }
  getPoint(e, t) {
    const n = e * this.getLength(),
      i = this.getCurveLengths();
    let r = 0;
    for (; r < i.length; ) {
      if (i[r] >= n) {
        const o = i[r] - n,
          a = this.curves[r],
          l = a.getLength(),
          c = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(c, t);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (t += this.curves[n].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const o = r[i],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        (n && n.equals(h)) || (t.push(h), (n = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new Qu[i.type]().fromJSON(i));
    }
    return this;
  }
}
class pl extends Sx {
  constructor(e) {
    super();
    (this.type = "Path"),
      (this.currentPoint = new ae()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new Ko(this.currentPoint.clone(), new ae(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const r = new Xl(this.currentPoint.clone(), new ae(e, t), new ae(n, i));
    return this.curves.push(r), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, o) {
    const a = new Wl(
      this.currentPoint.clone(),
      new ae(e, t),
      new ae(n, i),
      new ae(r, o)
    );
    return this.curves.push(a), this.currentPoint.set(r, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      n = new jl(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, r, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, t + l, n, i, r, o), this;
  }
  absarc(e, t, n, i, r, o) {
    return this.absellipse(e, t, n, n, i, r, o), this;
  }
  ellipse(e, t, n, i, r, o, a, l) {
    const c = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, n, i, r, o, a, l), this;
  }
  absellipse(e, t, n, i, r, o, a, l) {
    const c = new $o(e, t, n, i, r, o, a, l);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Ls extends pl {
  constructor(e) {
    super(e);
    (this.uuid = gn()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new pl().fromJSON(i));
    }
    return this;
  }
}
const Tx = {
  triangulate: function (s, e, t = 2) {
    const n = e && e.length,
      i = n ? e[0] * t : s.length;
    let r = ed(s, 0, i, t, !0);
    const o = [];
    if (!r || r.next === r.prev) return o;
    let a, l, c, h, u, d, f;
    if ((n && (r = Lx(s, e, r, t)), s.length > 80 * t)) {
      (a = c = s[0]), (l = h = s[1]);
      for (let m = t; m < i; m += t)
        (u = s[m]),
          (d = s[m + 1]),
          u < a && (a = u),
          d < l && (l = d),
          u > c && (c = u),
          d > h && (h = d);
      (f = Math.max(c - a, h - l)), (f = f !== 0 ? 1 / f : 0);
    }
    return ys(r, o, t, a, l, f), o;
  },
};
function ed(s, e, t, n, i) {
  let r, o;
  if (i === Hx(s, e, t, n) > 0)
    for (r = e; r < t; r += n) o = Fh(r, s[r], s[r + 1], o);
  else for (r = t - n; r >= e; r -= n) o = Fh(r, s[r], s[r + 1], o);
  return o && Jo(o, o.next) && (ws(o), (o = o.next)), o;
}
function gi(s, e) {
  if (!s) return s;
  e || (e = s);
  let t = s,
    n;
  do
    if (
      ((n = !1), !t.steiner && (Jo(t, t.next) || Mt(t.prev, t, t.next) === 0))
    ) {
      if ((ws(t), (t = e = t.prev), t === t.next)) break;
      n = !0;
    } else t = t.next;
  while (n || t !== e);
  return e;
}
function ys(s, e, t, n, i, r, o) {
  if (!s) return;
  !o && r && Nx(s, n, i, r);
  let a = s,
    l,
    c;
  for (; s.prev !== s.next; ) {
    if (((l = s.prev), (c = s.next), r ? Ax(s, n, i, r) : Ex(s))) {
      e.push(l.i / t),
        e.push(s.i / t),
        e.push(c.i / t),
        ws(s),
        (s = c.next),
        (a = c.next);
      continue;
    }
    if (((s = c), s === a)) {
      o
        ? o === 1
          ? ((s = Cx(gi(s), e, t)), ys(s, e, t, n, i, r, 2))
          : o === 2 && Rx(s, e, t, n, i, r)
        : ys(gi(s), e, t, n, i, r, 1);
      break;
    }
  }
}
function Ex(s) {
  const e = s.prev,
    t = s,
    n = s.next;
  if (Mt(e, t, n) >= 0) return !1;
  let i = s.next.next;
  for (; i !== s.prev; ) {
    if (
      ur(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
      Mt(i.prev, i, i.next) >= 0
    )
      return !1;
    i = i.next;
  }
  return !0;
}
function Ax(s, e, t, n) {
  const i = s.prev,
    r = s,
    o = s.next;
  if (Mt(i, r, o) >= 0) return !1;
  const a = i.x < r.x ? (i.x < o.x ? i.x : o.x) : r.x < o.x ? r.x : o.x,
    l = i.y < r.y ? (i.y < o.y ? i.y : o.y) : r.y < o.y ? r.y : o.y,
    c = i.x > r.x ? (i.x > o.x ? i.x : o.x) : r.x > o.x ? r.x : o.x,
    h = i.y > r.y ? (i.y > o.y ? i.y : o.y) : r.y > o.y ? r.y : o.y,
    u = ml(a, l, e, t, n),
    d = ml(c, h, e, t, n);
  let f = s.prevZ,
    m = s.nextZ;
  for (; f && f.z >= u && m && m.z <= d; ) {
    if (
      (f !== s.prev &&
        f !== s.next &&
        ur(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
        Mt(f.prev, f, f.next) >= 0) ||
      ((f = f.prevZ),
      m !== s.prev &&
        m !== s.next &&
        ur(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
        Mt(m.prev, m, m.next) >= 0)
    )
      return !1;
    m = m.nextZ;
  }
  for (; f && f.z >= u; ) {
    if (
      f !== s.prev &&
      f !== s.next &&
      ur(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
      Mt(f.prev, f, f.next) >= 0
    )
      return !1;
    f = f.prevZ;
  }
  for (; m && m.z <= d; ) {
    if (
      m !== s.prev &&
      m !== s.next &&
      ur(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
      Mt(m.prev, m, m.next) >= 0
    )
      return !1;
    m = m.nextZ;
  }
  return !0;
}
function Cx(s, e, t) {
  let n = s;
  do {
    const i = n.prev,
      r = n.next.next;
    !Jo(i, r) &&
      td(i, n, n.next, r) &&
      _s(i, r) &&
      _s(r, i) &&
      (e.push(i.i / t),
      e.push(n.i / t),
      e.push(r.i / t),
      ws(n),
      ws(n.next),
      (n = s = r)),
      (n = n.next);
  } while (n !== s);
  return gi(n);
}
function Rx(s, e, t, n, i, r) {
  let o = s;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && Ux(o, a)) {
        let l = nd(o, a);
        (o = gi(o, o.next)),
          (l = gi(l, l.next)),
          ys(o, e, t, n, i, r),
          ys(l, e, t, n, i, r);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== s);
}
function Lx(s, e, t, n) {
  const i = [];
  let r, o, a, l, c;
  for (r = 0, o = e.length; r < o; r++)
    (a = e[r] * n),
      (l = r < o - 1 ? e[r + 1] * n : s.length),
      (c = ed(s, a, l, n, !1)),
      c === c.next && (c.steiner = !0),
      i.push(Ox(c));
  for (i.sort(Px), r = 0; r < i.length; r++) Ix(i[r], t), (t = gi(t, t.next));
  return t;
}
function Px(s, e) {
  return s.x - e.x;
}
function Ix(s, e) {
  if (((e = Dx(s, e)), e)) {
    const t = nd(e, s);
    gi(e, e.next), gi(t, t.next);
  }
}
function Dx(s, e) {
  let t = e;
  const n = s.x,
    i = s.y;
  let r = -1 / 0,
    o;
  do {
    if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
      const d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (d <= n && d > r) {
        if (((r = d), d === n)) {
          if (i === t.y) return t;
          if (i === t.next.y) return t.next;
        }
        o = t.x < t.next.x ? t : t.next;
      }
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  if (n === r) return o;
  const a = o,
    l = o.x,
    c = o.y;
  let h = 1 / 0,
    u;
  t = o;
  do
    n >= t.x &&
      t.x >= l &&
      n !== t.x &&
      ur(i < c ? n : r, i, l, c, i < c ? r : n, i, t.x, t.y) &&
      ((u = Math.abs(i - t.y) / (n - t.x)),
      _s(t, s) &&
        (u < h || (u === h && (t.x > o.x || (t.x === o.x && Fx(o, t))))) &&
        ((o = t), (h = u))),
      (t = t.next);
  while (t !== a);
  return o;
}
function Fx(s, e) {
  return Mt(s.prev, s, e.prev) < 0 && Mt(e.next, s, s.next) < 0;
}
function Nx(s, e, t, n) {
  let i = s;
  do
    i.z === null && (i.z = ml(i.x, i.y, e, t, n)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== s);
  (i.prevZ.nextZ = null), (i.prevZ = null), Bx(i);
}
function Bx(s) {
  let e,
    t,
    n,
    i,
    r,
    o,
    a,
    l,
    c = 1;
  do {
    for (t = s, s = null, r = null, o = 0; t; ) {
      for (o++, n = t, a = 0, e = 0; e < c && (a++, (n = n.nextZ), !!n); e++);
      for (l = c; a > 0 || (l > 0 && n); )
        a !== 0 && (l === 0 || !n || t.z <= n.z)
          ? ((i = t), (t = t.nextZ), a--)
          : ((i = n), (n = n.nextZ), l--),
          r ? (r.nextZ = i) : (s = i),
          (i.prevZ = r),
          (r = i);
      t = n;
    }
    (r.nextZ = null), (c *= 2);
  } while (o > 1);
  return s;
}
function ml(s, e, t, n, i) {
  return (
    (s = 32767 * (s - t) * i),
    (e = 32767 * (e - n) * i),
    (s = (s | (s << 8)) & 16711935),
    (s = (s | (s << 4)) & 252645135),
    (s = (s | (s << 2)) & 858993459),
    (s = (s | (s << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    s | (e << 1)
  );
}
function Ox(s) {
  let e = s,
    t = s;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== s);
  return t;
}
function ur(s, e, t, n, i, r, o, a) {
  return (
    (i - o) * (e - a) - (s - o) * (r - a) >= 0 &&
    (s - o) * (n - a) - (t - o) * (e - a) >= 0 &&
    (t - o) * (r - a) - (i - o) * (n - a) >= 0
  );
}
function Ux(s, e) {
  return (
    s.next.i !== e.i &&
    s.prev.i !== e.i &&
    !zx(s, e) &&
    ((_s(s, e) &&
      _s(e, s) &&
      kx(s, e) &&
      (Mt(s.prev, s, e.prev) || Mt(s, e.prev, e))) ||
      (Jo(s, e) && Mt(s.prev, s, s.next) > 0 && Mt(e.prev, e, e.next) > 0))
  );
}
function Mt(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function Jo(s, e) {
  return s.x === e.x && s.y === e.y;
}
function td(s, e, t, n) {
  const i = fo(Mt(s, e, t)),
    r = fo(Mt(s, e, n)),
    o = fo(Mt(t, n, s)),
    a = fo(Mt(t, n, e));
  return !!(
    (i !== r && o !== a) ||
    (i === 0 && uo(s, t, e)) ||
    (r === 0 && uo(s, n, e)) ||
    (o === 0 && uo(t, s, n)) ||
    (a === 0 && uo(t, e, n))
  );
}
function uo(s, e, t) {
  return (
    e.x <= Math.max(s.x, t.x) &&
    e.x >= Math.min(s.x, t.x) &&
    e.y <= Math.max(s.y, t.y) &&
    e.y >= Math.min(s.y, t.y)
  );
}
function fo(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function zx(s, e) {
  let t = s;
  do {
    if (
      t.i !== s.i &&
      t.next.i !== s.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      td(t, t.next, s, e)
    )
      return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function _s(s, e) {
  return Mt(s.prev, s, s.next) < 0
    ? Mt(s, e, s.next) >= 0 && Mt(s, s.prev, e) >= 0
    : Mt(s, e, s.prev) < 0 || Mt(s, s.next, e) < 0;
}
function kx(s, e) {
  let t = s,
    n = !1;
  const i = (s.x + e.x) / 2,
    r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x &&
      (n = !n),
      (t = t.next);
  while (t !== s);
  return n;
}
function nd(s, e) {
  const t = new gl(s.i, s.x, s.y),
    n = new gl(e.i, e.x, e.y),
    i = s.next,
    r = e.prev;
  return (
    (s.next = e),
    (e.prev = s),
    (t.next = i),
    (i.prev = t),
    (n.next = t),
    (t.prev = n),
    (r.next = n),
    (n.prev = r),
    n
  );
}
function Fh(s, e, t, n) {
  const i = new gl(s, e, t);
  return (
    n
      ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function ws(s) {
  (s.next.prev = s.prev),
    (s.prev.next = s.next),
    s.prevZ && (s.prevZ.nextZ = s.nextZ),
    s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function gl(s, e, t) {
  (this.i = s),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function Hx(s, e, t, n) {
  let i = 0;
  for (let r = e, o = t - n; r < t; r += n)
    (i += (s[o] - s[r]) * (s[r + 1] + s[o + 1])), (o = r);
  return i;
}
class di {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, r = 0; r < t; i = r++)
      n += e[i].x * e[r].y - e[r].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return di.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [],
      i = [],
      r = [];
    Nh(e), Bh(n, e);
    let o = e.length;
    t.forEach(Nh);
    for (let l = 0; l < t.length; l++)
      i.push(o), (o += t[l].length), Bh(n, t[l]);
    const a = Tx.triangulate(n, i);
    for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
    return r;
  }
}
function Nh(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function Bh(s, e) {
  for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
}
class Dr extends tt {
  constructor(
    e = new Ls([
      new ae(0.5, 0.5),
      new ae(-0.5, 0.5),
      new ae(-0.5, -0.5),
      new ae(0.5, -0.5),
    ]),
    t = {}
  ) {
    super();
    (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const n = this,
      i = [],
      r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      o(c);
    }
    this.setAttribute("position", new Je(i, 3)),
      this.setAttribute("uv", new Je(r, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1;
      let u = t.depth !== void 0 ? t.depth : 1,
        d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
        v = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        y = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const p = t.extrudePath,
        g = t.UVGenerator !== void 0 ? t.UVGenerator : Gx;
      t.amount !== void 0 &&
        (console.warn(
          "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
        ),
        (u = t.amount));
      let w,
        b = !1,
        _,
        E,
        L,
        D;
      p &&
        ((w = p.getSpacedPoints(h)),
        (b = !0),
        (d = !1),
        (_ = p.computeFrenetFrames(h, !1)),
        (E = new P()),
        (L = new P()),
        (D = new P())),
        d || ((y = 0), (f = 0), (m = 0), (v = 0));
      const V = a.extractPoints(c);
      let F = V.shape;
      const M = V.holes;
      if (!di.isClockWise(F)) {
        F = F.reverse();
        for (let K = 0, de = M.length; K < de; K++) {
          const pe = M[K];
          di.isClockWise(pe) && (M[K] = pe.reverse());
        }
      }
      const N = di.triangulateShape(F, M),
        O = F;
      for (let K = 0, de = M.length; K < de; K++) {
        const pe = M[K];
        F = F.concat(pe);
      }
      function H(K, de, pe) {
        return (
          de || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          de.clone().multiplyScalar(pe).add(K)
        );
      }
      const G = F.length,
        W = N.length;
      function k(K, de, pe) {
        let De, Ee, We;
        const ze = K.x - de.x,
          $e = K.y - de.y,
          ut = pe.x - K.x,
          R = pe.y - K.y,
          T = ze * ze + $e * $e,
          te = ze * R - $e * ut;
        if (Math.abs(te) > Number.EPSILON) {
          const ce = Math.sqrt(T),
            _e = Math.sqrt(ut * ut + R * R),
            Le = de.x - $e / ce,
            He = de.y + ze / ce,
            ne = pe.x - R / _e,
            U = pe.y + ut / _e,
            fe = ((ne - Le) * R - (U - He) * ut) / (ze * R - $e * ut);
          (De = Le + ze * fe - K.x), (Ee = He + $e * fe - K.y);
          const Ce = De * De + Ee * Ee;
          if (Ce <= 2) return new ae(De, Ee);
          We = Math.sqrt(Ce / 2);
        } else {
          let ce = !1;
          ze > Number.EPSILON
            ? ut > Number.EPSILON && (ce = !0)
            : ze < -Number.EPSILON
            ? ut < -Number.EPSILON && (ce = !0)
            : Math.sign($e) === Math.sign(R) && (ce = !0),
            ce
              ? ((De = -$e), (Ee = ze), (We = Math.sqrt(T)))
              : ((De = ze), (Ee = $e), (We = Math.sqrt(T / 2)));
        }
        return new ae(De / We, Ee / We);
      }
      const Q = [];
      for (
        let K = 0, de = O.length, pe = de - 1, De = K + 1;
        K < de;
        K++, pe++, De++
      )
        pe === de && (pe = 0),
          De === de && (De = 0),
          (Q[K] = k(O[K], O[pe], O[De]));
      const ie = [];
      let re,
        ee = Q.concat();
      for (let K = 0, de = M.length; K < de; K++) {
        const pe = M[K];
        re = [];
        for (
          let De = 0, Ee = pe.length, We = Ee - 1, ze = De + 1;
          De < Ee;
          De++, We++, ze++
        )
          We === Ee && (We = 0),
            ze === Ee && (ze = 0),
            (re[De] = k(pe[De], pe[We], pe[ze]));
        ie.push(re), (ee = ee.concat(re));
      }
      for (let K = 0; K < y; K++) {
        const de = K / y,
          pe = f * Math.cos((de * Math.PI) / 2),
          De = m * Math.sin((de * Math.PI) / 2) + v;
        for (let Ee = 0, We = O.length; Ee < We; Ee++) {
          const ze = H(O[Ee], Q[Ee], De);
          qe(ze.x, ze.y, -pe);
        }
        for (let Ee = 0, We = M.length; Ee < We; Ee++) {
          const ze = M[Ee];
          re = ie[Ee];
          for (let $e = 0, ut = ze.length; $e < ut; $e++) {
            const R = H(ze[$e], re[$e], De);
            qe(R.x, R.y, -pe);
          }
        }
      }
      const Me = m + v;
      for (let K = 0; K < G; K++) {
        const de = d ? H(F[K], ee[K], Me) : F[K];
        b
          ? (L.copy(_.normals[0]).multiplyScalar(de.x),
            E.copy(_.binormals[0]).multiplyScalar(de.y),
            D.copy(w[0]).add(L).add(E),
            qe(D.x, D.y, D.z))
          : qe(de.x, de.y, 0);
      }
      for (let K = 1; K <= h; K++)
        for (let de = 0; de < G; de++) {
          const pe = d ? H(F[de], ee[de], Me) : F[de];
          b
            ? (L.copy(_.normals[K]).multiplyScalar(pe.x),
              E.copy(_.binormals[K]).multiplyScalar(pe.y),
              D.copy(w[K]).add(L).add(E),
              qe(D.x, D.y, D.z))
            : qe(pe.x, pe.y, (u / h) * K);
        }
      for (let K = y - 1; K >= 0; K--) {
        const de = K / y,
          pe = f * Math.cos((de * Math.PI) / 2),
          De = m * Math.sin((de * Math.PI) / 2) + v;
        for (let Ee = 0, We = O.length; Ee < We; Ee++) {
          const ze = H(O[Ee], Q[Ee], De);
          qe(ze.x, ze.y, u + pe);
        }
        for (let Ee = 0, We = M.length; Ee < We; Ee++) {
          const ze = M[Ee];
          re = ie[Ee];
          for (let $e = 0, ut = ze.length; $e < ut; $e++) {
            const R = H(ze[$e], re[$e], De);
            b
              ? qe(R.x, R.y + w[h - 1].y, w[h - 1].x + pe)
              : qe(R.x, R.y, u + pe);
          }
        }
      }
      Be(), Re();
      function Be() {
        const K = i.length / 3;
        if (d) {
          let de = 0,
            pe = G * de;
          for (let De = 0; De < W; De++) {
            const Ee = N[De];
            ke(Ee[2] + pe, Ee[1] + pe, Ee[0] + pe);
          }
          (de = h + y * 2), (pe = G * de);
          for (let De = 0; De < W; De++) {
            const Ee = N[De];
            ke(Ee[0] + pe, Ee[1] + pe, Ee[2] + pe);
          }
        } else {
          for (let de = 0; de < W; de++) {
            const pe = N[de];
            ke(pe[2], pe[1], pe[0]);
          }
          for (let de = 0; de < W; de++) {
            const pe = N[de];
            ke(pe[0] + G * h, pe[1] + G * h, pe[2] + G * h);
          }
        }
        n.addGroup(K, i.length / 3 - K, 0);
      }
      function Re() {
        const K = i.length / 3;
        let de = 0;
        Z(O, de), (de += O.length);
        for (let pe = 0, De = M.length; pe < De; pe++) {
          const Ee = M[pe];
          Z(Ee, de), (de += Ee.length);
        }
        n.addGroup(K, i.length / 3 - K, 1);
      }
      function Z(K, de) {
        let pe = K.length;
        for (; --pe >= 0; ) {
          const De = pe;
          let Ee = pe - 1;
          Ee < 0 && (Ee = K.length - 1);
          for (let We = 0, ze = h + y * 2; We < ze; We++) {
            const $e = G * We,
              ut = G * (We + 1),
              R = de + De + $e,
              T = de + Ee + $e,
              te = de + Ee + ut,
              ce = de + De + ut;
            Fe(R, T, te, ce);
          }
        }
      }
      function qe(K, de, pe) {
        l.push(K), l.push(de), l.push(pe);
      }
      function ke(K, de, pe) {
        Ie(K), Ie(de), Ie(pe);
        const De = i.length / 3,
          Ee = g.generateTopUV(n, i, De - 3, De - 2, De - 1);
        Ze(Ee[0]), Ze(Ee[1]), Ze(Ee[2]);
      }
      function Fe(K, de, pe, De) {
        Ie(K), Ie(de), Ie(De), Ie(de), Ie(pe), Ie(De);
        const Ee = i.length / 3,
          We = g.generateSideWallUV(n, i, Ee - 6, Ee - 3, Ee - 2, Ee - 1);
        Ze(We[0]), Ze(We[1]), Ze(We[3]), Ze(We[1]), Ze(We[2]), Ze(We[3]);
      }
      function Ie(K) {
        i.push(l[K * 3 + 0]), i.push(l[K * 3 + 1]), i.push(l[K * 3 + 2]);
      }
      function Ze(K) {
        r.push(K.x), r.push(K.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      n = this.parameters.options;
    return Vx(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const a = t[e.shapes[r]];
      n.push(a);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new Qu[i.type]().fromJSON(i)),
      new Dr(n, e.options)
    );
  }
}
const Gx = {
  generateTopUV: function (s, e, t, n, i) {
    const r = e[t * 3],
      o = e[t * 3 + 1],
      a = e[n * 3],
      l = e[n * 3 + 1],
      c = e[i * 3],
      h = e[i * 3 + 1];
    return [new ae(r, o), new ae(a, l), new ae(c, h)];
  },
  generateSideWallUV: function (s, e, t, n, i, r) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      c = e[n * 3],
      h = e[n * 3 + 1],
      u = e[n * 3 + 2],
      d = e[i * 3],
      f = e[i * 3 + 1],
      m = e[i * 3 + 2],
      v = e[r * 3],
      y = e[r * 3 + 1],
      p = e[r * 3 + 2];
    return Math.abs(a - h) < Math.abs(o - c)
      ? [new ae(o, 1 - l), new ae(c, 1 - u), new ae(d, 1 - m), new ae(v, 1 - p)]
      : [
          new ae(a, 1 - l),
          new ae(h, 1 - u),
          new ae(f, 1 - m),
          new ae(y, 1 - p),
        ];
  },
};
function Vx(s, e, t) {
  if (((t.shapes = []), Array.isArray(s)))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      t.shapes.push(r.uuid);
    }
  else t.shapes.push(s.uuid);
  return (
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class ql extends tt {
  constructor(
    e = new Ls([new ae(0, 0.5), new ae(-0.5, -0.5), new ae(0.5, -0.5)]),
    t = 12
  ) {
    super();
    (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const n = [],
      i = [],
      r = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let h = 0; h < e.length; h++)
        c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
    this.setIndex(n),
      this.setAttribute("position", new Je(i, 3)),
      this.setAttribute("normal", new Je(r, 3)),
      this.setAttribute("uv", new Je(o, 2));
    function c(h) {
      const u = i.length / 3,
        d = h.extractPoints(t);
      let f = d.shape;
      const m = d.holes;
      di.isClockWise(f) === !1 && (f = f.reverse());
      for (let y = 0, p = m.length; y < p; y++) {
        const g = m[y];
        di.isClockWise(g) === !0 && (m[y] = g.reverse());
      }
      const v = di.triangulateShape(f, m);
      for (let y = 0, p = m.length; y < p; y++) {
        const g = m[y];
        f = f.concat(g);
      }
      for (let y = 0, p = f.length; y < p; y++) {
        const g = f[y];
        i.push(g.x, g.y, 0), r.push(0, 0, 1), o.push(g.x, g.y);
      }
      for (let y = 0, p = v.length; y < p; y++) {
        const g = v[y],
          w = g[0] + u,
          b = g[1] + u,
          _ = g[2] + u;
        n.push(w, b, _), (l += 3);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return Wx(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, r = e.shapes.length; i < r; i++) {
      const o = t[e.shapes[i]];
      n.push(o);
    }
    return new ql(n, e.curveSegments);
  }
}
function Wx(s, e) {
  if (((e.shapes = []), Array.isArray(s)))
    for (let t = 0, n = s.length; t < n; t++) {
      const i = s[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(s.uuid);
  return e;
}
class id extends tt {
  constructor(
    e = 1,
    t = 32,
    n = 16,
    i = 0,
    r = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super();
    (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (n = Math.max(2, Math.floor(n)));
    const l = Math.min(o + a, Math.PI);
    let c = 0;
    const h = [],
      u = new P(),
      d = new P(),
      f = [],
      m = [],
      v = [],
      y = [];
    for (let p = 0; p <= n; p++) {
      const g = [],
        w = p / n;
      let b = 0;
      p == 0 && o == 0
        ? (b = 0.5 / t)
        : p == n && l == Math.PI && (b = -0.5 / t);
      for (let _ = 0; _ <= t; _++) {
        const E = _ / t;
        (u.x = -e * Math.cos(i + E * r) * Math.sin(o + w * a)),
          (u.y = e * Math.cos(o + w * a)),
          (u.z = e * Math.sin(i + E * r) * Math.sin(o + w * a)),
          m.push(u.x, u.y, u.z),
          d.copy(u).normalize(),
          v.push(d.x, d.y, d.z),
          y.push(E + b, 1 - w),
          g.push(c++);
      }
      h.push(g);
    }
    for (let p = 0; p < n; p++)
      for (let g = 0; g < t; g++) {
        const w = h[p][g + 1],
          b = h[p][g],
          _ = h[p + 1][g],
          E = h[p + 1][g + 1];
        (p !== 0 || o > 0) && f.push(w, b, E),
          (p !== n - 1 || l < Math.PI) && f.push(b, _, E);
      }
    this.setIndex(f),
      this.setAttribute("position", new Je(m, 3)),
      this.setAttribute("normal", new Je(v, 3)),
      this.setAttribute("uv", new Je(y, 2));
  }
  static fromJSON(e) {
    return new id(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class rd extends Et {
  constructor(e) {
    super();
    (this.type = "ShadowMaterial"),
      (this.color = new ye(0)),
      (this.transparent = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this;
  }
}
rd.prototype.isShadowMaterial = !0;
class sd extends Vt {
  constructor(e) {
    super(e);
    this.type = "RawShaderMaterial";
  }
}
sd.prototype.isRawShaderMaterial = !0;
class Fr extends Et {
  constructor(e) {
    super();
    (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new ye(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new ye(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ii),
      (this.normalScale = new ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
Fr.prototype.isMeshStandardMaterial = !0;
class wi extends Fr {
  constructor(e) {
    super();
    (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new ae(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Kt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.sheenColor = new ye(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 0),
      (this.attenuationColor = new ye(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new ye(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
wi.prototype.isMeshPhysicalMaterial = !0;
class hs extends Et {
  constructor(e) {
    super();
    (this.type = "MeshPhongMaterial"),
      (this.color = new ye(16777215)),
      (this.specular = new ye(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new ye(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ii),
      (this.normalScale = new ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = ko),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
hs.prototype.isMeshPhongMaterial = !0;
class od extends Et {
  constructor(e) {
    super();
    (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new ye(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new ye(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ii),
      (this.normalScale = new ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      this
    );
  }
}
od.prototype.isMeshToonMaterial = !0;
class ad extends Et {
  constructor(e) {
    super();
    (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ii),
      (this.normalScale = new ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
ad.prototype.isMeshNormalMaterial = !0;
class Yl extends Et {
  constructor(e) {
    super();
    (this.type = "MeshLambertMaterial"),
      (this.color = new ye(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new ye(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = ko),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      this
    );
  }
}
Yl.prototype.isMeshLambertMaterial = !0;
class ld extends Et {
  constructor(e) {
    super();
    (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new ye(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ii),
      (this.normalScale = new ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
ld.prototype.isMeshMatcapMaterial = !0;
class cd extends Nn {
  constructor(e) {
    super();
    (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
cd.prototype.isLineDashedMaterial = !0;
const Xx = {
  ShadowMaterial: rd,
  SpriteMaterial: kl,
  RawShaderMaterial: sd,
  ShaderMaterial: Vt,
  PointsMaterial: Zo,
  MeshPhysicalMaterial: wi,
  MeshStandardMaterial: Fr,
  MeshPhongMaterial: hs,
  MeshToonMaterial: od,
  MeshNormalMaterial: ad,
  MeshLambertMaterial: Yl,
  MeshDepthMaterial: Ul,
  MeshDistanceMaterial: zl,
  MeshBasicMaterial: Rn,
  MeshMatcapMaterial: ld,
  LineDashedMaterial: cd,
  LineBasicMaterial: Nn,
  Material: Et,
};
Et.fromType = function (s) {
  return new Xx[s]();
};
const bt = {
  arraySlice: function (s, e, t) {
    return bt.isTypedArray(s)
      ? new s.constructor(s.subarray(e, t !== void 0 ? t : s.length))
      : s.slice(e, t);
  },
  convertArray: function (s, e, t) {
    return !s || (!t && s.constructor === e)
      ? s
      : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(s)
      : Array.prototype.slice.call(s);
  },
  isTypedArray: function (s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView);
  },
  getKeyframeOrder: function (s) {
    function e(i, r) {
      return s[i] - s[r];
    }
    const t = s.length,
      n = new Array(t);
    for (let i = 0; i !== t; ++i) n[i] = i;
    return n.sort(e), n;
  },
  sortedArray: function (s, e, t) {
    const n = s.length,
      i = new s.constructor(n);
    for (let r = 0, o = 0; o !== n; ++r) {
      const a = t[r] * e;
      for (let l = 0; l !== e; ++l) i[o++] = s[a + l];
    }
    return i;
  },
  flattenJSON: function (s, e, t, n) {
    let i = 1,
      r = s[0];
    for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
    if (r === void 0) return;
    let o = r[n];
    if (o !== void 0)
      if (Array.isArray(o))
        do
          (o = r[n]),
            o !== void 0 && (e.push(r.time), t.push.apply(t, o)),
            (r = s[i++]);
        while (r !== void 0);
      else if (o.toArray !== void 0)
        do
          (o = r[n]),
            o !== void 0 && (e.push(r.time), o.toArray(t, t.length)),
            (r = s[i++]);
        while (r !== void 0);
      else
        do
          (o = r[n]), o !== void 0 && (e.push(r.time), t.push(o)), (r = s[i++]);
        while (r !== void 0);
  },
  subclip: function (s, e, t, n, i = 30) {
    const r = s.clone();
    r.name = e;
    const o = [];
    for (let l = 0; l < r.tracks.length; ++l) {
      const c = r.tracks[l],
        h = c.getValueSize(),
        u = [],
        d = [];
      for (let f = 0; f < c.times.length; ++f) {
        const m = c.times[f] * i;
        if (!(m < t || m >= n)) {
          u.push(c.times[f]);
          for (let v = 0; v < h; ++v) d.push(c.values[f * h + v]);
        }
      }
      u.length !== 0 &&
        ((c.times = bt.convertArray(u, c.times.constructor)),
        (c.values = bt.convertArray(d, c.values.constructor)),
        o.push(c));
    }
    r.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < r.tracks.length; ++l)
      a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
    for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
    return r.resetDuration(), r;
  },
  makeClipAdditive: function (s, e = 0, t = s, n = 30) {
    n <= 0 && (n = 30);
    const i = t.tracks.length,
      r = e / n;
    for (let o = 0; o < i; ++o) {
      const a = t.tracks[o],
        l = a.ValueTypeName;
      if (l === "bool" || l === "string") continue;
      const c = s.tracks.find(function (p) {
        return p.name === a.name && p.ValueTypeName === l;
      });
      if (c === void 0) continue;
      let h = 0;
      const u = a.getValueSize();
      a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (h = u / 3);
      let d = 0;
      const f = c.getValueSize();
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (d = f / 3);
      const m = a.times.length - 1;
      let v;
      if (r <= a.times[0]) {
        const p = h,
          g = u - h;
        v = bt.arraySlice(a.values, p, g);
      } else if (r >= a.times[m]) {
        const p = m * u + h,
          g = p + u - h;
        v = bt.arraySlice(a.values, p, g);
      } else {
        const p = a.createInterpolant(),
          g = h,
          w = u - h;
        p.evaluate(r), (v = bt.arraySlice(p.resultBuffer, g, w));
      }
      l === "quaternion" &&
        new Dt().fromArray(v).normalize().conjugate().toArray(v);
      const y = c.times.length;
      for (let p = 0; p < y; ++p) {
        const g = p * f + d;
        if (l === "quaternion")
          Dt.multiplyQuaternionsFlat(c.values, g, v, 0, c.values, g);
        else {
          const w = f - d * 2;
          for (let b = 0; b < w; ++b) c.values[g + b] -= v[b];
        }
      }
    }
    return (s.blendMode = Mu), s;
  },
};
class Zn {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      r = t[n - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < i)) {
            for (let a = n + 2; ; ) {
              if (i === void 0) {
                if (e < r) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, e, r)
                );
              }
              if (n === a) break;
              if (((r = i), (i = t[++n]), e < i)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= r)) {
            const a = t[1];
            e < a && ((n = 2), (r = a));
            for (let l = n - 2; ; ) {
              if (r === void 0)
                return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
              if (n === l) break;
              if (((i = r), (r = t[--n - 1]), e >= r)) break t;
            }
            (o = n), (n = 0);
            break n;
          }
          break e;
        }
        for (; n < o; ) {
          const a = (n + o) >>> 1;
          e < t[a] ? (o = a) : (n = a + 1);
        }
        if (((i = t[n]), (r = t[n - 1]), r === void 0))
          return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
        if (i === void 0)
          return (
            (n = t.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, e)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i;
    for (let o = 0; o !== i; ++o) t[o] = n[r + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
Zn.prototype.beforeStart_ = Zn.prototype.copySampleValue_;
Zn.prototype.afterEnd_ = Zn.prototype.copySampleValue_;
class jx extends Zn {
  constructor(e, t, n, i) {
    super(e, t, n, i);
    (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: lr, endingEnd: lr });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2,
      o = e + 1,
      a = i[r],
      l = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case cr:
          (r = e), (a = 2 * t - n);
          break;
        case Co:
          (r = i.length - 2), (a = t + i[r] - i[r + 1]);
          break;
        default:
          (r = e), (a = n);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case cr:
          (o = e), (l = 2 * n - t);
          break;
        case Co:
          (o = 1), (l = n + i[1] - i[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const c = (n - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - n)),
      (this._offsetPrev = r * h),
      (this._offsetNext = o * h);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      h = this._offsetPrev,
      u = this._offsetNext,
      d = this._weightPrev,
      f = this._weightNext,
      m = (n - t) / (i - t),
      v = m * m,
      y = v * m,
      p = -d * y + 2 * d * v - d * m,
      g = (1 + d) * y + (-1.5 - 2 * d) * v + (-0.5 + d) * m + 1,
      w = (-1 - f) * y + (1.5 + f) * v + 0.5 * m,
      b = f * y - f * v;
    for (let _ = 0; _ !== a; ++_)
      r[_] = p * o[h + _] + g * o[c + _] + w * o[l + _] + b * o[u + _];
    return r;
  }
}
class hd extends Zn {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      h = (n - t) / (i - t),
      u = 1 - h;
    for (let d = 0; d !== a; ++d) r[d] = o[c + d] * u + o[l + d] * h;
    return r;
  }
}
class qx extends Zn {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Bn {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = bt.convertArray(t, this.TimeBufferType)),
      (this.values = bt.convertArray(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: bt.convertArray(e.times, Array),
        values: bt.convertArray(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new qx(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new hd(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new jx(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case fs:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case _r:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case oa:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return fs;
      case this.InterpolantFactoryMethodLinear:
        return _r;
      case this.InterpolantFactoryMethodSmooth:
        return oa;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let r = 0,
      o = i - 1;
    for (; r !== i && n[r] < e; ) ++r;
    for (; o !== -1 && n[o] > t; ) --o;
    if ((++o, r !== 0 || o !== i)) {
      r >= o && ((o = Math.max(o, 1)), (r = o - 1));
      const a = this.getValueSize();
      (this.times = bt.arraySlice(n, r, o)),
        (this.values = bt.arraySlice(this.values, r * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const n = this.times,
      i = this.values,
      r = n.length;
    r === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== r; a++) {
      const l = n[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (i !== void 0 && bt.isTypedArray(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = bt.arraySlice(this.times),
      t = bt.arraySlice(this.values),
      n = this.getValueSize(),
      i = this.getInterpolation() === oa,
      r = e.length - 1;
    let o = 1;
    for (let a = 1; a < r; ++a) {
      let l = !1;
      const c = e[a],
        h = e[a + 1];
      if (c !== h && (a !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const u = a * n,
            d = u - n,
            f = u + n;
          for (let m = 0; m !== n; ++m) {
            const v = t[u + m];
            if (v !== t[d + m] || v !== t[f + m]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const u = a * n,
            d = o * n;
          for (let f = 0; f !== n; ++f) t[d + f] = t[u + f];
        }
        ++o;
      }
    }
    if (r > 0) {
      e[o] = e[r];
      for (let a = r * n, l = o * n, c = 0; c !== n; ++c) t[l + c] = t[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = bt.arraySlice(e, 0, o)),
          (this.values = bt.arraySlice(t, 0, o * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = bt.arraySlice(this.times, 0),
      t = bt.arraySlice(this.values, 0),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
Bn.prototype.TimeBufferType = Float32Array;
Bn.prototype.ValueBufferType = Float32Array;
Bn.prototype.DefaultInterpolation = _r;
class Nr extends Bn {}
Nr.prototype.ValueTypeName = "bool";
Nr.prototype.ValueBufferType = Array;
Nr.prototype.DefaultInterpolation = fs;
Nr.prototype.InterpolantFactoryMethodLinear = void 0;
Nr.prototype.InterpolantFactoryMethodSmooth = void 0;
class ud extends Bn {}
ud.prototype.ValueTypeName = "color";
class Mr extends Bn {}
Mr.prototype.ValueTypeName = "number";
class Yx extends Zn {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (n - t) / (i - t);
    let c = e * a;
    for (let h = c + a; c !== h; c += 4) Dt.slerpFlat(r, 0, o, c - a, o, c, l);
    return r;
  }
}
class vi extends Bn {
  InterpolantFactoryMethodLinear(e) {
    return new Yx(this.times, this.values, this.getValueSize(), e);
  }
}
vi.prototype.ValueTypeName = "quaternion";
vi.prototype.DefaultInterpolation = _r;
vi.prototype.InterpolantFactoryMethodSmooth = void 0;
class Br extends Bn {}
Br.prototype.ValueTypeName = "string";
Br.prototype.ValueBufferType = Array;
Br.prototype.DefaultInterpolation = fs;
Br.prototype.InterpolantFactoryMethodLinear = void 0;
Br.prototype.InterpolantFactoryMethodSmooth = void 0;
class Sr extends Bn {}
Sr.prototype.ValueTypeName = "vector";
class Po {
  constructor(e, t = -1, n, i = Pl) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = gn()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let o = 0, a = n.length; o !== a; ++o) t.push($x(n[o]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return (r.uuid = e.uuid), r;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let r = 0, o = n.length; r !== o; ++r) t.push(Bn.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length,
      o = [];
    for (let a = 0; a < r; a++) {
      let l = [],
        c = [];
      l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
      const h = bt.getKeyframeOrder(l);
      (l = bt.sortedArray(l, 1, h)),
        (c = bt.sortedArray(c, 1, h)),
        !i && l[0] === 0 && (l.push(r), c.push(c[0])),
        o.push(
          new Mr(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / n)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        h = c.name.match(r);
      if (h && h.length > 1) {
        const u = h[1];
        let d = i[u];
        d || (i[u] = d = []), d.push(c);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (u, d, f, m, v) {
        if (f.length !== 0) {
          const y = [],
            p = [];
          bt.flattenJSON(f, y, p, m), y.length !== 0 && v.push(new u(d, y, p));
        }
      },
      i = [],
      r = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const d = c[u].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let m;
          for (m = 0; m < d.length; m++)
            if (d[m].morphTargets)
              for (let v = 0; v < d[m].morphTargets.length; v++)
                f[d[m].morphTargets[v]] = -1;
          for (const v in f) {
            const y = [],
              p = [];
            for (let g = 0; g !== d[m].morphTargets.length; ++g) {
              const w = d[m];
              y.push(w.time), p.push(w.morphTarget === v ? 1 : 0);
            }
            i.push(new Mr(".morphTargetInfluence[" + v + "]", y, p));
          }
          l = f.length * o;
        } else {
          const f = ".bones[" + t[u].name + "]";
          n(Sr, f + ".position", d, "pos", i),
            n(vi, f + ".quaternion", d, "rot", i),
            n(Sr, f + ".scale", d, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(r, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function Zx(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Mr;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Sr;
    case "color":
      return ud;
    case "quaternion":
      return vi;
    case "bool":
    case "boolean":
      return Nr;
    case "string":
      return Br;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function $x(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = Zx(s.type);
  if (s.times === void 0) {
    const t = [],
      n = [];
    bt.flattenJSON(s.keys, t, n, "value"), (s.times = t), (s.values = n);
  }
  return e.parse !== void 0
    ? e.parse(s)
    : new e(s.name, s.times, s.values, s.interpolation);
}
const Tr = {
  enabled: !1,
  files: {},
  add: function (s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function (s) {
    if (this.enabled !== !1) return this.files[s];
  },
  remove: function (s) {
    delete this.files[s];
  },
  clear: function () {
    this.files = {};
  },
};
class Kx {
  constructor(e, t, n) {
    const i = this;
    let r = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (h) {
        a++, r === !1 && i.onStart !== void 0 && i.onStart(h, o, a), (r = !0);
      }),
      (this.itemEnd = function (h) {
        o++,
          i.onProgress !== void 0 && i.onProgress(h, o, a),
          o === a && ((r = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (h) {
        i.onError !== void 0 && i.onError(h);
      }),
      (this.resolveURL = function (h) {
        return l ? l(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (l = h), this;
      }),
      (this.addHandler = function (h, u) {
        return c.push(h, u), this;
      }),
      (this.removeHandler = function (h) {
        const u = c.indexOf(h);
        return u !== -1 && c.splice(u, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let u = 0, d = c.length; u < d; u += 2) {
          const f = c[u],
            m = c[u + 1];
          if ((f.global && (f.lastIndex = 0), f.test(h))) return m;
        }
        return null;
      });
  }
}
const Jx = new Kx();
class cn {
  constructor(e) {
    (this.manager = e !== void 0 ? e : Jx),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
const Vn = {};
class Pn extends cn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = Tr.get(e);
    if (r !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(r), this.manager.itemEnd(e);
        }, 0),
        r
      );
    if (Vn[e] !== void 0) {
      Vn[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (Vn[e] = []), Vn[e].push({ onLoad: t, onProgress: n, onError: i });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream == "undefined" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const h = Vn[e],
            u = c.body.getReader(),
            d = c.headers.get("Content-Length"),
            f = d ? parseInt(d) : 0,
            m = f !== 0;
          let v = 0;
          const y = new ReadableStream({
            start(p) {
              g();
              function g() {
                u.read().then(({ done: w, value: b }) => {
                  if (w) p.close();
                  else {
                    v += b.byteLength;
                    const _ = new ProgressEvent("progress", {
                      lengthComputable: m,
                      loaded: v,
                      total: f,
                    });
                    for (let E = 0, L = h.length; E < L; E++) {
                      const D = h[E];
                      D.onProgress && D.onProgress(_);
                    }
                    p.enqueue(b), g();
                  }
                });
              }
            },
          });
          return new Response(y);
        } else
          throw Error(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const u = /charset="?([^;"\s]*)"?/i.exec(a),
                d = u && u[1] ? u[1].toLowerCase() : void 0,
                f = new TextDecoder(d);
              return c.arrayBuffer().then((m) => f.decode(m));
            }
        }
      })
      .then((c) => {
        Tr.add(e, c);
        const h = Vn[e];
        delete Vn[e];
        for (let u = 0, d = h.length; u < d; u++) {
          const f = h[u];
          f.onLoad && f.onLoad(c);
        }
      })
      .catch((c) => {
        const h = Vn[e];
        if (h === void 0) throw (this.manager.itemError(e), c);
        delete Vn[e];
        for (let u = 0, d = h.length; u < d; u++) {
          const f = h[u];
          f.onError && f.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class dd extends cn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      o = Tr.get(e);
    if (o !== void 0)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), r.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = gs("img");
    function l() {
      h(), Tr.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(u) {
      h(), i && i(u), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      r.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class Qx extends cn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new Wo(),
      o = new dd(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(
        e[c],
        function (h) {
          (r.images[c] = h), a++, a === 6 && ((r.needsUpdate = !0), t && t(r));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return r;
  }
}
class fd extends cn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this,
      o = new Hl(),
      a = new Pn(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(r.withCredentials),
      a.load(
        e,
        function (l) {
          const c = r.parse(l);
          !c ||
            (c.image !== void 0
              ? (o.image = c.image)
              : c.data !== void 0 &&
                ((o.image.width = c.width),
                (o.image.height = c.height),
                (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : Zt),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : Zt),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : st),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : st),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = yi)),
            c.mipmapCount === 1 && (o.minFilter = st),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, c));
        },
        n,
        i
      ),
      o
    );
  }
}
class Zl extends cn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new At(),
      o = new dd(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (r.image = a), (r.needsUpdate = !0), t !== void 0 && t(r);
        },
        n,
        i
      ),
      r
    );
  }
}
class Dn extends at {
  constructor(e, t = 1) {
    super();
    (this.type = "Light"), (this.color = new ye(e)), (this.intensity = t);
  }
  dispose() {}
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
Dn.prototype.isLight = !0;
class ey extends Dn {
  constructor(e, t, n) {
    super(e, n);
    (this.type = "HemisphereLight"),
      this.position.copy(at.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new ye(t));
  }
  copy(e) {
    return (
      Dn.prototype.copy.call(this, e),
      this.groundColor.copy(e.groundColor),
      this
    );
  }
}
ey.prototype.isHemisphereLight = !0;
const Oh = new be(),
  Uh = new P(),
  zh = new P();
class $l {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new ae(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new be()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Xo()),
      (this._frameExtents = new ae(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new ct(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    Uh.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Uh),
      zh.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(zh),
      t.updateMatrixWorld(),
      Oh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Oh),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(t.projectionMatrix),
      n.multiply(t.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class pd extends $l {
  constructor() {
    super(new Yt(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = ms * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      r = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || r !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = r), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
pd.prototype.isSpotLightShadow = !0;
class Kl extends Dn {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 1) {
    super(e, t);
    (this.type = "SpotLight"),
      this.position.copy(at.DefaultUp),
      this.updateMatrix(),
      (this.target = new at()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = r),
      (this.decay = o),
      (this.shadow = new pd());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
Kl.prototype.isSpotLight = !0;
const kh = new be(),
  ts = new P(),
  za = new P();
class md extends $l {
  constructor() {
    super(new Yt(90, 1, 0.5, 500));
    (this._frameExtents = new ae(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new ct(2, 1, 1, 1),
        new ct(0, 1, 1, 1),
        new ct(3, 1, 1, 1),
        new ct(1, 1, 1, 1),
        new ct(3, 0, 1, 1),
        new ct(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new P(1, 0, 0),
        new P(-1, 0, 0),
        new P(0, 0, 1),
        new P(0, 0, -1),
        new P(0, 1, 0),
        new P(0, -1, 0),
      ]),
      (this._cubeUps = [
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 0, 1),
        new P(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      r = e.distance || n.far;
    r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
      ts.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(ts),
      za.copy(n.position),
      za.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(za),
      n.updateMatrixWorld(),
      i.makeTranslation(-ts.x, -ts.y, -ts.z),
      kh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(kh);
  }
}
md.prototype.isPointLightShadow = !0;
class Io extends Dn {
  constructor(e, t, n = 0, i = 1) {
    super(e, t);
    (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new md());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
Io.prototype.isPointLight = !0;
class gd extends $l {
  constructor() {
    super(new Ni(-5, 5, 5, -5, 0.5, 500));
  }
}
gd.prototype.isDirectionalLightShadow = !0;
class Jl extends Dn {
  constructor(e, t) {
    super(e, t);
    (this.type = "DirectionalLight"),
      this.position.copy(at.DefaultUp),
      this.updateMatrix(),
      (this.target = new at()),
      (this.shadow = new gd());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
Jl.prototype.isDirectionalLight = !0;
class vd extends Dn {
  constructor(e, t) {
    super(e, t);
    this.type = "AmbientLight";
  }
}
vd.prototype.isAmbientLight = !0;
class ty extends Dn {
  constructor(e, t, n = 10, i = 10) {
    super(e, t);
    (this.type = "RectAreaLight"), (this.width = n), (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
ty.prototype.isRectAreaLight = !0;
class xd {
  constructor() {
    this.coefficients = [];
    for (let e = 0; e < 9; e++) this.coefficients.push(new P());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x,
      i = e.y,
      r = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * i),
      t.addScaledVector(o[2], 0.488603 * r),
      t.addScaledVector(o[3], 0.488603 * n),
      t.addScaledVector(o[4], 1.092548 * (n * i)),
      t.addScaledVector(o[5], 1.092548 * (i * r)),
      t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
      t.addScaledVector(o[7], 1.092548 * (n * r)),
      t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const n = e.x,
      i = e.y,
      r = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * i),
      t.addScaledVector(o[2], 2 * 0.511664 * r),
      t.addScaledVector(o[3], 2 * 0.511664 * n),
      t.addScaledVector(o[4], 2 * 0.429043 * n * i),
      t.addScaledVector(o[5], 2 * 0.429043 * i * r),
      t.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * n * r),
      t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x,
      i = e.y,
      r = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * r),
      (t[3] = 0.488603 * n),
      (t[4] = 1.092548 * n * i),
      (t[5] = 1.092548 * i * r),
      (t[6] = 0.315392 * (3 * r * r - 1)),
      (t[7] = 1.092548 * n * r),
      (t[8] = 0.546274 * (n * n - i * i));
  }
}
xd.prototype.isSphericalHarmonics3 = !0;
class Ql extends Dn {
  constructor(e = new xd(), t = 1) {
    super(void 0, t);
    this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
Ql.prototype.isLightProbe = !0;
class Tn {
  static decodeText(e) {
    if (typeof TextDecoder != "undefined") return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class ny extends tt {
  constructor() {
    super();
    (this.type = "InstancedBufferGeometry"), (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
ny.prototype.isInstancedBufferGeometry = !0;
class yd extends cn {
  constructor(e) {
    super(e);
    typeof createImageBitmap == "undefined" &&
      console.warn(
        "THREE.ImageBitmapLoader: createImageBitmap() not supported."
      ),
      typeof fetch == "undefined" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      o = Tr.get(e);
    if (o !== void 0)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), r.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(r.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          Tr.add(e, l), t && t(l), r.manager.itemEnd(e);
        })
        .catch(function (l) {
          i && i(l), r.manager.itemError(e), r.manager.itemEnd(e);
        }),
      r.manager.itemStart(e);
  }
}
yd.prototype.isImageBitmapLoader = !0;
let po;
const iy = {
  getContext: function () {
    return (
      po === void 0 &&
        (po = new (window.AudioContext || window.webkitAudioContext)()),
      po
    );
  },
  setContext: function (s) {
    po = s;
  },
};
class ry extends cn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this,
      o = new Pn(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            const l = a.slice(0);
            iy.getContext().decodeAudioData(l, function (h) {
              t(h);
            });
          } catch (l) {
            i ? i(l) : console.error(l), r.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
}
class sy extends Ql {
  constructor(e, t, n = 1) {
    super(void 0, n);
    const i = new ye().set(e),
      r = new ye().set(t),
      o = new P(i.r, i.g, i.b),
      a = new P(r.r, r.g, r.b),
      l = Math.sqrt(Math.PI),
      c = l * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
      this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
  }
}
sy.prototype.isHemisphereLightProbe = !0;
class oy extends Ql {
  constructor(e, t = 1) {
    super(void 0, t);
    const n = new ye().set(e);
    this.sh.coefficients[0]
      .set(n.r, n.g, n.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
oy.prototype.isAmbientLightProbe = !0;
class ay {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = Hh()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = Hh();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function Hh() {
  return (typeof performance == "undefined" ? Date : performance).now();
}
class ly extends at {
  constructor(e) {
    super();
    (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source.stop(),
      (this.source.onended = null),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return (this._connected = !1), this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
class cy {
  constructor(e, t, n) {
    (this.binding = e), (this.valueSize = n);
    let i, r, o;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (r = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (r = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5));
        break;
      default:
        (i = this._lerp),
          (r = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = r),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const n = this.buffer,
      i = this.valueSize,
      r = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== i; ++a) n[r + a] = n[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(n, r, 0, a, i);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, n),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      n = this.buffer,
      i = e * t + t,
      r = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(n, i, l, 1 - r, t);
    }
    o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (n[l] !== n[l + t]) {
        a.setValue(n, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    e.getValue(t, i);
    for (let r = n, o = i; r !== o; ++r) t[r] = t[i + (r % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let n = e; n < t; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, i, r) {
    if (i >= 0.5) for (let o = 0; o !== r; ++o) e[t + o] = e[n + o];
  }
  _slerp(e, t, n, i) {
    Dt.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, r) {
    const o = this._workIndex * r;
    Dt.multiplyQuaternionsFlat(e, o, e, t, e, n),
      Dt.slerpFlat(e, t, e, t, e, o, i);
  }
  _lerp(e, t, n, i, r) {
    const o = 1 - i;
    for (let a = 0; a !== r; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[n + a] * i;
    }
  }
  _lerpAdditive(e, t, n, i, r) {
    for (let o = 0; o !== r; ++o) {
      const a = t + o;
      e[a] = e[a] + e[n + o] * i;
    }
  }
}
const ec = "\\[\\]\\.:\\/",
  hy = new RegExp("[" + ec + "]", "g"),
  tc = "[^" + ec + "]",
  uy = "[^" + ec.replace("\\.", "") + "]",
  dy = /((?:WC+[\/:])*)/.source.replace("WC", tc),
  fy = /(WCOD+)?/.source.replace("WCOD", uy),
  py = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", tc),
  my = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", tc),
  gy = new RegExp("^" + dy + fy + py + my + "$"),
  vy = ["material", "materials", "bones"];
class xy {
  constructor(e, t, n) {
    const i = n || ot.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class ot {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || ot.parseTrackName(t)),
      (this.node = ot.findNode(e, this.parsedPath.nodeName) || e),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new ot.Composite(e, t, n)
      : new ot(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(hy, "");
  }
  static parseTrackName(e) {
    const t = gy.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      vy.indexOf(r) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (r) {
          for (let o = 0; o < r.length; o++) {
            const a = r[o];
            if (a.name === t || a.uuid === t) return a;
            const l = n(a.children);
            if (l) return l;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let r = t.propertyIndex;
    if (
      (e ||
        ((e = ot.findNode(this.rootNode, t.nodeName) || this.rootNode),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (e.geometry.isBufferGeometry) {
          if (!e.geometry.morphAttributes) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
            return;
          }
          e.morphTargetDictionary[r] !== void 0 &&
            (r = e.morphTargetDictionary[r]);
        } else {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
            this
          );
          return;
        }
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = r);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
ot.Composite = xy;
ot.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
ot.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
ot.prototype.GetterByBindingType = [
  ot.prototype._getValue_direct,
  ot.prototype._getValue_array,
  ot.prototype._getValue_arrayElement,
  ot.prototype._getValue_toArray,
];
ot.prototype.SetterByBindingTypeAndVersioning = [
  [
    ot.prototype._setValue_direct,
    ot.prototype._setValue_direct_setNeedsUpdate,
    ot.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    ot.prototype._setValue_array,
    ot.prototype._setValue_array_setNeedsUpdate,
    ot.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    ot.prototype._setValue_arrayElement,
    ot.prototype._setValue_arrayElement_setNeedsUpdate,
    ot.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    ot.prototype._setValue_fromArray,
    ot.prototype._setValue_fromArray_setNeedsUpdate,
    ot.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class yy {
  constructor(e, t, n = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = n),
      (this.blendMode = i);
    const r = t.tracks,
      o = r.length,
      a = new Array(o),
      l = { endingStart: lr, endingEnd: lr };
    for (let c = 0; c !== o; ++c) {
      const h = r[c].createInterpolant(null);
      (a[c] = h), (h.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = np),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if ((e.fadeOut(t), this.fadeIn(t), n)) {
      const i = this._clip.duration,
        r = e._clip.duration,
        o = r / i,
        a = i / r;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer,
      r = i.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return (l[0] = r), (l[1] = r + n), (c[0] = e / o), (c[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const l = (e - r) * n;
      if (l < 0 || n === 0) return;
      (this._startTime = null), (t = n * l);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case Mu:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(o), c[h].accumulateAdditive(a);
          break;
        case Pl:
        default:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(o), c[h].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      n !== null &&
        ((t *= n.evaluate(e)[0]),
        e > n.parameterPositions[1] &&
          (this.stopWarping(),
          t === 0 ? (this.paused = !0) : (this.timeScale = t)));
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      n = this.loop;
    let i = this.time + e,
      r = this._loopCount;
    const o = n === ip;
    if (e === 0) return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
    if (n === tp) {
      r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (r === -1 &&
          (e >= 0
            ? ((r = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        i >= t || i < 0)
      ) {
        const a = Math.floor(i / t);
        (i -= t * a), (r += Math.abs(a));
        const l = this.repetitions - r;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = r),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = i;
      if (o && (r & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = cr), (i.endingEnd = cr))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? cr : lr)
          : (i.endingStart = Co),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? cr : lr) : (i.endingEnd = Co));
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer,
      r = i.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = r), (l[0] = t), (a[1] = r + e), (l[1] = n), this;
  }
}
class _y extends _i {
  constructor(e) {
    super();
    (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root,
      i = e._clip.tracks,
      r = i.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = n.uuid,
      c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && ((h = {}), (c[l] = h));
    for (let u = 0; u !== r; ++u) {
      const d = i[u],
        f = d.name;
      let m = h[f];
      if (m !== void 0) ++m.referenceCount, (o[u] = m);
      else {
        if (((m = o[u]), m !== void 0)) {
          m._cacheIndex === null &&
            (++m.referenceCount, this._addInactiveBinding(m, l, f));
          continue;
        }
        const v = t && t._propertyBindings[u].binding.parsedPath;
        (m = new cy(ot.create(n, f, v), d.ValueTypeName, d.getValueSize())),
          ++m.referenceCount,
          this._addInactiveBinding(m, l, f),
          (o[u] = m);
      }
      a[u].resultBuffer = m.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          r = this._actionsByClip[i];
        this._bindAction(e, r && r.knownActions[0]),
          this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        --r.useCount === 0 &&
          (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions,
      r = this._actionsByClip;
    let o = r[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (r[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      n = t[t.length - 1],
      i = e._cacheIndex;
    (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
    const r = e._clip.uuid,
      o = this._actionsByClip,
      a = o[r],
      l = a.knownActions,
      c = l[l.length - 1],
      h = e._byClipCacheIndex;
    (c._byClipCacheIndex = h),
      (l[h] = c),
      l.pop(),
      (e._byClipCacheIndex = null);
    const u = a.actionByRoot,
      d = (e._localRoot || this._root).uuid;
    delete u[d],
      l.length === 0 && delete o[r],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const r = t[n];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = this._nActiveActions++,
      r = t[i];
    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
  }
  _takeBackAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = --this._nActiveActions,
      r = t[i];
    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
  }
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName,
      r = this._bindings;
    let o = i[t];
    o === void 0 && ((o = {}), (i[t] = o)),
      (o[n] = e),
      (e._cacheIndex = r.length),
      r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      n = e.binding,
      i = n.rootNode.uuid,
      r = n.path,
      o = this._bindingsByRootAndName,
      a = o[i],
      l = t[t.length - 1],
      c = e._cacheIndex;
    (l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete a[r],
      Object.keys(a).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = this._nActiveBindings++,
      r = t[i];
    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = --this._nActiveBindings,
      r = t[i];
    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let n = e[t];
    return (
      n === void 0 &&
        ((n = new hd(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (n.__cacheIndex = t),
        (e[t] = n)),
      n
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      n = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      r = t[i];
    (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
  }
  clipAction(e, t, n) {
    const i = t || this._root,
      r = i.uuid;
    let o = typeof e == "string" ? Po.findByName(i, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let c = null;
    if (
      (n === void 0 && (o !== null ? (n = o.blendMode) : (n = Pl)),
      l !== void 0)
    ) {
      const u = l.actionByRoot[r];
      if (u !== void 0 && u.blendMode === n) return u;
      (c = l.knownActions[0]), o === null && (o = c._clip);
    }
    if (o === null) return null;
    const h = new yy(this, o, t, n);
    return this._bindAction(h, c), this._addInactiveAction(h, a, r), h;
  }
  existingAction(e, t) {
    const n = t || this._root,
      i = n.uuid,
      r = typeof e == "string" ? Po.findByName(n, e) : e,
      o = r ? r.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n) e[n].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      n = this._nActiveActions,
      i = (this.time += e),
      r = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let c = 0; c !== n; ++c) t[c]._update(i, e, r, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) a[c].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      n = e.uuid,
      i = this._actionsByClip,
      r = i[n];
    if (r !== void 0) {
      const o = r.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const h = c._cacheIndex,
          u = t[t.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (u._cacheIndex = h),
          (t[h] = u),
          t.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[n];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      n = this._actionsByClip;
    for (const o in n) {
      const a = n[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      r = i[t];
    if (r !== void 0)
      for (const o in r) {
        const a = r[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
_y.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class wy extends Pr {
  constructor(e, t, n = 1) {
    super(e, t);
    this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
wy.prototype.isInstancedInterleavedBuffer = !0;
class Gh {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)),
          (this.phi = Math.acos(Kt(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Vh = new P();
class aw extends at {
  constructor(e, t) {
    super();
    (this.light = e),
      this.light.updateMatrixWorld(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t);
    const n = new tt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const c = (o / l) * Math.PI * 2,
        h = (a / l) * Math.PI * 2;
      i.push(Math.cos(c), Math.sin(c), 1, Math.cos(h), Math.sin(h), 1);
    }
    n.setAttribute("position", new Je(i, 3));
    const r = new Nn({ fog: !1, toneMapped: !1 });
    (this.cone = new Ir(n, r)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      Vh.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(Vh),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const si = new P(),
  mo = new be(),
  ka = new be();
class by extends Ir {
  constructor(e) {
    const t = _d(e),
      n = new tt(),
      i = [],
      r = [],
      o = new ye(0, 0, 1),
      a = new ye(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.parent &&
        h.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        r.push(o.r, o.g, o.b),
        r.push(a.r, a.g, a.b));
    }
    n.setAttribute("position", new Je(i, 3)),
      n.setAttribute("color", new Je(r, 3));
    const l = new Nn({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(n, l);
    (this.type = "SkeletonHelper"),
      (this.isSkeletonHelper = !0),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      n = this.geometry,
      i = n.getAttribute("position");
    ka.copy(this.root.matrixWorld).invert();
    for (let r = 0, o = 0; r < t.length; r++) {
      const a = t[r];
      a.parent &&
        a.parent.isBone &&
        (mo.multiplyMatrices(ka, a.matrixWorld),
        si.setFromMatrixPosition(mo),
        i.setXYZ(o, si.x, si.y, si.z),
        mo.multiplyMatrices(ka, a.parent.matrixWorld),
        si.setFromMatrixPosition(mo),
        i.setXYZ(o + 1, si.x, si.y, si.z),
        (o += 2));
    }
    (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
}
function _d(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push.apply(e, _d(s.children[t]));
  return e;
}
class My extends Ir {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    (n = new ye(n)), (i = new ye(i));
    const r = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      c = [];
    for (let d = 0, f = 0, m = -a; d <= t; d++, m += o) {
      l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
      const v = d === r ? n : i;
      v.toArray(c, f),
        (f += 3),
        v.toArray(c, f),
        (f += 3),
        v.toArray(c, f),
        (f += 3),
        v.toArray(c, f),
        (f += 3);
    }
    const h = new tt();
    h.setAttribute("position", new Je(l, 3)),
      h.setAttribute("color", new Je(c, 3));
    const u = new Nn({ vertexColors: !0, toneMapped: !1 });
    super(h, u);
    this.type = "GridHelper";
  }
}
const go = new P(),
  Tt = new Vo();
class lw extends Ir {
  constructor(e) {
    const t = new tt(),
      n = new Nn({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      r = [],
      o = {},
      a = new ye(16755200),
      l = new ye(16711680),
      c = new ye(43775),
      h = new ye(16777215),
      u = new ye(3355443);
    d("n1", "n2", a),
      d("n2", "n4", a),
      d("n4", "n3", a),
      d("n3", "n1", a),
      d("f1", "f2", a),
      d("f2", "f4", a),
      d("f4", "f3", a),
      d("f3", "f1", a),
      d("n1", "f1", a),
      d("n2", "f2", a),
      d("n3", "f3", a),
      d("n4", "f4", a),
      d("p", "n1", l),
      d("p", "n2", l),
      d("p", "n3", l),
      d("p", "n4", l),
      d("u1", "u2", c),
      d("u2", "u3", c),
      d("u3", "u1", c),
      d("c", "t", h),
      d("p", "c", u),
      d("cn1", "cn2", u),
      d("cn3", "cn4", u),
      d("cf1", "cf2", u),
      d("cf3", "cf4", u);
    function d(m, v, y) {
      f(m, y), f(v, y);
    }
    function f(m, v) {
      i.push(0, 0, 0),
        r.push(v.r, v.g, v.b),
        o[m] === void 0 && (o[m] = []),
        o[m].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Je(i, 3)),
      t.setAttribute("color", new Je(r, 3));
    super(t, n);
    (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      n = 1,
      i = 1;
    Tt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Lt("c", t, e, Tt, 0, 0, -1),
      Lt("t", t, e, Tt, 0, 0, 1),
      Lt("n1", t, e, Tt, -n, -i, -1),
      Lt("n2", t, e, Tt, n, -i, -1),
      Lt("n3", t, e, Tt, -n, i, -1),
      Lt("n4", t, e, Tt, n, i, -1),
      Lt("f1", t, e, Tt, -n, -i, 1),
      Lt("f2", t, e, Tt, n, -i, 1),
      Lt("f3", t, e, Tt, -n, i, 1),
      Lt("f4", t, e, Tt, n, i, 1),
      Lt("u1", t, e, Tt, n * 0.7, i * 1.1, -1),
      Lt("u2", t, e, Tt, -n * 0.7, i * 1.1, -1),
      Lt("u3", t, e, Tt, 0, i * 2, -1),
      Lt("cf1", t, e, Tt, -n, 0, 1),
      Lt("cf2", t, e, Tt, n, 0, 1),
      Lt("cf3", t, e, Tt, 0, -i, 1),
      Lt("cf4", t, e, Tt, 0, i, 1),
      Lt("cn1", t, e, Tt, -n, 0, -1),
      Lt("cn2", t, e, Tt, n, 0, -1),
      Lt("cn3", t, e, Tt, 0, -i, -1),
      Lt("cn4", t, e, Tt, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Lt(s, e, t, n, i, r, o) {
  go.set(i, r, o).unproject(n);
  const a = e[s];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, h = a.length; c < h; c++) l.setXYZ(a[c], go.x, go.y, go.z);
  }
}
const wd = new Float32Array(1),
  Sy = new Int32Array(wd.buffer);
class dr {
  static toHalfFloat(e) {
    e > 65504 &&
      (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."),
      (e = 65504)),
      (wd[0] = e);
    const t = Sy[0];
    let n = (t >> 16) & 32768,
      i = (t >> 12) & 2047;
    const r = (t >> 23) & 255;
    return r < 103
      ? n
      : r > 142
      ? ((n |= 31744), (n |= (r == 255 ? 0 : 1) && t & 8388607), n)
      : r < 113
      ? ((i |= 2048), (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)), n)
      : ((n |= ((r - 112) << 10) | (i >> 1)), (n += i & 1), n);
  }
}
ln.create = function (s, e) {
  return (
    console.log("THREE.Curve.create() has been deprecated"),
    (s.prototype = Object.create(ln.prototype)),
    (s.prototype.constructor = s),
    (s.prototype.getPoint = e),
    s
  );
};
pl.prototype.fromPoints = function (s) {
  return (
    console.warn(
      "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
    ),
    this.setFromPoints(s)
  );
};
My.prototype.setColors = function () {
  console.error(
    "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
  );
};
by.prototype.update = function () {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
cn.prototype.extractUrlBase = function (s) {
  return (
    console.warn(
      "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
    ),
    Tn.extractUrlBase(s)
  );
};
cn.Handlers = {
  add: function () {
    console.error(
      "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
    );
  },
  get: function () {
    console.error(
      "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
    );
  },
};
_n.prototype.center = function (s) {
  return (
    console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
    this.getCenter(s)
  );
};
_n.prototype.empty = function () {
  return (
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
  );
};
_n.prototype.isIntersectionBox = function (s) {
  return (
    console.warn(
      "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
    ),
    this.intersectsBox(s)
  );
};
_n.prototype.isIntersectionSphere = function (s) {
  return (
    console.warn(
      "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
    ),
    this.intersectsSphere(s)
  );
};
_n.prototype.size = function (s) {
  return (
    console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
    this.getSize(s)
  );
};
mn.prototype.toVector3 = function () {
  console.error(
    "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
  );
};
Fi.prototype.empty = function () {
  return (
    console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
  );
};
Xo.prototype.setFromMatrix = function (s) {
  return (
    console.warn(
      "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
    ),
    this.setFromProjectionMatrix(s)
  );
};
Gt.prototype.flattenToArrayOffset = function (s, e) {
  return (
    console.warn(
      "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
    ),
    this.toArray(s, e)
  );
};
Gt.prototype.multiplyVector3 = function (s) {
  return (
    console.warn(
      "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
    ),
    s.applyMatrix3(this)
  );
};
Gt.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Gt.prototype.applyToBufferAttribute = function (s) {
  return (
    console.warn(
      "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
    ),
    s.applyMatrix3(this)
  );
};
Gt.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Gt.prototype.getInverse = function (s) {
  return (
    console.warn(
      "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
    ),
    this.copy(s).invert()
  );
};
be.prototype.extractPosition = function (s) {
  return (
    console.warn(
      "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
    ),
    this.copyPosition(s)
  );
};
be.prototype.flattenToArrayOffset = function (s, e) {
  return (
    console.warn(
      "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
    ),
    this.toArray(s, e)
  );
};
be.prototype.getPosition = function () {
  return (
    console.warn(
      "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
    ),
    new P().setFromMatrixColumn(this, 3)
  );
};
be.prototype.setRotationFromQuaternion = function (s) {
  return (
    console.warn(
      "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
    ),
    this.makeRotationFromQuaternion(s)
  );
};
be.prototype.multiplyToArray = function () {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
be.prototype.multiplyVector3 = function (s) {
  return (
    console.warn(
      "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    s.applyMatrix4(this)
  );
};
be.prototype.multiplyVector4 = function (s) {
  return (
    console.warn(
      "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    s.applyMatrix4(this)
  );
};
be.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
be.prototype.rotateAxis = function (s) {
  console.warn(
    "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
  ),
    s.transformDirection(this);
};
be.prototype.crossVector = function (s) {
  return (
    console.warn(
      "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    s.applyMatrix4(this)
  );
};
be.prototype.translate = function () {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
be.prototype.rotateX = function () {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
be.prototype.rotateY = function () {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
be.prototype.rotateZ = function () {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
be.prototype.rotateByAxis = function () {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
be.prototype.applyToBufferAttribute = function (s) {
  return (
    console.warn(
      "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
    ),
    s.applyMatrix4(this)
  );
};
be.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
be.prototype.makeFrustum = function (s, e, t, n, i, r) {
  return (
    console.warn(
      "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
    ),
    this.makePerspective(s, e, n, t, i, r)
  );
};
be.prototype.getInverse = function (s) {
  return (
    console.warn(
      "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
    ),
    this.copy(s).invert()
  );
};
Xn.prototype.isIntersectionLine = function (s) {
  return (
    console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ),
    this.intersectsLine(s)
  );
};
Dt.prototype.multiplyVector3 = function (s) {
  return (
    console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ),
    s.applyQuaternion(this)
  );
};
Dt.prototype.inverse = function () {
  return (
    console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
    this.invert()
  );
};
Rr.prototype.isIntersectionBox = function (s) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
    ),
    this.intersectsBox(s)
  );
};
Rr.prototype.isIntersectionPlane = function (s) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
    ),
    this.intersectsPlane(s)
  );
};
Rr.prototype.isIntersectionSphere = function (s) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
    ),
    this.intersectsSphere(s)
  );
};
Ft.prototype.area = function () {
  return (
    console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
    this.getArea()
  );
};
Ft.prototype.barycoordFromPoint = function (s, e) {
  return (
    console.warn(
      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
    ),
    this.getBarycoord(s, e)
  );
};
Ft.prototype.midpoint = function (s) {
  return (
    console.warn(
      "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
    ),
    this.getMidpoint(s)
  );
};
Ft.prototypenormal = function (s) {
  return (
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    this.getNormal(s)
  );
};
Ft.prototype.plane = function (s) {
  return (
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
    this.getPlane(s)
  );
};
Ft.barycoordFromPoint = function (s, e, t, n, i) {
  return (
    console.warn(
      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
    ),
    Ft.getBarycoord(s, e, t, n, i)
  );
};
Ft.normal = function (s, e, t, n) {
  return (
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    Ft.getNormal(s, e, t, n)
  );
};
Ls.prototype.extractAllPoints = function (s) {
  return (
    console.warn(
      "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
    ),
    this.extractPoints(s)
  );
};
Ls.prototype.extrude = function (s) {
  return (
    console.warn(
      "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
    ),
    new Dr(this, s)
  );
};
Ls.prototype.makeGeometry = function (s) {
  return (
    console.warn(
      "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
    ),
    new ql(this, s)
  );
};
ae.prototype.fromAttribute = function (s, e, t) {
  return (
    console.warn(
      "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(s, e, t)
  );
};
ae.prototype.distanceToManhattan = function (s) {
  return (
    console.warn(
      "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
    ),
    this.manhattanDistanceTo(s)
  );
};
ae.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  );
};
P.prototype.setEulerFromRotationMatrix = function () {
  console.error(
    "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
  );
};
P.prototype.setEulerFromQuaternion = function () {
  console.error(
    "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
  );
};
P.prototype.getPositionFromMatrix = function (s) {
  return (
    console.warn(
      "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
    ),
    this.setFromMatrixPosition(s)
  );
};
P.prototype.getScaleFromMatrix = function (s) {
  return (
    console.warn(
      "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
    ),
    this.setFromMatrixScale(s)
  );
};
P.prototype.getColumnFromMatrix = function (s, e) {
  return (
    console.warn(
      "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
    ),
    this.setFromMatrixColumn(e, s)
  );
};
P.prototype.applyProjection = function (s) {
  return (
    console.warn(
      "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
    ),
    this.applyMatrix4(s)
  );
};
P.prototype.fromAttribute = function (s, e, t) {
  return (
    console.warn(
      "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(s, e, t)
  );
};
P.prototype.distanceToManhattan = function (s) {
  return (
    console.warn(
      "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
    ),
    this.manhattanDistanceTo(s)
  );
};
P.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  );
};
ct.prototype.fromAttribute = function (s, e, t) {
  return (
    console.warn(
      "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(s, e, t)
  );
};
ct.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  );
};
at.prototype.getChildByName = function (s) {
  return (
    console.warn(
      "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
    ),
    this.getObjectByName(s)
  );
};
at.prototype.renderDepth = function () {
  console.warn(
    "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
  );
};
at.prototype.translate = function (s, e) {
  return (
    console.warn(
      "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
    ),
    this.translateOnAxis(e, s)
  );
};
at.prototype.getWorldRotation = function () {
  console.error(
    "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
  );
};
at.prototype.applyMatrix = function (s) {
  return (
    console.warn(
      "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
    ),
    this.applyMatrix4(s)
  );
};
Object.defineProperties(at.prototype, {
  eulerOrder: {
    get: function () {
      return (
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        this.rotation.order
      );
    },
    set: function (s) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        (this.rotation.order = s);
    },
  },
  useQuaternion: {
    get: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      );
    },
    set: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      );
    },
  },
});
jt.prototype.setDrawMode = function () {
  console.error(
    "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
  );
};
Object.defineProperties(jt.prototype, {
  drawMode: {
    get: function () {
      return (
        console.error(
          "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
        ),
        rp
      );
    },
    set: function () {
      console.error(
        "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
      );
    },
  },
});
qo.prototype.initBones = function () {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Yt.prototype.setLens = function (s, e) {
  console.warn(
    "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
  ),
    e !== void 0 && (this.filmGauge = e),
    this.setFocalLength(s);
};
Object.defineProperties(Dn.prototype, {
  onlyShadow: {
    set: function () {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    },
  },
  shadowCameraFov: {
    set: function (s) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
        (this.shadow.camera.fov = s);
    },
  },
  shadowCameraLeft: {
    set: function (s) {
      console.warn(
        "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
      ),
        (this.shadow.camera.left = s);
    },
  },
  shadowCameraRight: {
    set: function (s) {
      console.warn(
        "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
      ),
        (this.shadow.camera.right = s);
    },
  },
  shadowCameraTop: {
    set: function (s) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
        (this.shadow.camera.top = s);
    },
  },
  shadowCameraBottom: {
    set: function (s) {
      console.warn(
        "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
      ),
        (this.shadow.camera.bottom = s);
    },
  },
  shadowCameraNear: {
    set: function (s) {
      console.warn(
        "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
      ),
        (this.shadow.camera.near = s);
    },
  },
  shadowCameraFar: {
    set: function (s) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
        (this.shadow.camera.far = s);
    },
  },
  shadowCameraVisible: {
    set: function () {
      console.warn(
        "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
      );
    },
  },
  shadowBias: {
    set: function (s) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
        (this.shadow.bias = s);
    },
  },
  shadowDarkness: {
    set: function () {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    },
  },
  shadowMapWidth: {
    set: function (s) {
      console.warn(
        "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
      ),
        (this.shadow.mapSize.width = s);
    },
  },
  shadowMapHeight: {
    set: function (s) {
      console.warn(
        "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
      ),
        (this.shadow.mapSize.height = s);
    },
  },
});
Object.defineProperties(St.prototype, {
  length: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ),
        this.array.length
      );
    },
  },
  dynamic: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
        ),
        this.usage === Ro
      );
    },
    set: function () {
      console.warn(
        "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
      ),
        this.setUsage(Ro);
    },
  },
});
St.prototype.setDynamic = function (s) {
  return (
    console.warn(
      "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
    ),
    this.setUsage(s === !0 ? Ro : ps),
    this
  );
};
(St.prototype.copyIndicesArray = function () {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}),
  (St.prototype.setArray = function () {
    console.error(
      "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
    );
  });
tt.prototype.addIndex = function (s) {
  console.warn(
    "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
  ),
    this.setIndex(s);
};
tt.prototype.addAttribute = function (s, e) {
  return (
    console.warn(
      "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
    ),
    !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
      ? (console.warn(
          "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
        ),
        this.setAttribute(s, new St(arguments[1], arguments[2])))
      : s === "index"
      ? (console.warn(
          "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
        ),
        this.setIndex(e),
        this)
      : this.setAttribute(s, e)
  );
};
tt.prototype.addDrawCall = function (s, e, t) {
  t !== void 0 &&
    console.warn(
      "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
    ),
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
    this.addGroup(s, e);
};
tt.prototype.clearDrawCalls = function () {
  console.warn(
    "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
  ),
    this.clearGroups();
};
tt.prototype.computeOffsets = function () {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
tt.prototype.removeAttribute = function (s) {
  return (
    console.warn(
      "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
    ),
    this.deleteAttribute(s)
  );
};
tt.prototype.applyMatrix = function (s) {
  return (
    console.warn(
      "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
    ),
    this.applyMatrix4(s)
  );
};
Object.defineProperties(tt.prototype, {
  drawcalls: {
    get: function () {
      return (
        console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ),
        this.groups
      );
    },
  },
  offsets: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ),
        this.groups
      );
    },
  },
});
Pr.prototype.setDynamic = function (s) {
  return (
    console.warn(
      "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
    ),
    this.setUsage(s === !0 ? Ro : ps),
    this
  );
};
Pr.prototype.setArray = function () {
  console.error(
    "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
  );
};
Dr.prototype.getArrays = function () {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
Dr.prototype.addShapeList = function () {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
Dr.prototype.addShape = function () {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Vu.prototype.dispose = function () {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Et.prototype, {
  wrapAround: {
    get: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
  },
  overdraw: {
    get: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
  },
  wrapRGB: {
    get: function () {
      return (
        console.warn("THREE.Material: .wrapRGB has been removed."), new ye()
      );
    },
  },
  shading: {
    get: function () {
      console.error(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      );
    },
    set: function (s) {
      console.warn(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      ),
        (this.flatShading = s === gu);
    },
  },
  stencilMask: {
    get: function () {
      return (
        console.warn(
          "THREE." +
            this.type +
            ": .stencilMask has been removed. Use .stencilFuncMask instead."
        ),
        this.stencilFuncMask
      );
    },
    set: function (s) {
      console.warn(
        "THREE." +
          this.type +
          ": .stencilMask has been removed. Use .stencilFuncMask instead."
      ),
        (this.stencilFuncMask = s);
    },
  },
  vertexTangents: {
    get: function () {
      console.warn(
        "THREE." + this.type + ": .vertexTangents has been removed."
      );
    },
    set: function () {
      console.warn(
        "THREE." + this.type + ": .vertexTangents has been removed."
      );
    },
  },
});
Object.defineProperties(Vt.prototype, {
  derivatives: {
    get: function () {
      return (
        console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ),
        this.extensions.derivatives
      );
    },
    set: function (s) {
      console.warn(
        "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
      ),
        (this.extensions.derivatives = s);
    },
  },
});
mt.prototype.clearTarget = function (s, e, t, n) {
  console.warn(
    "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
  ),
    this.setRenderTarget(s),
    this.clear(e, t, n);
};
mt.prototype.animate = function (s) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
    this.setAnimationLoop(s);
};
mt.prototype.getCurrentRenderTarget = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
    ),
    this.getRenderTarget()
  );
};
mt.prototype.getMaxAnisotropy = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
    ),
    this.capabilities.getMaxAnisotropy()
  );
};
mt.prototype.getPrecision = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
    ),
    this.capabilities.precision
  );
};
mt.prototype.resetGLState = function () {
  return (
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
    this.state.reset()
  );
};
mt.prototype.supportsFloatTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
    ),
    this.extensions.get("OES_texture_float")
  );
};
mt.prototype.supportsHalfFloatTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
    ),
    this.extensions.get("OES_texture_half_float")
  );
};
mt.prototype.supportsStandardDerivatives = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
    ),
    this.extensions.get("OES_standard_derivatives")
  );
};
mt.prototype.supportsCompressedTextureS3TC = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
    ),
    this.extensions.get("WEBGL_compressed_texture_s3tc")
  );
};
mt.prototype.supportsCompressedTexturePVRTC = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
    ),
    this.extensions.get("WEBGL_compressed_texture_pvrtc")
  );
};
mt.prototype.supportsBlendMinMax = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
    ),
    this.extensions.get("EXT_blend_minmax")
  );
};
mt.prototype.supportsVertexTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
    ),
    this.capabilities.vertexTextures
  );
};
mt.prototype.supportsInstancedArrays = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
    ),
    this.extensions.get("ANGLE_instanced_arrays")
  );
};
mt.prototype.enableScissorTest = function (s) {
  console.warn(
    "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
  ),
    this.setScissorTest(s);
};
mt.prototype.initMaterial = function () {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
mt.prototype.addPrePlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
mt.prototype.addPostPlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
mt.prototype.updateShadowMap = function () {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
mt.prototype.setFaceCulling = function () {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
mt.prototype.allocTextureUnit = function () {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
mt.prototype.setTexture = function () {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
mt.prototype.setTexture2D = function () {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
mt.prototype.setTextureCube = function () {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
mt.prototype.getActiveMipMapLevel = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
    ),
    this.getActiveMipmapLevel()
  );
};
Object.defineProperties(mt.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (s) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
      ),
        (this.shadowMap.enabled = s);
    },
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (s) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
      ),
        (this.shadowMap.type = s);
    },
  },
  shadowMapCullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },
  context: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
        ),
        this.getContext()
      );
    },
  },
  vr: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
        this.xr
      );
    },
  },
  gammaInput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
        ),
        !1
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
      );
    },
  },
  gammaOutput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
        ),
        !1
      );
    },
    set: function (s) {
      console.warn(
        "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
      ),
        (this.outputEncoding = s === !0 ? it : an);
    },
  },
  toneMappingWhitePoint: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
        ),
        1
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
      );
    },
  },
  gammaFactor: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
      );
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
    },
  },
});
Object.defineProperties(ku.prototype, {
  cullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },
  renderReverseSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
  },
  renderSingleSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
  },
});
Object.defineProperties(Bt.prototype, {
  wrapS: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        this.texture.wrapS
      );
    },
    set: function (s) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        (this.texture.wrapS = s);
    },
  },
  wrapT: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        this.texture.wrapT
      );
    },
    set: function (s) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        (this.texture.wrapT = s);
    },
  },
  magFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ),
        this.texture.magFilter
      );
    },
    set: function (s) {
      console.warn(
        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
      ),
        (this.texture.magFilter = s);
    },
  },
  minFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ),
        this.texture.minFilter
      );
    },
    set: function (s) {
      console.warn(
        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
      ),
        (this.texture.minFilter = s);
    },
  },
  anisotropy: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ),
        this.texture.anisotropy
      );
    },
    set: function (s) {
      console.warn(
        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
      ),
        (this.texture.anisotropy = s);
    },
  },
  offset: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ),
        this.texture.offset
      );
    },
    set: function (s) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
        (this.texture.offset = s);
    },
  },
  repeat: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ),
        this.texture.repeat
      );
    },
    set: function (s) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
        (this.texture.repeat = s);
    },
  },
  format: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ),
        this.texture.format
      );
    },
    set: function (s) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
        (this.texture.format = s);
    },
  },
  type: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        this.texture.type
      );
    },
    set: function (s) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        (this.texture.type = s);
    },
  },
  generateMipmaps: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ),
        this.texture.generateMipmaps
      );
    },
    set: function (s) {
      console.warn(
        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
      ),
        (this.texture.generateMipmaps = s);
    },
  },
});
ly.prototype.load = function (s) {
  console.warn(
    "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
  );
  const e = this;
  return (
    new ry().load(s, function (n) {
      e.setBuffer(n);
    }),
    this
  );
};
Nl.prototype.updateCubeMap = function (s, e) {
  return (
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(s, e)
  );
};
Nl.prototype.clear = function (s, e, t, n) {
  return (
    console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
    this.renderTarget.clear(s, e, t, n)
  );
};
Di.crossOrigin = void 0;
Di.loadTexture = function (s, e, t, n) {
  console.warn(
    "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
  );
  const i = new Zl();
  i.setCrossOrigin(this.crossOrigin);
  const r = i.load(s, t, void 0, n);
  return e && (r.mapping = e), r;
};
Di.loadTextureCube = function (s, e, t, n) {
  console.warn(
    "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
  );
  const i = new Qx();
  i.setCrossOrigin(this.crossOrigin);
  const r = i.load(s, t, void 0, n);
  return e && (r.mapping = e), r;
};
Di.loadCompressedTexture = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
  );
};
Di.loadCompressedTextureCube = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
  );
};
typeof __THREE_DEVTOOLS__ != "undefined" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Rl } })
  );
typeof window != "undefined" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Rl));
function Ha(s, e, t, n) {
  return new (t || (t = Promise))(function (i, r) {
    function o(c) {
      try {
        l(n.next(c));
      } catch (h) {
        r(h);
      }
    }
    function a(c) {
      try {
        l(n.throw(c));
      } catch (h) {
        r(h);
      }
    }
    function l(c) {
      var h;
      c.done
        ? i(c.value)
        : ((h = c.value),
          h instanceof t
            ? h
            : new t(function (u) {
                u(h);
              })).then(o, a);
    }
    l((n = n.apply(s, e || [])).next());
  });
}
const Ty = [
  "geforce 320m",
  "geforce 8600",
  "geforce 8600m gt",
  "geforce 8800 gs",
  "geforce 8800 gt",
  "geforce 9400",
  "geforce 9400m g",
  "geforce 9400m",
  "geforce 9600m gt",
  "geforce 9600m",
  "geforce fx go5200",
  "geforce gt 120",
  "geforce gt 130",
  "geforce gt 330m",
  "geforce gtx 285",
  "google swiftshader",
  "intel g41",
  "intel g45",
  "intel gma 4500mhd",
  "intel gma x3100",
  "intel hd 3000",
  "intel q45",
  "legacy",
  "mali-2",
  "mali-3",
  "mali-4",
  "quadro fx 1500",
  "quadro fx 4",
  "quadro fx 5",
  "radeon hd 2400",
  "radeon hd 2600",
  "radeon hd 4670",
  "radeon hd 4850",
  "radeon hd 4870",
  "radeon hd 5670",
  "radeon hd 5750",
  "radeon hd 6290",
  "radeon hd 6300",
  "radeon hd 6310",
  "radeon hd 6320",
  "radeon hd 6490m",
  "radeon hd 6630m",
  "radeon hd 6750m",
  "radeon hd 6770m",
  "radeon hd 6970m",
  "sgx 543",
  "sgx543",
];
function Wh(s) {
  return (s = s
    .toLowerCase()
    .replace(/^angle ?\((.+)\)*$/, "$1")
    .replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, ""));
}
const bd = typeof window == "undefined",
  li = (() => {
    if (bd) return;
    const { userAgent: s, platform: e, maxTouchPoints: t } = window.navigator,
      n = /(iphone|ipod|ipad)/i.test(s),
      i = e === "iPad" || (e === "MacIntel" && t > 0 && !window.MSStream);
    return {
      isIpad: i,
      isMobile: /android/i.test(s) || n || i,
      isSafari12: /Version\/12.+Safari/.test(s),
    };
  })();
function Ey(s, e, t) {
  if (!t) return [e];
  const n = (function (c) {
      const h = `
    precision highp float;
    attribute vec3 aPosition;
    varying float vvv;
    void main() {
      vvv = 0.31622776601683794;
      gl_Position = vec4(aPosition, 1.0);
    }
  `,
        u = `
    precision highp float;
    varying float vvv;
    void main() {
      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;
      enc = fract(enc);
      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
      gl_FragColor = enc;
    }
  `,
        d = c.createShader(35633),
        f = c.createShader(35632),
        m = c.createProgram();
      if (!(f && d && m)) return;
      c.shaderSource(d, h),
        c.shaderSource(f, u),
        c.compileShader(d),
        c.compileShader(f),
        c.attachShader(m, d),
        c.attachShader(m, f),
        c.linkProgram(m),
        c.detachShader(m, d),
        c.detachShader(m, f),
        c.deleteShader(d),
        c.deleteShader(f),
        c.useProgram(m);
      const v = c.createBuffer();
      c.bindBuffer(34962, v),
        c.bufferData(
          34962,
          new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
          35044
        );
      const y = c.getAttribLocation(m, "aPosition");
      c.vertexAttribPointer(y, 3, 5126, !1, 0, 0),
        c.enableVertexAttribArray(y),
        c.clearColor(1, 1, 1, 1),
        c.clear(16384),
        c.viewport(0, 0, 1, 1),
        c.drawArrays(4, 0, 3);
      const p = new Uint8Array(4);
      return (
        c.readPixels(0, 0, 1, 1, 6408, 5121, p),
        c.deleteProgram(m),
        c.deleteBuffer(v),
        p.join("")
      );
    })(s),
    i = "801621810",
    r = "8016218135",
    o = "80162181161",
    a = (li == null ? void 0 : li.isIpad)
      ? [
          ["a7", o, 12],
          ["a8", r, 15],
          ["a8x", r, 15],
          ["a9", r, 15],
          ["a9x", r, 15],
          ["a10", r, 15],
          ["a10x", r, 15],
          ["a12", i, 15],
          ["a12x", i, 15],
          ["a12z", i, 15],
          ["a14", i, 15],
          ["m1", i, 15],
        ]
      : [
          ["a7", o, 12],
          ["a8", r, 12],
          ["a9", r, 15],
          ["a10", r, 15],
          ["a11", i, 15],
          ["a12", i, 15],
          ["a13", i, 15],
          ["a14", i, 15],
        ];
  let l;
  return (
    n === "80162181255"
      ? (l = a.filter(([, , c]) => c >= 14))
      : ((l = a.filter(([, c]) => c === n)), l.length || (l = a)),
    l.map(([c]) => `apple ${c} gpu`)
  );
}
const Ga = [],
  Xh = [];
function Ay(s, e) {
  if (s === e) return 0;
  const t = s;
  s.length > e.length && ((s = e), (e = t));
  let n = s.length,
    i = e.length;
  for (; n > 0 && s.charCodeAt(~-n) === e.charCodeAt(~-i); ) n--, i--;
  let r,
    o = 0;
  for (; o < n && s.charCodeAt(o) === e.charCodeAt(o); ) o++;
  if (((n -= o), (i -= o), n === 0)) return i;
  let a,
    l,
    c = 0,
    h = 0,
    u = 0;
  for (; h < n; ) (Xh[h] = s.charCodeAt(o + h)), (Ga[h] = ++h);
  for (; u < i; )
    for (r = e.charCodeAt(o + u), a = u++, c = u, h = 0; h < n; h++)
      (l = r === Xh[h] ? a : a + 1),
        (a = Ga[h]),
        (c = Ga[h] = a > c ? (l > c ? c + 1 : l) : l > a ? a + 1 : l);
  return c;
}
function Cy(s) {
  return s != null;
}
class jh extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, new.target.prototype);
  }
}
const cw = ({
  mobileTiers: s = [0, 15, 30, 60],
  desktopTiers: e = [0, 15, 30, 60],
  override: t = {},
  glContext: n,
  failIfMajorPerformanceCaveat: i = !1,
  benchmarksURL: r = "https://unpkg.com/detect-gpu@4.0.14/dist/benchmarks",
} = {}) =>
  Ha(void 0, void 0, void 0, function* () {
    const o = {};
    if (bd) return { tier: 0, type: "SSR" };
    const {
      isIpad: a = !!(li == null ? void 0 : li.isIpad),
      isMobile: l = !!(li == null ? void 0 : li.isMobile),
      screenSize: c = window.screen,
      loadBenchmarks: h = (_) =>
        Ha(void 0, void 0, void 0, function* () {
          const E = yield fetch(`${r}/${_}`).then((L) => L.json());
          if (parseInt(E.shift().split(".")[0], 10) < 4)
            throw new jh(
              "Detect GPU benchmark data is out of date. Please update to version 4x"
            );
          return E;
        }),
    } = t;
    let { renderer: u } = t;
    const d = (_, E, L, D, V) => ({
      device: V,
      fps: D,
      gpu: L,
      isMobile: l,
      tier: _,
      type: E,
    });
    let f,
      m = "";
    if (u) (u = Wh(u)), (f = [u]);
    else {
      const _ =
        n ||
        (function (L, D = !1) {
          const V = {
            alpha: !1,
            antialias: !1,
            depth: !1,
            failIfMajorPerformanceCaveat: D,
            powerPreference: "high-performance",
            stencil: !1,
          };
          L && delete V.powerPreference;
          const F = window.document.createElement("canvas"),
            M =
              F.getContext("webgl", V) || F.getContext("experimental-webgl", V);
          return M != null ? M : void 0;
        })(li == null ? void 0 : li.isSafari12, i);
      if (!_) return d(0, "WEBGL_UNSUPPORTED");
      const E = _.getExtension("WEBGL_debug_renderer_info");
      if ((E && (u = _.getParameter(E.UNMASKED_RENDERER_WEBGL)), !u))
        return d(1, "FALLBACK");
      (m = u),
        (u = Wh(u)),
        (f = (function (L, D, V) {
          return D === "apple gpu" ? Ey(L, D, V) : [D];
        })(_, u, l));
    }
    const v = (yield Promise.all(
      f.map((_) =>
        Ha(void 0, void 0, void 0, function* () {
          var E;
          const L = ((ee) => {
            const Me = l
              ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr"]
              : ["intel", "apple", "amd", "radeon", "nvidia", "geforce"];
            for (const Be of Me) if (ee.includes(Be)) return Be;
          })(_);
          if (!L) return;
          const D = `${l ? "m" : "d"}-${L}${a ? "-ipad" : ""}.json`,
            V = (o[D] = (E = o[D]) !== null && E !== void 0 ? E : h(D));
          let F;
          try {
            F = yield V;
          } catch (ee) {
            if (ee instanceof jh) throw ee;
            return;
          }
          const M = (function (ee) {
            var Me;
            const Be =
              (ee = ee.replace(/\([^)]+\)/, "")).match(/\d+/) ||
              ee.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
            return (Me =
              Be == null ? void 0 : Be.join("").replace(/\W|amd/g, "")) !==
              null && Me !== void 0
              ? Me
              : "";
          })(_);
          let A = F.filter(([, ee]) => ee === M);
          A.length || (A = F.filter(([ee]) => ee.includes(_)));
          const N = A.length;
          if (N === 0) return;
          let O,
            [H, , , G] =
              N > 1
                ? A.map((ee) => [ee, Ay(_, ee[0])]).sort(
                    ([, ee], [, Me]) => ee - Me
                  )[0][0]
                : A[0],
            W = Number.MAX_VALUE;
          const { devicePixelRatio: k } = window,
            Q = c.width * k * c.height * k;
          for (const ee of G) {
            const [Me, Be] = ee,
              Re = Me * Be,
              Z = Math.abs(Q - Re);
            Z < W && ((W = Z), (O = ee));
          }
          if (!O) return;
          const [, , ie, re] = O;
          return [W, ie, H, re];
        })
      )
    ))
      .filter(Cy)
      .sort(([_ = Number.MAX_VALUE, E], [L = Number.MAX_VALUE, D]) =>
        _ === L ? E - D : _ - L
      );
    if (!v.length) {
      const _ = Ty.find((E) => u.includes(E));
      return _ ? d(0, "BLOCKLISTED", _) : d(1, "FALLBACK", `${u} (${m})`);
    }
    const [, y, p, g] = v[0];
    if (y === -1) return d(0, "BLOCKLISTED", p, y, g);
    const w = l ? s : e;
    let b = 0;
    for (let _ = 0; _ < w.length; _++) y >= w[_] && (b = _);
    return d(b, "BENCHMARK", p, y, g);
  });
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.16.1
 * @author George Michael Brower
 * @license MIT
 */ class In {
  constructor(e, t, n, i, r = "div") {
    (this.parent = e),
      (this.object = t),
      (this.property = n),
      (this._disabled = !1),
      (this.initialValue = this.getValue()),
      (this.domElement = document.createElement("div")),
      this.domElement.classList.add("controller"),
      this.domElement.classList.add(i),
      (this.$name = document.createElement("div")),
      this.$name.classList.add("name"),
      (In.nextNameID = In.nextNameID || 0),
      (this.$name.id = `lil-gui-name-${++In.nextNameID}`),
      (this.$widget = document.createElement(r)),
      this.$widget.classList.add("widget"),
      (this.$disable = this.$widget),
      this.domElement.appendChild(this.$name),
      this.domElement.appendChild(this.$widget),
      this.parent.children.push(this),
      this.parent.controllers.push(this),
      this.parent.$children.appendChild(this.domElement),
      (this._listenCallback = this._listenCallback.bind(this)),
      this.name(n);
  }
  name(e) {
    return (this._name = e), (this.$name.innerHTML = e), this;
  }
  onChange(e) {
    return (this._onChange = e), this;
  }
  _callOnChange() {
    this.parent._callOnChange(this),
      this._onChange !== void 0 && this._onChange.call(this, this.getValue()),
      (this._changed = !0);
  }
  onFinishChange(e) {
    return (this._onFinishChange = e), this;
  }
  _callOnFinishChange() {
    this._changed &&
      (this.parent._callOnFinishChange(this),
      this._onFinishChange !== void 0 &&
        this._onFinishChange.call(this, this.getValue())),
      (this._changed = !1);
  }
  reset() {
    return this.setValue(this.initialValue), this._callOnFinishChange(), this;
  }
  enable(e = !0) {
    return this.disable(!e);
  }
  disable(e = !0) {
    return e === this._disabled
      ? this
      : ((this._disabled = e),
        this.domElement.classList.toggle("disabled", e),
        this.$disable.toggleAttribute("disabled", e),
        this);
  }
  options(e) {
    const t = this.parent.add(this.object, this.property, e);
    return t.name(this._name), this.destroy(), t;
  }
  min(e) {
    return this;
  }
  max(e) {
    return this;
  }
  step(e) {
    return this;
  }
  listen(e = !0) {
    return (
      (this._listening = e),
      this._listenCallbackID !== void 0 &&
        (cancelAnimationFrame(this._listenCallbackID),
        (this._listenCallbackID = void 0)),
      this._listening && this._listenCallback(),
      this
    );
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback);
    const e = this.save();
    e !== this._listenPrevValue && this.updateDisplay(),
      (this._listenPrevValue = e);
  }
  getValue() {
    return this.object[this.property];
  }
  setValue(e) {
    return (
      (this.object[this.property] = e),
      this._callOnChange(),
      this.updateDisplay(),
      this
    );
  }
  updateDisplay() {
    return this;
  }
  load(e) {
    return this.setValue(e), this._callOnFinishChange(), this;
  }
  save() {
    return this.getValue();
  }
  destroy() {
    this.listen(!1),
      this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1),
      this.parent.$children.removeChild(this.domElement);
  }
}
class Ry extends In {
  constructor(e, t, n) {
    super(e, t, n, "boolean", "label");
    (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "checkbox"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$widget.appendChild(this.$input),
      this.$input.addEventListener("change", () => {
        this.setValue(this.$input.checked), this._callOnFinishChange();
      }),
      (this.$disable = this.$input),
      this.updateDisplay();
  }
  updateDisplay() {
    return (this.$input.checked = this.getValue()), this;
  }
}
function vl(s) {
  let e, t;
  return (
    (e = s.match(/(#|0x)?([a-f0-9]{6})/i))
      ? (t = e[2])
      : (e = s.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))
      ? (t =
          parseInt(e[1]).toString(16).padStart(2, 0) +
          parseInt(e[2]).toString(16).padStart(2, 0) +
          parseInt(e[3]).toString(16).padStart(2, 0))
      : (e = s.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) &&
        (t = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
    t ? "#" + t : !1
  );
}
const Ly = {
    isPrimitive: !0,
    match: (s) => typeof s == "string",
    fromHexString: vl,
    toHexString: vl,
  },
  bs = {
    isPrimitive: !0,
    match: (s) => typeof s == "number",
    fromHexString: (s) => parseInt(s.substring(1), 16),
    toHexString: (s) => "#" + s.toString(16).padStart(6, 0),
  },
  Py = {
    isPrimitive: !1,
    match: Array.isArray,
    fromHexString(s, e, t = 1) {
      const n = bs.fromHexString(s);
      (e[0] = (((n >> 16) & 255) / 255) * t),
        (e[1] = (((n >> 8) & 255) / 255) * t),
        (e[2] = ((n & 255) / 255) * t);
    },
    toHexString([s, e, t], n = 1) {
      n = 255 / n;
      const i = ((s * n) << 16) ^ ((e * n) << 8) ^ ((t * n) << 0);
      return bs.toHexString(i);
    },
  },
  Iy = {
    isPrimitive: !1,
    match: (s) => Object(s) === s,
    fromHexString(s, e, t = 1) {
      const n = bs.fromHexString(s);
      (e.r = (((n >> 16) & 255) / 255) * t),
        (e.g = (((n >> 8) & 255) / 255) * t),
        (e.b = ((n & 255) / 255) * t);
    },
    toHexString({ r: s, g: e, b: t }, n = 1) {
      n = 255 / n;
      const i = ((s * n) << 16) ^ ((e * n) << 8) ^ ((t * n) << 0);
      return bs.toHexString(i);
    },
  },
  Dy = [Ly, bs, Py, Iy];
function Fy(s) {
  return Dy.find((e) => e.match(s));
}
class Ny extends In {
  constructor(e, t, n, i) {
    super(e, t, n, "color");
    (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "color"),
      this.$input.setAttribute("tabindex", -1),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      (this.$text = document.createElement("input")),
      this.$text.setAttribute("type", "text"),
      this.$text.setAttribute("spellcheck", "false"),
      this.$text.setAttribute("aria-labelledby", this.$name.id),
      (this.$display = document.createElement("div")),
      this.$display.classList.add("display"),
      this.$display.appendChild(this.$input),
      this.$widget.appendChild(this.$display),
      this.$widget.appendChild(this.$text),
      (this._format = Fy(this.initialValue)),
      (this._rgbScale = i),
      (this._initialValueHexString = this.save()),
      (this._textFocused = !1),
      this.$input.addEventListener("input", () => {
        this._setValueFromHexString(this.$input.value);
      }),
      this.$input.addEventListener("blur", () => {
        this._callOnFinishChange();
      }),
      this.$text.addEventListener("input", () => {
        const r = vl(this.$text.value);
        r && this._setValueFromHexString(r);
      }),
      this.$text.addEventListener("focus", () => {
        (this._textFocused = !0), this.$text.select();
      }),
      this.$text.addEventListener("blur", () => {
        (this._textFocused = !1),
          this.updateDisplay(),
          this._callOnFinishChange();
      }),
      (this.$disable = this.$text),
      this.updateDisplay();
  }
  reset() {
    return this._setValueFromHexString(this._initialValueHexString), this;
  }
  _setValueFromHexString(e) {
    if (this._format.isPrimitive) {
      const t = this._format.fromHexString(e);
      this.setValue(t);
    } else
      this._format.fromHexString(e, this.getValue(), this._rgbScale),
        this._callOnChange(),
        this.updateDisplay();
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale);
  }
  load(e) {
    return this._setValueFromHexString(e), this._callOnFinishChange(), this;
  }
  updateDisplay() {
    return (
      (this.$input.value = this._format.toHexString(
        this.getValue(),
        this._rgbScale
      )),
      this._textFocused || (this.$text.value = this.$input.value.substring(1)),
      (this.$display.style.backgroundColor = this.$input.value),
      this
    );
  }
}
class Va extends In {
  constructor(e, t, n) {
    super(e, t, n, "function");
    (this.$button = document.createElement("button")),
      this.$button.appendChild(this.$name),
      this.$widget.appendChild(this.$button),
      this.$button.addEventListener("click", (i) => {
        i.preventDefault(), this.getValue().call(this.object);
      }),
      this.$button.addEventListener("touchstart", () => {}, { passive: !0 }),
      (this.$disable = this.$button);
  }
}
class By extends In {
  constructor(e, t, n, i, r, o) {
    super(e, t, n, "number");
    this._initInput(), this.min(i), this.max(r);
    const a = o !== void 0;
    this.step(a ? o : this._getImplicitStep(), a), this.updateDisplay();
  }
  min(e) {
    return (this._min = e), this._onUpdateMinMax(), this;
  }
  max(e) {
    return (this._max = e), this._onUpdateMinMax(), this;
  }
  step(e, t = !0) {
    return (this._step = e), (this._stepExplicit = t), this;
  }
  updateDisplay() {
    const e = this.getValue();
    if (this._hasSlider) {
      let t = (e - this._min) / (this._max - this._min);
      (t = Math.max(0, Math.min(t, 1))),
        (this.$fill.style.width = t * 100 + "%");
    }
    return this._inputFocused || (this.$input.value = e), this;
  }
  _initInput() {
    (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "number"),
      this.$input.setAttribute("step", "any"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input);
    const e = () => {
        const p = parseFloat(this.$input.value);
        isNaN(p) || this.setValue(this._clamp(p));
      },
      t = (p) => {
        const g = parseFloat(this.$input.value);
        isNaN(g) ||
          (this._snapClampSetValue(g + p),
          (this.$input.value = this.getValue()));
      },
      n = (p) => {
        p.code === "Enter" && this.$input.blur(),
          p.code === "ArrowUp" &&
            (p.preventDefault(), t(this._step * this._arrowKeyMultiplier(p))),
          p.code === "ArrowDown" &&
            (p.preventDefault(),
            t(this._step * this._arrowKeyMultiplier(p) * -1));
      },
      i = (p) => {
        this._inputFocused &&
          (p.preventDefault(), t(this._step * this._normalizeMouseWheel(p)));
      };
    let r = !1,
      o,
      a,
      l,
      c,
      h;
    const u = 5,
      d = (p) => {
        (o = p.clientX),
          (a = l = p.clientY),
          (r = !0),
          (c = this.getValue()),
          (h = 0),
          window.addEventListener("mousemove", f),
          window.addEventListener("mouseup", m);
      },
      f = (p) => {
        if (r) {
          const g = p.clientX - o,
            w = p.clientY - a;
          Math.abs(w) > u
            ? (p.preventDefault(),
              this.$input.blur(),
              (r = !1),
              this._setDraggingStyle(!0, "vertical"))
            : Math.abs(g) > u && m();
        }
        r ||
          ((h -= (p.clientY - l) * this._step * this._arrowKeyMultiplier(p)),
          c + h > this._max
            ? (h = this._max - c)
            : c + h < this._min && (h = this._min - c),
          this._snapClampSetValue(c + h)),
          (l = p.clientY);
      },
      m = () => {
        this._setDraggingStyle(!1, "vertical"),
          this._callOnFinishChange(),
          window.removeEventListener("mousemove", f),
          window.removeEventListener("mouseup", m);
      },
      v = () => {
        this._inputFocused = !0;
      },
      y = () => {
        (this._inputFocused = !1),
          this.updateDisplay(),
          this._callOnFinishChange();
      };
    this.$input.addEventListener("input", e),
      this.$input.addEventListener("keydown", n),
      this.$input.addEventListener("wheel", i, { passive: !1 }),
      this.$input.addEventListener("mousedown", d),
      this.$input.addEventListener("focus", v),
      this.$input.addEventListener("blur", y);
  }
  _initSlider() {
    (this._hasSlider = !0),
      (this.$slider = document.createElement("div")),
      this.$slider.classList.add("slider"),
      (this.$fill = document.createElement("div")),
      this.$fill.classList.add("fill"),
      this.$slider.appendChild(this.$fill),
      this.$widget.insertBefore(this.$slider, this.$input),
      this.domElement.classList.add("hasSlider");
    const e = (p, g, w, b, _) => ((p - g) / (w - g)) * (_ - b) + b,
      t = (p) => {
        const g = this.$slider.getBoundingClientRect();
        let w = e(p, g.left, g.right, this._min, this._max);
        this._snapClampSetValue(w);
      },
      n = (p) => {
        this._setDraggingStyle(!0),
          t(p.clientX),
          window.addEventListener("mousemove", i),
          window.addEventListener("mouseup", r);
      },
      i = (p) => {
        t(p.clientX);
      },
      r = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(!1),
          window.removeEventListener("mousemove", i),
          window.removeEventListener("mouseup", r);
      };
    let o = !1,
      a,
      l;
    const c = (p) => {
        p.preventDefault(),
          this._setDraggingStyle(!0),
          t(p.touches[0].clientX),
          (o = !1);
      },
      h = (p) => {
        p.touches.length > 1 ||
          (this._hasScrollBar
            ? ((a = p.touches[0].clientX), (l = p.touches[0].clientY), (o = !0))
            : c(p),
          window.addEventListener("touchmove", u),
          window.addEventListener("touchend", d));
      },
      u = (p) => {
        if (o) {
          const g = p.touches[0].clientX - a,
            w = p.touches[0].clientY - l;
          Math.abs(g) > Math.abs(w)
            ? c(p)
            : (window.removeEventListener("touchmove", u),
              window.removeEventListener("touchend", d));
        } else p.preventDefault(), t(p.touches[0].clientX);
      },
      d = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(!1),
          window.removeEventListener("touchmove", u),
          window.removeEventListener("touchend", d);
      },
      f = this._callOnFinishChange.bind(this),
      m = 400;
    let v;
    const y = (p) => {
      if (Math.abs(p.deltaX) < Math.abs(p.deltaY) && this._hasScrollBar) return;
      p.preventDefault();
      const w = this._normalizeMouseWheel(p) * this._step;
      this._snapClampSetValue(this.getValue() + w),
        (this.$input.value = this.getValue()),
        clearTimeout(v),
        (v = setTimeout(f, m));
    };
    this.$slider.addEventListener("mousedown", n),
      this.$slider.addEventListener("touchstart", h, { passive: !1 }),
      this.$slider.addEventListener("wheel", y, { passive: !1 });
  }
  _setDraggingStyle(e, t = "horizontal") {
    this.$slider && this.$slider.classList.toggle("active", e),
      document.body.classList.toggle("lil-gui-dragging", e),
      document.body.classList.toggle(`lil-gui-${t}`, e);
  }
  _getImplicitStep() {
    return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : 0.1;
  }
  _onUpdateMinMax() {
    !this._hasSlider &&
      this._hasMin &&
      this._hasMax &&
      (this._stepExplicit || this.step(this._getImplicitStep(), !1),
      this._initSlider(),
      this.updateDisplay());
  }
  _normalizeMouseWheel(e) {
    let { deltaX: t, deltaY: n } = e;
    return (
      Math.floor(e.deltaY) !== e.deltaY &&
        e.wheelDelta &&
        ((t = 0),
        (n = -e.wheelDelta / 120),
        (n *= this._stepExplicit ? 1 : 10)),
      t + -n
    );
  }
  _arrowKeyMultiplier(e) {
    let t = this._stepExplicit ? 1 : 10;
    return e.shiftKey ? (t *= 10) : e.altKey && (t /= 10), t;
  }
  _snap(e) {
    const t = Math.round(e / this._step) * this._step;
    return parseFloat(t.toPrecision(15));
  }
  _clamp(e) {
    return (
      e < this._min && (e = this._min), e > this._max && (e = this._max), e
    );
  }
  _snapClampSetValue(e) {
    this.setValue(this._clamp(this._snap(e)));
  }
  get _hasScrollBar() {
    const e = this.parent.root.$children;
    return e.scrollHeight > e.clientHeight;
  }
  get _hasMin() {
    return this._min !== void 0;
  }
  get _hasMax() {
    return this._max !== void 0;
  }
}
class Oy extends In {
  constructor(e, t, n, i) {
    super(e, t, n, "option");
    (this.$select = document.createElement("select")),
      this.$select.setAttribute("aria-labelledby", this.$name.id),
      (this.$display = document.createElement("div")),
      this.$display.classList.add("display"),
      (this._values = Array.isArray(i) ? i : Object.values(i)),
      (this._names = Array.isArray(i) ? i : Object.keys(i)),
      this._names.forEach((r) => {
        const o = document.createElement("option");
        (o.innerHTML = r), this.$select.appendChild(o);
      }),
      this.$select.addEventListener("change", () => {
        this.setValue(this._values[this.$select.selectedIndex]),
          this._callOnFinishChange();
      }),
      this.$select.addEventListener("focus", () => {
        this.$display.classList.add("focus");
      }),
      this.$select.addEventListener("blur", () => {
        this.$display.classList.remove("focus");
      }),
      this.$widget.appendChild(this.$select),
      this.$widget.appendChild(this.$display),
      (this.$disable = this.$select),
      this.updateDisplay();
  }
  updateDisplay() {
    const e = this.getValue(),
      t = this._values.indexOf(e);
    return (
      (this.$select.selectedIndex = t),
      (this.$display.innerHTML = t === -1 ? e : this._names[t]),
      this
    );
  }
}
class Uy extends In {
  constructor(e, t, n) {
    super(e, t, n, "string");
    (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "text"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$input.addEventListener("input", () => {
        this.setValue(this.$input.value);
      }),
      this.$input.addEventListener("keydown", (i) => {
        i.code === "Enter" && this.$input.blur();
      }),
      this.$input.addEventListener("blur", () => {
        this._callOnFinishChange();
      }),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input),
      this.updateDisplay();
  }
  updateDisplay() {
    return (this.$input.value = this.getValue()), this;
  }
}
const zy = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  background-color: var(--background-color);
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean .widget {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "\u2195";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background-color: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background-color: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background-color: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "\u25BE";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "\u25B8";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui input {
  -webkit-tap-highlight-color: transparent;
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input::-webkit-outer-spin-button,
.lil-gui input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.lil-gui input[type=number] {
  -moz-appearance: textfield;
}
.lil-gui input[type=checkbox] {
  appearance: none;
  -webkit-appearance: none;
  height: var(--checkbox-size);
  width: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "\u2713";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  -webkit-tap-highlight-color: transparent;
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: 1px solid var(--widget-color);
  text-align: center;
  line-height: calc(var(--widget-height) - 4px);
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
    border-color: var(--hover-color);
  }
  .lil-gui button:focus {
    border-color: var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;
function ky(s) {
  const e = document.createElement("style");
  e.innerHTML = s;
  const t = document.querySelector("head link[rel=stylesheet], head style");
  t ? document.head.insertBefore(e, t) : document.head.appendChild(e);
}
let qh = !1;
class Md {
  constructor({
    parent: e,
    autoPlace: t = e === void 0,
    container: n,
    width: i,
    title: r = "Controls",
    injectStyles: o = !0,
    touchStyles: a = !0,
  } = {}) {
    if (
      ((this.parent = e),
      (this.root = e ? e.root : this),
      (this.children = []),
      (this.controllers = []),
      (this.folders = []),
      (this._closed = !1),
      (this._hidden = !1),
      (this.domElement = document.createElement("div")),
      this.domElement.classList.add("lil-gui"),
      (this.$title = document.createElement("div")),
      this.$title.classList.add("title"),
      this.$title.setAttribute("role", "button"),
      this.$title.setAttribute("aria-expanded", !0),
      this.$title.setAttribute("tabindex", 0),
      this.$title.addEventListener("click", () =>
        this.openAnimated(this._closed)
      ),
      this.$title.addEventListener("keydown", (l) => {
        (l.code === "Enter" || l.code === "Space") &&
          (l.preventDefault(), this.$title.click());
      }),
      this.$title.addEventListener("touchstart", () => {}, { passive: !0 }),
      (this.$children = document.createElement("div")),
      this.$children.classList.add("children"),
      this.domElement.appendChild(this.$title),
      this.domElement.appendChild(this.$children),
      this.title(r),
      a && this.domElement.classList.add("allow-touch-styles"),
      this.parent)
    ) {
      this.parent.children.push(this),
        this.parent.folders.push(this),
        this.parent.$children.appendChild(this.domElement);
      return;
    }
    this.domElement.classList.add("root"),
      !qh && o && (ky(zy), (qh = !0)),
      n
        ? n.appendChild(this.domElement)
        : t &&
          (this.domElement.classList.add("autoPlace"),
          document.body.appendChild(this.domElement)),
      i && this.domElement.style.setProperty("--width", i + "px"),
      this.domElement.addEventListener("keydown", (l) => l.stopPropagation()),
      this.domElement.addEventListener("keyup", (l) => l.stopPropagation());
  }
  add(e, t, n, i, r) {
    if (Object(n) === n) return new Oy(this, e, t, n);
    const o = e[t];
    switch (typeof o) {
      case "number":
        return new By(this, e, t, n, i, r);
      case "boolean":
        return new Ry(this, e, t);
      case "string":
        return new Uy(this, e, t);
      case "function":
        return new Va(this, e, t);
    }
    console.error(
      `gui.add failed
	property:`,
      t,
      `
	object:`,
      e,
      `
	value:`,
      o
    );
  }
  addColor(e, t, n = 1) {
    return new Ny(this, e, t, n);
  }
  addFolder(e) {
    return new Md({ parent: this, title: e });
  }
  load(e, t = !0) {
    return (
      e.controllers &&
        this.controllers.forEach((n) => {
          n instanceof Va ||
            (n._name in e.controllers && n.load(e.controllers[n._name]));
        }),
      t &&
        e.folders &&
        this.folders.forEach((n) => {
          n._title in e.folders && n.load(e.folders[n._title]);
        }),
      this
    );
  }
  save(e = !0) {
    const t = { controllers: {}, folders: {} };
    return (
      this.controllers.forEach((n) => {
        if (!(n instanceof Va)) {
          if (n._name in t.controllers)
            throw new Error(
              `Cannot save GUI with duplicate property "${n._name}"`
            );
          t.controllers[n._name] = n.save();
        }
      }),
      e &&
        this.folders.forEach((n) => {
          if (n._title in t.folders)
            throw new Error(
              `Cannot save GUI with duplicate folder "${n._title}"`
            );
          t.folders[n._title] = n.save();
        }),
      t
    );
  }
  open(e = !0) {
    return (
      (this._closed = !e),
      this.$title.setAttribute("aria-expanded", !this._closed),
      this.domElement.classList.toggle("closed", this._closed),
      this
    );
  }
  close() {
    return this.open(!1);
  }
  show(e = !0) {
    return (
      (this._hidden = !e),
      (this.domElement.style.display = this._hidden ? "none" : ""),
      this
    );
  }
  hide() {
    return this.show(!1);
  }
  openAnimated(e = !0) {
    return (
      (this._closed = !e),
      this.$title.setAttribute("aria-expanded", !this._closed),
      requestAnimationFrame(() => {
        const t = this.$children.clientHeight;
        (this.$children.style.height = t + "px"),
          this.domElement.classList.add("transition");
        const n = (r) => {
          r.target === this.$children &&
            ((this.$children.style.height = ""),
            this.domElement.classList.remove("transition"),
            this.$children.removeEventListener("transitionend", n));
        };
        this.$children.addEventListener("transitionend", n);
        const i = e ? this.$children.scrollHeight : 0;
        this.domElement.classList.toggle("closed", !e),
          requestAnimationFrame(() => {
            this.$children.style.height = i + "px";
          });
      }),
      this
    );
  }
  title(e) {
    return (this._title = e), (this.$title.innerHTML = e), this;
  }
  reset(e = !0) {
    return (
      (e ? this.controllersRecursive() : this.controllers).forEach((n) =>
        n.reset()
      ),
      this
    );
  }
  onChange(e) {
    return (this._onChange = e), this;
  }
  _callOnChange(e) {
    this.parent && this.parent._callOnChange(e),
      this._onChange !== void 0 &&
        this._onChange.call(this, {
          object: e.object,
          property: e.property,
          value: e.getValue(),
          controller: e,
        });
  }
  onFinishChange(e) {
    return (this._onFinishChange = e), this;
  }
  _callOnFinishChange(e) {
    this.parent && this.parent._callOnFinishChange(e),
      this._onFinishChange !== void 0 &&
        this._onFinishChange.call(this, {
          object: e.object,
          property: e.property,
          value: e.getValue(),
          controller: e,
        });
  }
  destroy() {
    this.parent &&
      (this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
      this.domElement.parentElement &&
        this.domElement.parentElement.removeChild(this.domElement),
      Array.from(this.children).forEach((e) => e.destroy());
  }
  controllersRecursive() {
    let e = Array.from(this.controllers);
    return (
      this.folders.forEach((t) => {
        e = e.concat(t.controllersRecursive());
      }),
      e
    );
  }
  foldersRecursive() {
    let e = Array.from(this.folders);
    return (
      this.folders.forEach((t) => {
        e = e.concat(t.foldersRecursive());
      }),
      e
    );
  }
}
var Hy =
    typeof globalThis != "undefined"
      ? globalThis
      : typeof window != "undefined"
      ? window
      : typeof global != "undefined"
      ? global
      : typeof self != "undefined"
      ? self
      : {},
  Sd = { exports: {} };
(function (s, e) {
  (function (t, n) {
    s.exports = n();
  })(Hy, function () {
    var t = function () {
      function n(f) {
        return o.appendChild(f.dom), f;
      }
      function i(f) {
        for (var m = 0; m < o.children.length; m++)
          o.children[m].style.display = m === f ? "block" : "none";
        r = f;
      }
      var r = 0,
        o = document.createElement("div");
      (o.style.cssText =
        "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
        o.addEventListener(
          "click",
          function (f) {
            f.preventDefault(), i(++r % o.children.length);
          },
          !1
        );
      var a = (performance || Date).now(),
        l = a,
        c = 0,
        h = n(new t.Panel("FPS", "#0ff", "#002")),
        u = n(new t.Panel("MS", "#0f0", "#020"));
      if (self.performance && self.performance.memory)
        var d = n(new t.Panel("MB", "#f08", "#201"));
      return (
        i(0),
        {
          REVISION: 16,
          dom: o,
          addPanel: n,
          showPanel: i,
          begin: function () {
            a = (performance || Date).now();
          },
          end: function () {
            c++;
            var f = (performance || Date).now();
            if (
              (u.update(f - a, 200),
              f > l + 1e3 &&
                (h.update((1e3 * c) / (f - l), 100), (l = f), (c = 0), d))
            ) {
              var m = performance.memory;
              d.update(m.usedJSHeapSize / 1048576, m.jsHeapSizeLimit / 1048576);
            }
            return f;
          },
          update: function () {
            a = this.end();
          },
          domElement: o,
          setMode: i,
        }
      );
    };
    return (
      (t.Panel = function (n, i, r) {
        var o = 1 / 0,
          a = 0,
          l = Math.round,
          c = l(window.devicePixelRatio || 1),
          h = 80 * c,
          u = 48 * c,
          d = 3 * c,
          f = 2 * c,
          m = 3 * c,
          v = 15 * c,
          y = 74 * c,
          p = 30 * c,
          g = document.createElement("canvas");
        (g.width = h),
          (g.height = u),
          (g.style.cssText = "width:80px;height:48px");
        var w = g.getContext("2d");
        return (
          (w.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif"),
          (w.textBaseline = "top"),
          (w.fillStyle = r),
          w.fillRect(0, 0, h, u),
          (w.fillStyle = i),
          w.fillText(n, d, f),
          w.fillRect(m, v, y, p),
          (w.fillStyle = r),
          (w.globalAlpha = 0.9),
          w.fillRect(m, v, y, p),
          {
            dom: g,
            update: function (b, _) {
              (o = Math.min(o, b)),
                (a = Math.max(a, b)),
                (w.fillStyle = r),
                (w.globalAlpha = 1),
                w.fillRect(0, 0, h, v),
                (w.fillStyle = i),
                w.fillText(
                  l(b) + " " + n + " (" + l(o) + "-" + l(a) + ")",
                  d,
                  f
                ),
                w.drawImage(g, m + c, v, y - c, p, m, v, y - c, p),
                w.fillRect(m + y - c, v, c, p),
                (w.fillStyle = r),
                (w.globalAlpha = 0.9),
                w.fillRect(m + y - c, v, c, l((1 - b / _) * p));
            },
          }
        );
      }),
      t
    );
  });
})(Sd);
var hw = Sd.exports;
class uw extends cn {
  constructor(e) {
    super(e);
    (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new Xy(t);
      }),
      this.register(function (t) {
        return new Ky(t);
      }),
      this.register(function (t) {
        return new Jy(t);
      }),
      this.register(function (t) {
        return new jy(t);
      }),
      this.register(function (t) {
        return new qy(t);
      }),
      this.register(function (t) {
        return new Yy(t);
      }),
      this.register(function (t) {
        return new Zy(t);
      }),
      this.register(function (t) {
        return new $y(t);
      }),
      this.register(function (t) {
        return new Vy(t);
      }),
      this.register(function (t) {
        return new Qy(t);
      });
  }
  load(e, t, n, i) {
    const r = this;
    let o;
    this.resourcePath !== ""
      ? (o = this.resourcePath)
      : this.path !== ""
      ? (o = this.path)
      : (o = Tn.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (c) {
        i ? i(c) : console.error(c),
          r.manager.itemError(e),
          r.manager.itemEnd(e);
      },
      l = new Pn(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            r.parse(
              c,
              o,
              function (h) {
                t(h), r.manager.itemEnd(e);
              },
              a
            );
          } catch (h) {
            a(h);
          }
        },
        n,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let r;
    const o = {},
      a = {};
    if (typeof e == "string") r = e;
    else if (Tn.decodeText(new Uint8Array(e, 0, 4)) === Td) {
      try {
        o[rt.KHR_BINARY_GLTF] = new e_(e);
      } catch (u) {
        i && i(u);
        return;
      }
      r = o[rt.KHR_BINARY_GLTF].content;
    } else r = Tn.decodeText(new Uint8Array(e));
    const l = JSON.parse(r);
    if (l.asset === void 0 || l.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new f_(l, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const u = this.pluginCallbacks[h](c);
      (a[u.name] = u), (o[u.name] = !0);
    }
    if (l.extensionsUsed)
      for (let h = 0; h < l.extensionsUsed.length; ++h) {
        const u = l.extensionsUsed[h],
          d = l.extensionsRequired || [];
        switch (u) {
          case rt.KHR_MATERIALS_UNLIT:
            o[u] = new Wy();
            break;
          case rt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            o[u] = new i_();
            break;
          case rt.KHR_DRACO_MESH_COMPRESSION:
            o[u] = new t_(l, this.dracoLoader);
            break;
          case rt.KHR_TEXTURE_TRANSFORM:
            o[u] = new n_();
            break;
          case rt.KHR_MESH_QUANTIZATION:
            o[u] = new r_();
            break;
          default:
            d.indexOf(u) >= 0 &&
              a[u] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    c.setExtensions(o), c.setPlugins(a), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, r) {
      n.parse(e, t, i, r);
    });
  }
}
function Gy() {
  let s = {};
  return {
    get: function (e) {
      return s[e];
    },
    add: function (e, t) {
      s[e] = t;
    },
    remove: function (e) {
      delete s[e];
    },
    removeAll: function () {
      s = {};
    },
  };
}
const rt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
};
class Vy {
  constructor(e) {
    (this.parser = e),
      (this.name = rt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      r.extensions &&
        r.extensions[this.name] &&
        r.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const r = t.json,
      l = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const h = new ye(16777215);
    l.color !== void 0 && h.fromArray(l.color);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new Jl(h)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new Io(h)), (c.distance = u);
        break;
      case "spot":
        (c = new Kl(h)),
          (c.distance = u),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (i = Promise.resolve(c)),
      t.cache.add(n, i),
      i
    );
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      r = n.json.nodes[e],
      a = ((r.extensions && r.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return n._getNodeRef(t.cache, a, l);
        });
  }
}
class Wy {
  constructor() {
    this.name = rt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Rn;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new ye(1, 1, 1)), (e.opacity = 1);
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const o = r.baseColorFactor;
        e.color.fromArray(o), (e.opacity = o[3]);
      }
      r.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, "map", r.baseColorTexture));
    }
    return Promise.all(i);
  }
}
class Xy {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (r.push(
          n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ae(a, a);
    }
    return Promise.all(r);
  }
}
class jy {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [];
    (t.sheenColor = new ye(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = i.extensions[this.name];
    return (
      o.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(o.sheenColorFactor),
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        r.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture)),
      o.sheenRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(r)
    );
  }
}
class qy {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        r.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(r)
    );
  }
}
class Yy {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        r.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new ye(a[0], a[1], a[2])), Promise.all(r);
  }
}
class Zy {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wi;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = i.extensions[this.name];
    return (t.ior = r.ior !== void 0 ? r.ior : 1.5), Promise.resolve();
  }
}
class $y {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      o = i.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        r.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new ye(a[0], a[1], a[2])),
      o.specularColorTexture !== void 0 &&
        r.push(
          n
            .assignTexture(t, "specularColorMap", o.specularColorTexture)
            .then(function (l) {
              l.encoding = it;
            })
        ),
      Promise.all(r)
    );
  }
}
class Ky {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const r = i.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, r.source, o);
  }
}
class Jy {
  constructor(e) {
    (this.parser = e),
      (this.name = rt.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const o = r.extensions[t],
      a = i.images[o.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, a, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class Qy {
  constructor(e) {
    (this.name = rt.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        r = this.parser.getDependency("buffer", i.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return Promise.all([r, o.ready]).then(function (a) {
        const l = i.byteOffset || 0,
          c = i.byteLength || 0,
          h = i.count,
          u = i.byteStride,
          d = new ArrayBuffer(h * u),
          f = new Uint8Array(a[0], l, c);
        return (
          o.decodeGltfBuffer(new Uint8Array(d), h, u, f, i.mode, i.filter), d
        );
      });
    } else return null;
  }
}
const Td = "glTF",
  ns = 12,
  Yh = { JSON: 1313821514, BIN: 5130562 };
class e_ {
  constructor(e) {
    (this.name = rt.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, ns);
    if (
      ((this.header = {
        magic: Tn.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== Td)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - ns,
      i = new DataView(e, ns);
    let r = 0;
    for (; r < n; ) {
      const o = i.getUint32(r, !0);
      r += 4;
      const a = i.getUint32(r, !0);
      if (((r += 4), a === Yh.JSON)) {
        const l = new Uint8Array(e, ns + r, o);
        this.content = Tn.decodeText(l);
      } else if (a === Yh.BIN) {
        const l = ns + r;
        this.body = e.slice(l, l + o);
      }
      r += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class t_ {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = rt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      r = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      c = {};
    for (const h in o) {
      const u = yl[h] || h.toLowerCase();
      a[u] = o[h];
    }
    for (const h in e.attributes) {
      const u = yl[h] || h.toLowerCase();
      if (o[h] !== void 0) {
        const d = n.accessors[e.attributes[h]],
          f = Ms[d.componentType];
        (c[u] = f), (l[u] = d.normalized === !0);
      }
    }
    return t.getDependency("bufferView", r).then(function (h) {
      return new Promise(function (u) {
        i.decodeDracoFile(
          h,
          function (d) {
            for (const f in d.attributes) {
              const m = d.attributes[f],
                v = l[f];
              v !== void 0 && (m.normalized = v);
            }
            u(d);
          },
          a,
          c
        );
      });
    });
  }
}
class n_ {
  constructor() {
    this.name = rt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      t.texCoord !== void 0 &&
        console.warn(
          'THREE.GLTFLoader: Custom UV sets in "' +
            this.name +
            '" extension not yet supported.'
        ),
      (t.offset === void 0 && t.rotation === void 0 && t.scale === void 0) ||
        ((e = e.clone()),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class xl extends Fr {
  constructor(e) {
    super();
    this.isGLTFSpecularGlossinessMaterial = !0;
    const t = [
        "#ifdef USE_SPECULARMAP",
        "	uniform sampler2D specularMap;",
        "#endif",
      ].join(`
`),
      n = [
        "#ifdef USE_GLOSSINESSMAP",
        "	uniform sampler2D glossinessMap;",
        "#endif",
      ].join(`
`),
      i = [
        "vec3 specularFactor = specular;",
        "#ifdef USE_SPECULARMAP",
        "	vec4 texelSpecular = texture2D( specularMap, vUv );",
        "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	specularFactor *= texelSpecular.rgb;",
        "#endif",
      ].join(`
`),
      r = [
        "float glossinessFactor = glossiness;",
        "#ifdef USE_GLOSSINESSMAP",
        "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
        "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	glossinessFactor *= texelGlossiness.a;",
        "#endif",
      ].join(`
`),
      o = [
        "PhysicalMaterial material;",
        "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
        "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
        "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
        "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
        "material.roughness += geometryRoughness;",
        "material.roughness = min( material.roughness, 1.0 );",
        "material.specularColor = specularFactor;",
      ].join(`
`),
      a = {
        specular: { value: new ye().setHex(16777215) },
        glossiness: { value: 1 },
        specularMap: { value: null },
        glossinessMap: { value: null },
      };
    (this._extraUniforms = a),
      (this.onBeforeCompile = function (l) {
        for (const c in a) l.uniforms[c] = a[c];
        l.fragmentShader = l.fragmentShader
          .replace("uniform float roughness;", "uniform vec3 specular;")
          .replace("uniform float metalness;", "uniform float glossiness;")
          .replace("#include <roughnessmap_pars_fragment>", t)
          .replace("#include <metalnessmap_pars_fragment>", n)
          .replace("#include <roughnessmap_fragment>", i)
          .replace("#include <metalnessmap_fragment>", r)
          .replace("#include <lights_physical_fragment>", o);
      }),
      Object.defineProperties(this, {
        specular: {
          get: function () {
            return a.specular.value;
          },
          set: function (l) {
            a.specular.value = l;
          },
        },
        specularMap: {
          get: function () {
            return a.specularMap.value;
          },
          set: function (l) {
            (a.specularMap.value = l),
              l
                ? (this.defines.USE_SPECULARMAP = "")
                : delete this.defines.USE_SPECULARMAP;
          },
        },
        glossiness: {
          get: function () {
            return a.glossiness.value;
          },
          set: function (l) {
            a.glossiness.value = l;
          },
        },
        glossinessMap: {
          get: function () {
            return a.glossinessMap.value;
          },
          set: function (l) {
            (a.glossinessMap.value = l),
              l
                ? ((this.defines.USE_GLOSSINESSMAP = ""),
                  (this.defines.USE_UV = ""))
                : (delete this.defines.USE_GLOSSINESSMAP,
                  delete this.defines.USE_UV);
          },
        },
      }),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.specularMap = e.specularMap),
      this.specular.copy(e.specular),
      (this.glossinessMap = e.glossinessMap),
      (this.glossiness = e.glossiness),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this
    );
  }
}
class i_ {
  constructor() {
    (this.name = rt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
      (this.specularGlossinessParams = [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio",
      ]);
  }
  getMaterialType() {
    return xl;
  }
  extendParams(e, t, n) {
    const i = t.extensions[this.name];
    (e.color = new ye(1, 1, 1)), (e.opacity = 1);
    const r = [];
    if (Array.isArray(i.diffuseFactor)) {
      const o = i.diffuseFactor;
      e.color.fromArray(o), (e.opacity = o[3]);
    }
    if (
      (i.diffuseTexture !== void 0 &&
        r.push(n.assignTexture(e, "map", i.diffuseTexture)),
      (e.emissive = new ye(0, 0, 0)),
      (e.glossiness = i.glossinessFactor !== void 0 ? i.glossinessFactor : 1),
      (e.specular = new ye(1, 1, 1)),
      Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor),
      i.specularGlossinessTexture !== void 0)
    ) {
      const o = i.specularGlossinessTexture;
      r.push(n.assignTexture(e, "glossinessMap", o)),
        r.push(n.assignTexture(e, "specularMap", o));
    }
    return Promise.all(r);
  }
  createMaterial(e) {
    const t = new xl(e);
    return (
      (t.fog = !0),
      (t.color = e.color),
      (t.map = e.map === void 0 ? null : e.map),
      (t.lightMap = null),
      (t.lightMapIntensity = 1),
      (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
      (t.aoMapIntensity = 1),
      (t.emissive = e.emissive),
      (t.emissiveIntensity = 1),
      (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
      (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
      (t.bumpScale = 1),
      (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
      (t.normalMapType = Ii),
      e.normalScale && (t.normalScale = e.normalScale),
      (t.displacementMap = null),
      (t.displacementScale = 1),
      (t.displacementBias = 0),
      (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
      (t.specular = e.specular),
      (t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap),
      (t.glossiness = e.glossiness),
      (t.alphaMap = null),
      (t.envMap = e.envMap === void 0 ? null : e.envMap),
      (t.envMapIntensity = 1),
      (t.refractionRatio = 0.98),
      t
    );
  }
}
class r_ {
  constructor() {
    this.name = rt.KHR_MESH_QUANTIZATION;
  }
}
class Pi extends Zn {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i * 3 + i;
    for (let o = 0; o !== i; o++) t[o] = n[r + o];
    return t;
  }
}
Pi.prototype.beforeStart_ = Pi.prototype.copySampleValue_;
Pi.prototype.afterEnd_ = Pi.prototype.copySampleValue_;
Pi.prototype.interpolate_ = function (s, e, t, n) {
  const i = this.resultBuffer,
    r = this.sampleValues,
    o = this.valueSize,
    a = o * 2,
    l = o * 3,
    c = n - e,
    h = (t - e) / c,
    u = h * h,
    d = u * h,
    f = s * l,
    m = f - l,
    v = -2 * d + 3 * u,
    y = d - u,
    p = 1 - v,
    g = y - u + h;
  for (let w = 0; w !== o; w++) {
    const b = r[m + w + o],
      _ = r[m + w + a] * c,
      E = r[f + w + o],
      L = r[f + w] * c;
    i[w] = p * b + g * _ + v * E + y * L;
  }
  return i;
};
const s_ = new Dt();
class o_ extends Pi {
  interpolate_(e, t, n, i) {
    const r = super.interpolate_(e, t, n, i);
    return s_.fromArray(r).normalize().toArray(r), r;
  }
}
const Wn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Ms = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  Zh = { 9728: zt, 9729: st, 9984: el, 9985: _u, 9986: tl, 9987: yi },
  $h = { 33071: Zt, 33648: Ao, 10497: pi },
  Kh = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  yl = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  oi = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  a_ = { CUBICSPLINE: void 0, LINEAR: _r, STEP: fs },
  Wa = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function l_(s) {
  return (
    s.DefaultMaterial === void 0 &&
      (s.DefaultMaterial = new Fr({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: gr,
      })),
    s.DefaultMaterial
  );
}
function is(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function Ai(s, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(s.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function c_(s, e, t) {
  let n = !1,
    i = !1,
    r = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (
      (u.POSITION !== void 0 && (n = !0),
      u.NORMAL !== void 0 && (i = !0),
      u.COLOR_0 !== void 0 && (r = !0),
      n && i && r)
    )
      break;
  }
  if (!n && !i && !r) return Promise.resolve(s);
  const o = [],
    a = [],
    l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (n) {
      const d =
        u.POSITION !== void 0
          ? t.getDependency("accessor", u.POSITION)
          : s.attributes.position;
      o.push(d);
    }
    if (i) {
      const d =
        u.NORMAL !== void 0
          ? t.getDependency("accessor", u.NORMAL)
          : s.attributes.normal;
      a.push(d);
    }
    if (r) {
      const d =
        u.COLOR_0 !== void 0
          ? t.getDependency("accessor", u.COLOR_0)
          : s.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (c) {
      const h = c[0],
        u = c[1],
        d = c[2];
      return (
        n && (s.morphAttributes.position = h),
        i && (s.morphAttributes.normal = u),
        r && (s.morphAttributes.color = d),
        (s.morphTargetsRelative = !0),
        s
      );
    }
  );
}
function h_(s, e) {
  if ((s.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function u_(s) {
  const e = s.extensions && s.extensions[rt.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return (
    e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + Jh(e.attributes))
      : (t = s.indices + ":" + Jh(s.attributes) + ":" + s.mode),
    t
  );
}
function Jh(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function _l(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function d_(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
class f_ {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new Gy()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {}),
      typeof createImageBitmap != "undefined" &&
      /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !1
        ? (this.textureLoader = new yd(this.options.manager))
        : (this.textureLoader = new Zl(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Pn(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      r = this.extensions;
    this.cache.removeAll(),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][i.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          is(r, a, i),
            Ai(a, i),
            Promise.all(
              n._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              e(a);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      r = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [c, h] of o.children.entries()) r(h, a.children[c]);
      };
    return r(n, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this.loadNode(t);
          break;
        case "mesh":
          i = this._invokeOne(function (r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this.loadAnimation(t);
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (r, o) {
          return n.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[rt.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (r, o) {
      n.load(Tn.resolveURL(t.uri, i.path), r, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        r = t.byteOffset || 0;
      return n.slice(r, r + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0)
      return Promise.resolve(null);
    const r = [];
    return (
      i.bufferView !== void 0
        ? r.push(this.getDependency("bufferView", i.bufferView))
        : r.push(null),
      i.sparse !== void 0 &&
        (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(r).then(function (o) {
        const a = o[0],
          l = Kh[i.type],
          c = Ms[i.componentType],
          h = c.BYTES_PER_ELEMENT,
          u = h * l,
          d = i.byteOffset || 0,
          f =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          m = i.normalized === !0;
        let v, y;
        if (f && f !== u) {
          const p = Math.floor(d / f),
            g =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              p +
              ":" +
              i.count;
          let w = t.cache.get(g);
          w ||
            ((v = new c(a, p * f, (i.count * f) / h)),
            (w = new Pr(v, f / h)),
            t.cache.add(g, w)),
            (y = new br(w, l, (d % f) / h, m));
        } else a === null ? (v = new c(i.count * l)) : (v = new c(a, d, i.count * l)), (y = new St(v, l, m));
        if (i.sparse !== void 0) {
          const p = Kh.SCALAR,
            g = Ms[i.sparse.indices.componentType],
            w = i.sparse.indices.byteOffset || 0,
            b = i.sparse.values.byteOffset || 0,
            _ = new g(o[1], w, i.sparse.count * p),
            E = new c(o[2], b, i.sparse.count * l);
          a !== null && (y = new St(y.array.slice(), y.itemSize, y.normalized));
          for (let L = 0, D = _.length; L < D; L++) {
            const V = _[L];
            if (
              (y.setX(V, E[L * l]),
              l >= 2 && y.setY(V, E[L * l + 1]),
              l >= 3 && y.setZ(V, E[L * l + 2]),
              l >= 4 && y.setW(V, E[L * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return y;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      r = t.textures[e].source,
      o = t.images[r];
    let a = this.textureLoader;
    if (o.uri) {
      const l = n.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, r, a);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      r = this.json,
      o = r.textures[e],
      a = r.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, n)
      .then(function (h) {
        (h.flipY = !1), o.name && (h.name = o.name);
        const d = (r.samplers || {})[o.sampler] || {};
        return (
          (h.magFilter = Zh[d.magFilter] || st),
          (h.minFilter = Zh[d.minFilter] || yi),
          (h.wrapS = $h[d.wrapS] || pi),
          (h.wrapT = $h[d.wrapT] || pi),
          i.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e]
        .then(function (u) {
          return u.clone();
        })
        .catch(function (u) {
          throw u;
        });
    const o = i.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      c = !1;
    if (o.bufferView !== void 0)
      l = n.getDependency("bufferView", o.bufferView).then(function (u) {
        c = !0;
        const d = new Blob([u], { type: o.mimeType });
        return (l = a.createObjectURL(d)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(l)
      .then(function (u) {
        return new Promise(function (d, f) {
          let m = d;
          t.isImageBitmapLoader === !0 &&
            (m = function (v) {
              const y = new At(v);
              (y.needsUpdate = !0), d(y);
            }),
            t.load(Tn.resolveURL(u, r.path), m, void 0, f);
        });
      })
      .then(function (u) {
        return (
          c === !0 && a.revokeObjectURL(l),
          (u.userData.mimeType = o.mimeType || d_(o.uri)),
          u
        );
      })
      .catch(function (u) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), u);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, n) {
    const i = this;
    return this.getDependency("texture", n.index).then(function (r) {
      if (
        (n.texCoord !== void 0 &&
          n.texCoord != 0 &&
          !(t === "aoMap" && n.texCoord == 1) &&
          console.warn(
            "THREE.GLTFLoader: Custom UV set " +
              n.texCoord +
              " for texture " +
              t +
              " not yet supported."
          ),
        i.extensions[rt.KHR_TEXTURE_TRANSFORM])
      ) {
        const o =
          n.extensions !== void 0
            ? n.extensions[rt.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (o) {
          const a = i.associations.get(r);
          (r = i.extensions[rt.KHR_TEXTURE_TRANSFORM].extendTexture(r, o)),
            i.associations.set(r, a);
        }
      }
      return (e[t] = r), r;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      r = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new Zo()),
        Et.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (n = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new Nn()),
        Et.prototype.copy.call(l, n),
        l.color.copy(n.color),
        this.cache.add(a, l)),
        (n = l);
    }
    if (i || r || o) {
      let a = "ClonedMaterial:" + n.uuid + ":";
      n.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
        i && (a += "derivative-tangents:"),
        r && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = n.clone()),
        r && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        i &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(n))),
        (n = l);
    }
    n.aoMap &&
      t.attributes.uv2 === void 0 &&
      t.attributes.uv !== void 0 &&
      t.setAttribute("uv2", t.attributes.uv),
      (e.material = n);
  }
  getMaterialType() {
    return Fr;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.materials[e];
    let o;
    const a = {},
      l = r.extensions || {},
      c = [];
    if (l[rt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const u = i[rt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      (o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
    } else if (l[rt.KHR_MATERIALS_UNLIT]) {
      const u = i[rt.KHR_MATERIALS_UNLIT];
      (o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
    } else {
      const u = r.pbrMetallicRoughness || {};
      if (
        ((a.color = new ye(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(u.baseColorFactor))
      ) {
        const d = u.baseColorFactor;
        a.color.fromArray(d), (a.opacity = d[3]);
      }
      u.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(a, "map", u.baseColorTexture)),
        (a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1),
        (a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
        u.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)
          ),
          c.push(
            t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (d) {
          return d.getMaterialType && d.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (d) {
              return d.extendMaterialParams && d.extendMaterialParams(e, a);
            })
          )
        );
    }
    r.doubleSided === !0 && (a.side = Li);
    const h = r.alphaMode || Wa.OPAQUE;
    if (
      (h === Wa.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === Wa.MASK &&
            (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
      r.normalTexture !== void 0 &&
        o !== Rn &&
        (c.push(t.assignTexture(a, "normalMap", r.normalTexture)),
        (a.normalScale = new ae(1, 1)),
        r.normalTexture.scale !== void 0))
    ) {
      const u = r.normalTexture.scale;
      a.normalScale.set(u, u);
    }
    return (
      r.occlusionTexture !== void 0 &&
        o !== Rn &&
        (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
        r.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = r.occlusionTexture.strength)),
      r.emissiveFactor !== void 0 &&
        o !== Rn &&
        (a.emissive = new ye().fromArray(r.emissiveFactor)),
      r.emissiveTexture !== void 0 &&
        o !== Rn &&
        c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)),
      Promise.all(c).then(function () {
        let u;
        return (
          o === xl
            ? (u =
                i[rt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a))
            : (u = new o(a)),
          r.name && (u.name = r.name),
          u.map && (u.map.encoding = it),
          u.emissiveMap && (u.emissiveMap.encoding = it),
          u.sheenColorMap && (u.sheenColorMap.encoding = it),
          u.specularColorMap && (u.specularColorMap.encoding = it),
          u.specularMap && (u.specularMap.encoding = it),
          Ai(u, r),
          t.associations.set(u, { materials: e }),
          r.extensions && is(i, u, r),
          u
        );
      })
    );
  }
  createUniqueName(e) {
    const t = ot.sanitizeNodeName(e || "");
    let n = t;
    for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
    return (this.nodeNamesUsed[n] = !0), n;
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function r(a) {
      return n[rt.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return Qh(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        h = u_(c),
        u = i[h];
      if (u) o.push(u.promise);
      else {
        let d;
        c.extensions && c.extensions[rt.KHR_DRACO_MESH_COMPRESSION]
          ? (d = r(c))
          : (d = Qh(new tt(), c, t)),
          (i[h] = { primitive: c, promise: d }),
          o.push(d);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.meshes[e],
      o = r.primitives,
      a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const h =
        o[l].material === void 0
          ? l_(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(h);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const c = l.slice(0, l.length - 1),
          h = l[l.length - 1],
          u = [];
        for (let f = 0, m = h.length; f < m; f++) {
          const v = h[f],
            y = o[f];
          let p;
          const g = c[f];
          if (
            y.mode === Wn.TRIANGLES ||
            y.mode === Wn.TRIANGLE_STRIP ||
            y.mode === Wn.TRIANGLE_FAN ||
            y.mode === void 0
          )
            (p = r.isSkinnedMesh === !0 ? new qo(v, g) : new jt(v, g)),
              p.isSkinnedMesh === !0 &&
                !p.geometry.attributes.skinWeight.normalized &&
                p.normalizeSkinWeights(),
              y.mode === Wn.TRIANGLE_STRIP
                ? (p.geometry = eu(p.geometry, sp))
                : y.mode === Wn.TRIANGLE_FAN &&
                  (p.geometry = eu(p.geometry, Su));
          else if (y.mode === Wn.LINES) p = new Ir(v, g);
          else if (y.mode === Wn.LINE_STRIP) p = new Rs(v, g);
          else if (y.mode === Wn.LINE_LOOP) p = new Xu(v, g);
          else if (y.mode === Wn.POINTS) p = new ju(v, g);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + y.mode
            );
          Object.keys(p.geometry.morphAttributes).length > 0 && h_(p, r),
            (p.name = t.createUniqueName(r.name || "mesh_" + e)),
            Ai(p, r),
            y.extensions && is(i, p, y),
            t.assignFinalMaterial(p),
            u.push(p);
        }
        for (let f = 0, m = u.length; f < m; f++)
          t.associations.set(u[f], { meshes: e, primitives: f });
        if (u.length === 1) return u[0];
        const d = new Ln();
        t.associations.set(d, { meshes: e });
        for (let f = 0, m = u.length; f < m; f++) d.add(u[f]);
        return d;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (t = new Yt(
            Sn.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : n.type === "orthographic" &&
          (t = new Ni(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      Ai(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = { joints: t.joints };
    return t.inverseBindMatrices === void 0
      ? Promise.resolve(n)
      : this.getDependency("accessor", t.inverseBindMatrices).then(function (
          i
        ) {
          return (n.inverseBindMatrices = i), n;
        });
  }
  loadAnimation(e) {
    const n = this.json.animations[e],
      i = [],
      r = [],
      o = [],
      a = [],
      l = [];
    for (let c = 0, h = n.channels.length; c < h; c++) {
      const u = n.channels[c],
        d = n.samplers[u.sampler],
        f = u.target,
        m = f.node !== void 0 ? f.node : f.id,
        v = n.parameters !== void 0 ? n.parameters[d.input] : d.input,
        y = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
      i.push(this.getDependency("node", m)),
        r.push(this.getDependency("accessor", v)),
        o.push(this.getDependency("accessor", y)),
        a.push(d),
        l.push(f);
    }
    return Promise.all([
      Promise.all(i),
      Promise.all(r),
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
    ]).then(function (c) {
      const h = c[0],
        u = c[1],
        d = c[2],
        f = c[3],
        m = c[4],
        v = [];
      for (let p = 0, g = h.length; p < g; p++) {
        const w = h[p],
          b = u[p],
          _ = d[p],
          E = f[p],
          L = m[p];
        if (w === void 0) continue;
        w.updateMatrix(), (w.matrixAutoUpdate = !0);
        let D;
        switch (oi[L.path]) {
          case oi.weights:
            D = Mr;
            break;
          case oi.rotation:
            D = vi;
            break;
          case oi.position:
          case oi.scale:
          default:
            D = Sr;
            break;
        }
        const V = w.name ? w.name : w.uuid,
          F = E.interpolation !== void 0 ? a_[E.interpolation] : _r,
          M = [];
        oi[L.path] === oi.weights
          ? w.traverse(function (N) {
              N.morphTargetInfluences && M.push(N.name ? N.name : N.uuid);
            })
          : M.push(V);
        let A = _.array;
        if (_.normalized) {
          const N = _l(A.constructor),
            O = new Float32Array(A.length);
          for (let H = 0, G = A.length; H < G; H++) O[H] = A[H] * N;
          A = O;
        }
        for (let N = 0, O = M.length; N < O; N++) {
          const H = new D(M[N] + "." + oi[L.path], b.array, A, F);
          E.interpolation === "CUBICSPLINE" &&
            ((H.createInterpolant = function (W) {
              const k = this instanceof vi ? o_ : Pi;
              return new k(this.times, this.values, this.getValueSize() / 3, W);
            }),
            (H.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            v.push(H);
        }
      }
      const y = n.name ? n.name : "animation_" + e;
      return new Po(y, void 0, v);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency("mesh", i.mesh).then(function (r) {
          const o = n._getNodeRef(n.meshCache, i.mesh, r);
          return (
            i.weights !== void 0 &&
              o.traverse(function (a) {
                if (!!a.isMesh)
                  for (let l = 0, c = i.weights.length; l < c; l++)
                    a.morphTargetInfluences[l] = i.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this.extensions,
      i = this,
      r = t.nodes[e],
      o = r.name ? i.createUniqueName(r.name) : "";
    return (function () {
      const a = [],
        l = i._invokeOne(function (c) {
          return c.createNodeMesh && c.createNodeMesh(e);
        });
      return (
        l && a.push(l),
        r.camera !== void 0 &&
          a.push(
            i.getDependency("camera", r.camera).then(function (c) {
              return i._getNodeRef(i.cameraCache, r.camera, c);
            })
          ),
        i
          ._invokeAll(function (c) {
            return c.createNodeAttachment && c.createNodeAttachment(e);
          })
          .forEach(function (c) {
            a.push(c);
          }),
        Promise.all(a)
      );
    })().then(function (a) {
      let l;
      if (
        (r.isBone === !0
          ? (l = new xs())
          : a.length > 1
          ? (l = new Ln())
          : a.length === 1
          ? (l = a[0])
          : (l = new at()),
        l !== a[0])
      )
        for (let c = 0, h = a.length; c < h; c++) l.add(a[c]);
      if (
        (r.name && ((l.userData.name = r.name), (l.name = o)),
        Ai(l, r),
        r.extensions && is(n, l, r),
        r.matrix !== void 0)
      ) {
        const c = new be();
        c.fromArray(r.matrix), l.applyMatrix4(c);
      } else r.translation !== void 0 && l.position.fromArray(r.translation), r.rotation !== void 0 && l.quaternion.fromArray(r.rotation), r.scale !== void 0 && l.scale.fromArray(r.scale);
      return (
        i.associations.has(l) || i.associations.set(l, {}),
        (i.associations.get(l).nodes = e),
        l
      );
    });
  }
  loadScene(e) {
    const t = this.json,
      n = this.extensions,
      i = this.json.scenes[e],
      r = this,
      o = new Ln();
    i.name && (o.name = r.createUniqueName(i.name)),
      Ai(o, i),
      i.extensions && is(n, o, i);
    const a = i.nodes || [],
      l = [];
    for (let c = 0, h = a.length; c < h; c++) l.push(Ed(a[c], o, t, r));
    return Promise.all(l).then(function () {
      const c = (h) => {
        const u = new Map();
        for (const [d, f] of r.associations)
          (d instanceof Et || d instanceof At) && u.set(d, f);
        return (
          h.traverse((d) => {
            const f = r.associations.get(d);
            f != null && u.set(d, f);
          }),
          u
        );
      };
      return (r.associations = c(o)), o;
    });
  }
}
function Ed(s, e, t, n) {
  const i = t.nodes[s];
  return n
    .getDependency("node", s)
    .then(function (r) {
      if (i.skin === void 0) return r;
      let o;
      return n
        .getDependency("skin", i.skin)
        .then(function (a) {
          o = a;
          const l = [];
          for (let c = 0, h = o.joints.length; c < h; c++)
            l.push(n.getDependency("node", o.joints[c]));
          return Promise.all(l);
        })
        .then(function (a) {
          return (
            r.traverse(function (l) {
              if (!l.isMesh) return;
              const c = [],
                h = [];
              for (let u = 0, d = a.length; u < d; u++) {
                const f = a[u];
                if (f) {
                  c.push(f);
                  const m = new be();
                  o.inverseBindMatrices !== void 0 &&
                    m.fromArray(o.inverseBindMatrices.array, u * 16),
                    h.push(m);
                } else
                  console.warn(
                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                    o.joints[u]
                  );
              }
              l.bind(new Yo(c, h), l.matrixWorld);
            }),
            r
          );
        });
    })
    .then(function (r) {
      e.add(r);
      const o = [];
      if (i.children) {
        const a = i.children;
        for (let l = 0, c = a.length; l < c; l++) {
          const h = a[l];
          o.push(Ed(h, r, t, n));
        }
      }
      return Promise.all(o);
    });
}
function p_(s, e, t) {
  const n = e.attributes,
    i = new _n();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION],
      l = a.min,
      c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (i.set(new P(l[0], l[1], l[2]), new P(c[0], c[1], c[2])), a.normalized)
      ) {
        const h = _l(Ms[a.componentType]);
        i.min.multiplyScalar(h), i.max.multiplyScalar(h);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const r = e.targets;
  if (r !== void 0) {
    const a = new P(),
      l = new P();
    for (let c = 0, h = r.length; c < h; c++) {
      const u = r[c];
      if (u.POSITION !== void 0) {
        const d = t.json.accessors[u.POSITION],
          f = d.min,
          m = d.max;
        if (f !== void 0 && m !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))),
            l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))),
            l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))),
            d.normalized)
          ) {
            const v = _l(Ms[d.componentType]);
            l.multiplyScalar(v);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    i.expandByVector(a);
  }
  s.boundingBox = i;
  const o = new Fi();
  i.getCenter(o.center),
    (o.radius = i.min.distanceTo(i.max) / 2),
    (s.boundingSphere = o);
}
function Qh(s, e, t) {
  const n = e.attributes,
    i = [];
  function r(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      s.setAttribute(a, l);
    });
  }
  for (const o in n) {
    const a = yl[o] || o.toLowerCase();
    a in s.attributes || i.push(r(n[o], a));
  }
  if (e.indices !== void 0 && !s.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      s.setIndex(a);
    });
    i.push(o);
  }
  return (
    Ai(s, e),
    p_(s, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? c_(s, e.targets, t) : s;
    })
  );
}
function eu(s, e) {
  let t = s.getIndex();
  if (t === null) {
    const o = [],
      a = s.getAttribute("position");
    if (a !== void 0) {
      for (let l = 0; l < a.count; l++) o.push(l);
      s.setIndex(o), (t = s.getIndex());
    } else
      return (
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ),
        s
      );
  }
  const n = t.count - 2,
    i = [];
  if (e === Su)
    for (let o = 1; o <= n; o++)
      i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
  else
    for (let o = 0; o < n; o++)
      o % 2 === 0
        ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2)))
        : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
  i.length / 3 !== n &&
    console.error(
      "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
    );
  const r = s.clone();
  return r.setIndex(i), r;
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/ var tu = {},
  wl = function (s) {
    return URL.createObjectURL(new Blob([s], { type: "text/javascript" }));
  },
  Ad = function (s) {
    return new Worker(s);
  };
try {
  URL.revokeObjectURL(wl(""));
} catch {
  (wl = function (e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  }),
    (Ad = function (e) {
      return new Worker(e, { type: "module" });
    });
}
var m_ = function (s, e, t, n, i) {
    var r = Ad(tu[e] || (tu[e] = wl(s)));
    return (
      (r.onerror = function (o) {
        return i(o.error, null);
      }),
      (r.onmessage = function (o) {
        return i(null, o.data);
      }),
      r.postMessage(t, n),
      r
    );
  },
  nt = Uint8Array,
  Wt = Uint16Array,
  $n = Uint32Array,
  Or = new nt([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  Ur = new nt([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  Ss = new nt([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  Cd = function (s, e) {
    for (var t = new Wt(31), n = 0; n < 31; ++n) t[n] = e += 1 << s[n - 1];
    for (var i = new $n(t[30]), n = 1; n < 30; ++n)
      for (var r = t[n]; r < t[n + 1]; ++r) i[r] = ((r - t[n]) << 5) | n;
    return [t, i];
  },
  Rd = Cd(Or, 2),
  nc = Rd[0],
  Do = Rd[1];
(nc[28] = 258), (Do[258] = 28);
var Ld = Cd(Ur, 0),
  Pd = Ld[0],
  bl = Ld[1],
  Ts = new Wt(32768);
for (var wt = 0; wt < 32768; ++wt) {
  var ai = ((wt & 43690) >>> 1) | ((wt & 21845) << 1);
  (ai = ((ai & 52428) >>> 2) | ((ai & 13107) << 2)),
    (ai = ((ai & 61680) >>> 4) | ((ai & 3855) << 4)),
    (Ts[wt] = (((ai & 65280) >>> 8) | ((ai & 255) << 8)) >>> 1);
}
var vn = function (s, e, t) {
    for (var n = s.length, i = 0, r = new Wt(e); i < n; ++i) ++r[s[i] - 1];
    var o = new Wt(e);
    for (i = 0; i < e; ++i) o[i] = (o[i - 1] + r[i - 1]) << 1;
    var a;
    if (t) {
      a = new Wt(1 << e);
      var l = 15 - e;
      for (i = 0; i < n; ++i)
        if (s[i])
          for (
            var c = (i << 4) | s[i],
              h = e - s[i],
              u = o[s[i] - 1]++ << h,
              d = u | ((1 << h) - 1);
            u <= d;
            ++u
          )
            a[Ts[u] >>> l] = c;
    } else
      for (a = new Wt(n), i = 0; i < n; ++i)
        s[i] && (a[i] = Ts[o[s[i] - 1]++] >>> (15 - s[i]));
    return a;
  },
  Kn = new nt(288);
for (var wt = 0; wt < 144; ++wt) Kn[wt] = 8;
for (var wt = 144; wt < 256; ++wt) Kn[wt] = 9;
for (var wt = 256; wt < 280; ++wt) Kn[wt] = 7;
for (var wt = 280; wt < 288; ++wt) Kn[wt] = 8;
var Er = new nt(32);
for (var wt = 0; wt < 32; ++wt) Er[wt] = 5;
var Id = vn(Kn, 9, 0),
  Dd = vn(Kn, 9, 1),
  Fd = vn(Er, 5, 0),
  Nd = vn(Er, 5, 1),
  bo = function (s) {
    for (var e = s[0], t = 1; t < s.length; ++t) s[t] > e && (e = s[t]);
    return e;
  },
  pn = function (s, e, t) {
    var n = (e / 8) | 0;
    return ((s[n] | (s[n + 1] << 8)) >> (e & 7)) & t;
  },
  Mo = function (s, e) {
    var t = (e / 8) | 0;
    return (s[t] | (s[t + 1] << 8) | (s[t + 2] << 16)) >> (e & 7);
  },
  Ps = function (s) {
    return ((s / 8) | 0) + (s & 7 && 1);
  },
  xn = function (s, e, t) {
    (e == null || e < 0) && (e = 0),
      (t == null || t > s.length) && (t = s.length);
    var n = new (s instanceof Wt ? Wt : s instanceof $n ? $n : nt)(t - e);
    return n.set(s.subarray(e, t)), n;
  },
  Is = function (s, e, t) {
    var n = s.length;
    if (!n || (t && !t.l && n < 5)) return e || new nt(0);
    var i = !e || t,
      r = !t || t.i;
    t || (t = {}), e || (e = new nt(n * 3));
    var o = function (Z) {
        var qe = e.length;
        if (Z > qe) {
          var ke = new nt(Math.max(qe * 2, Z));
          ke.set(e), (e = ke);
        }
      },
      a = t.f || 0,
      l = t.p || 0,
      c = t.b || 0,
      h = t.l,
      u = t.d,
      d = t.m,
      f = t.n,
      m = n * 8;
    do {
      if (!h) {
        t.f = a = pn(s, l, 1);
        var v = pn(s, l + 1, 3);
        if (((l += 3), v))
          if (v == 1) (h = Dd), (u = Nd), (d = 9), (f = 5);
          else if (v == 2) {
            var w = pn(s, l, 31) + 257,
              b = pn(s, l + 10, 15) + 4,
              _ = w + pn(s, l + 5, 31) + 1;
            l += 14;
            for (var E = new nt(_), L = new nt(19), D = 0; D < b; ++D)
              L[Ss[D]] = pn(s, l + D * 3, 7);
            l += b * 3;
            for (
              var V = bo(L), F = (1 << V) - 1, M = vn(L, V, 1), D = 0;
              D < _;

            ) {
              var A = M[pn(s, l, F)];
              l += A & 15;
              var y = A >>> 4;
              if (y < 16) E[D++] = y;
              else {
                var N = 0,
                  O = 0;
                for (
                  y == 16
                    ? ((O = 3 + pn(s, l, 3)), (l += 2), (N = E[D - 1]))
                    : y == 17
                    ? ((O = 3 + pn(s, l, 7)), (l += 3))
                    : y == 18 && ((O = 11 + pn(s, l, 127)), (l += 7));
                  O--;

                )
                  E[D++] = N;
              }
            }
            var H = E.subarray(0, w),
              G = E.subarray(w);
            (d = bo(H)), (f = bo(G)), (h = vn(H, d, 1)), (u = vn(G, f, 1));
          } else throw "invalid block type";
        else {
          var y = Ps(l) + 4,
            p = s[y - 4] | (s[y - 3] << 8),
            g = y + p;
          if (g > n) {
            if (r) throw "unexpected EOF";
            break;
          }
          i && o(c + p),
            e.set(s.subarray(y, g), c),
            (t.b = c += p),
            (t.p = l = g * 8);
          continue;
        }
        if (l > m) {
          if (r) throw "unexpected EOF";
          break;
        }
      }
      i && o(c + 131072);
      for (var W = (1 << d) - 1, k = (1 << f) - 1, Q = l; ; Q = l) {
        var N = h[Mo(s, l) & W],
          ie = N >>> 4;
        if (((l += N & 15), l > m)) {
          if (r) throw "unexpected EOF";
          break;
        }
        if (!N) throw "invalid length/literal";
        if (ie < 256) e[c++] = ie;
        else if (ie == 256) {
          (Q = l), (h = null);
          break;
        } else {
          var re = ie - 254;
          if (ie > 264) {
            var D = ie - 257,
              ee = Or[D];
            (re = pn(s, l, (1 << ee) - 1) + nc[D]), (l += ee);
          }
          var Me = u[Mo(s, l) & k],
            Be = Me >>> 4;
          if (!Me) throw "invalid distance";
          l += Me & 15;
          var G = Pd[Be];
          if (Be > 3) {
            var ee = Ur[Be];
            (G += Mo(s, l) & ((1 << ee) - 1)), (l += ee);
          }
          if (l > m) {
            if (r) throw "unexpected EOF";
            break;
          }
          i && o(c + 131072);
          for (var Re = c + re; c < Re; c += 4)
            (e[c] = e[c - G]),
              (e[c + 1] = e[c + 1 - G]),
              (e[c + 2] = e[c + 2 - G]),
              (e[c + 3] = e[c + 3 - G]);
          c = Re;
        }
      }
      (t.l = h),
        (t.p = Q),
        (t.b = c),
        h && ((a = 1), (t.m = d), (t.d = u), (t.n = f));
    } while (!a);
    return c == e.length ? e : xn(e, 0, c);
  },
  An = function (s, e, t) {
    t <<= e & 7;
    var n = (e / 8) | 0;
    (s[n] |= t), (s[n + 1] |= t >>> 8);
  },
  or = function (s, e, t) {
    t <<= e & 7;
    var n = (e / 8) | 0;
    (s[n] |= t), (s[n + 1] |= t >>> 8), (s[n + 2] |= t >>> 16);
  },
  So = function (s, e) {
    for (var t = [], n = 0; n < s.length; ++n)
      s[n] && t.push({ s: n, f: s[n] });
    var i = t.length,
      r = t.slice();
    if (!i) return [jn, 0];
    if (i == 1) {
      var o = new nt(t[0].s + 1);
      return (o[t[0].s] = 1), [o, 1];
    }
    t.sort(function (_, E) {
      return _.f - E.f;
    }),
      t.push({ s: -1, f: 25001 });
    var a = t[0],
      l = t[1],
      c = 0,
      h = 1,
      u = 2;
    for (t[0] = { s: -1, f: a.f + l.f, l: a, r: l }; h != i - 1; )
      (a = t[t[c].f < t[u].f ? c++ : u++]),
        (l = t[c != h && t[c].f < t[u].f ? c++ : u++]),
        (t[h++] = { s: -1, f: a.f + l.f, l: a, r: l });
    for (var d = r[0].s, n = 1; n < i; ++n) r[n].s > d && (d = r[n].s);
    var f = new Wt(d + 1),
      m = Fo(t[h - 1], f, 0);
    if (m > e) {
      var n = 0,
        v = 0,
        y = m - e,
        p = 1 << y;
      for (
        r.sort(function (E, L) {
          return f[L.s] - f[E.s] || E.f - L.f;
        });
        n < i;
        ++n
      ) {
        var g = r[n].s;
        if (f[g] > e) (v += p - (1 << (m - f[g]))), (f[g] = e);
        else break;
      }
      for (v >>>= y; v > 0; ) {
        var w = r[n].s;
        f[w] < e ? (v -= 1 << (e - f[w]++ - 1)) : ++n;
      }
      for (; n >= 0 && v; --n) {
        var b = r[n].s;
        f[b] == e && (--f[b], ++v);
      }
      m = e;
    }
    return [new nt(f), m];
  },
  Fo = function (s, e, t) {
    return s.s == -1
      ? Math.max(Fo(s.l, e, t + 1), Fo(s.r, e, t + 1))
      : (e[s.s] = t);
  },
  Ml = function (s) {
    for (var e = s.length; e && !s[--e]; );
    for (
      var t = new Wt(++e),
        n = 0,
        i = s[0],
        r = 1,
        o = function (l) {
          t[n++] = l;
        },
        a = 1;
      a <= e;
      ++a
    )
      if (s[a] == i && a != e) ++r;
      else {
        if (!i && r > 2) {
          for (; r > 138; r -= 138) o(32754);
          r > 2 &&
            (o(r > 10 ? ((r - 11) << 5) | 28690 : ((r - 3) << 5) | 12305),
            (r = 0));
        } else if (r > 3) {
          for (o(i), --r; r > 6; r -= 6) o(8304);
          r > 2 && (o(((r - 3) << 5) | 8208), (r = 0));
        }
        for (; r--; ) o(i);
        (r = 1), (i = s[a]);
      }
    return [t.subarray(0, n), e];
  },
  ar = function (s, e) {
    for (var t = 0, n = 0; n < e.length; ++n) t += s[n] * e[n];
    return t;
  },
  us = function (s, e, t) {
    var n = t.length,
      i = Ps(e + 2);
    (s[i] = n & 255),
      (s[i + 1] = n >>> 8),
      (s[i + 2] = s[i] ^ 255),
      (s[i + 3] = s[i + 1] ^ 255);
    for (var r = 0; r < n; ++r) s[i + r + 4] = t[r];
    return (i + 4 + n) * 8;
  },
  Sl = function (s, e, t, n, i, r, o, a, l, c, h) {
    An(e, h++, t), ++i[256];
    for (
      var u = So(i, 15),
        d = u[0],
        f = u[1],
        m = So(r, 15),
        v = m[0],
        y = m[1],
        p = Ml(d),
        g = p[0],
        w = p[1],
        b = Ml(v),
        _ = b[0],
        E = b[1],
        L = new Wt(19),
        D = 0;
      D < g.length;
      ++D
    )
      L[g[D] & 31]++;
    for (var D = 0; D < _.length; ++D) L[_[D] & 31]++;
    for (
      var V = So(L, 7), F = V[0], M = V[1], A = 19;
      A > 4 && !F[Ss[A - 1]];
      --A
    );
    var N = (c + 5) << 3,
      O = ar(i, Kn) + ar(r, Er) + o,
      H =
        ar(i, d) +
        ar(r, v) +
        o +
        14 +
        3 * A +
        ar(L, F) +
        (2 * L[16] + 3 * L[17] + 7 * L[18]);
    if (N <= O && N <= H) return us(e, h, s.subarray(l, l + c));
    var G, W, k, Q;
    if ((An(e, h, 1 + (H < O)), (h += 2), H < O)) {
      (G = vn(d, f, 0)), (W = d), (k = vn(v, y, 0)), (Q = v);
      var ie = vn(F, M, 0);
      An(e, h, w - 257), An(e, h + 5, E - 1), An(e, h + 10, A - 4), (h += 14);
      for (var D = 0; D < A; ++D) An(e, h + 3 * D, F[Ss[D]]);
      h += 3 * A;
      for (var re = [g, _], ee = 0; ee < 2; ++ee)
        for (var Me = re[ee], D = 0; D < Me.length; ++D) {
          var Be = Me[D] & 31;
          An(e, h, ie[Be]),
            (h += F[Be]),
            Be > 15 && (An(e, h, (Me[D] >>> 5) & 127), (h += Me[D] >>> 12));
        }
    } else (G = Id), (W = Kn), (k = Fd), (Q = Er);
    for (var D = 0; D < a; ++D)
      if (n[D] > 255) {
        var Be = (n[D] >>> 18) & 31;
        or(e, h, G[Be + 257]),
          (h += W[Be + 257]),
          Be > 7 && (An(e, h, (n[D] >>> 23) & 31), (h += Or[Be]));
        var Re = n[D] & 31;
        or(e, h, k[Re]),
          (h += Q[Re]),
          Re > 3 && (or(e, h, (n[D] >>> 5) & 8191), (h += Ur[Re]));
      } else or(e, h, G[n[D]]), (h += W[n[D]]);
    return or(e, h, G[256]), h + W[256];
  },
  Bd = new $n([
    65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632,
  ]),
  jn = new nt(0),
  Od = function (s, e, t, n, i, r) {
    var o = s.length,
      a = new nt(n + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
      l = a.subarray(n, a.length - i),
      c = 0;
    if (!e || o < 8)
      for (var h = 0; h <= o; h += 65535) {
        var u = h + 65535;
        u < o
          ? (c = us(l, c, s.subarray(h, u)))
          : ((l[h] = r), (c = us(l, c, s.subarray(h, o))));
      }
    else {
      for (
        var d = Bd[e - 1],
          f = d >>> 13,
          m = d & 8191,
          v = (1 << t) - 1,
          y = new Wt(32768),
          p = new Wt(v + 1),
          g = Math.ceil(t / 3),
          w = 2 * g,
          b = function (pe) {
            return (s[pe] ^ (s[pe + 1] << g) ^ (s[pe + 2] << w)) & v;
          },
          _ = new $n(25e3),
          E = new Wt(288),
          L = new Wt(32),
          D = 0,
          V = 0,
          h = 0,
          F = 0,
          M = 0,
          A = 0;
        h < o;
        ++h
      ) {
        var N = b(h),
          O = h & 32767,
          H = p[N];
        if (((y[O] = H), (p[N] = O), M <= h)) {
          var G = o - h;
          if ((D > 7e3 || F > 24576) && G > 423) {
            (c = Sl(s, l, 0, _, E, L, V, F, A, h - A, c)),
              (F = D = V = 0),
              (A = h);
            for (var W = 0; W < 286; ++W) E[W] = 0;
            for (var W = 0; W < 30; ++W) L[W] = 0;
          }
          var k = 2,
            Q = 0,
            ie = m,
            re = (O - H) & 32767;
          if (G > 2 && N == b(h - re))
            for (
              var ee = Math.min(f, G) - 1,
                Me = Math.min(32767, h),
                Be = Math.min(258, G);
              re <= Me && --ie && O != H;

            ) {
              if (s[h + k] == s[h + k - re]) {
                for (var Re = 0; Re < Be && s[h + Re] == s[h + Re - re]; ++Re);
                if (Re > k) {
                  if (((k = Re), (Q = re), Re > ee)) break;
                  for (
                    var Z = Math.min(re, Re - 2), qe = 0, W = 0;
                    W < Z;
                    ++W
                  ) {
                    var ke = (h - re + W + 32768) & 32767,
                      Fe = y[ke],
                      Ie = (ke - Fe + 32768) & 32767;
                    Ie > qe && ((qe = Ie), (H = ke));
                  }
                }
              }
              (O = H), (H = y[O]), (re += (O - H + 32768) & 32767);
            }
          if (Q) {
            _[F++] = 268435456 | (Do[k] << 18) | bl[Q];
            var Ze = Do[k] & 31,
              K = bl[Q] & 31;
            (V += Or[Ze] + Ur[K]), ++E[257 + Ze], ++L[K], (M = h + k), ++D;
          } else (_[F++] = s[h]), ++E[s[h]];
        }
      }
      (c = Sl(s, l, r, _, E, L, V, F, A, h - A, c)),
        !r && c & 7 && (c = us(l, c + 1, jn));
    }
    return xn(a, 0, n + Ps(c) + i);
  },
  Ud = (function () {
    for (var s = new $n(256), e = 0; e < 256; ++e) {
      for (var t = e, n = 9; --n; ) t = (t & 1 && 3988292384) ^ (t >>> 1);
      s[e] = t;
    }
    return s;
  })(),
  zr = function () {
    var s = -1;
    return {
      p: function (e) {
        for (var t = s, n = 0; n < e.length; ++n)
          t = Ud[(t & 255) ^ e[n]] ^ (t >>> 8);
        s = t;
      },
      d: function () {
        return ~s;
      },
    };
  },
  ic = function () {
    var s = 1,
      e = 0;
    return {
      p: function (t) {
        for (var n = s, i = e, r = t.length, o = 0; o != r; ) {
          for (var a = Math.min(o + 2655, r); o < a; ++o) i += n += t[o];
          (n = (n & 65535) + 15 * (n >> 16)),
            (i = (i & 65535) + 15 * (i >> 16));
        }
        (s = n), (e = i);
      },
      d: function () {
        return (
          (s %= 65521),
          (e %= 65521),
          ((s & 255) << 24) | ((s >>> 8) << 16) | ((e & 255) << 8) | (e >>> 8)
        );
      },
    };
  },
  Bi = function (s, e, t, n, i) {
    return Od(
      s,
      e.level == null ? 6 : e.level,
      e.mem == null
        ? Math.ceil(Math.max(8, Math.min(13, Math.log(s.length))) * 1.5)
        : 12 + e.mem,
      t,
      n,
      !i
    );
  },
  Ds = function (s, e) {
    var t = {};
    for (var n in s) t[n] = s[n];
    for (var n in e) t[n] = e[n];
    return t;
  },
  nu = function (s, e, t) {
    for (
      var n = s(),
        i = s.toString(),
        r = i
          .slice(i.indexOf("[") + 1, i.lastIndexOf("]"))
          .replace(/ /g, "")
          .split(","),
        o = 0;
      o < n.length;
      ++o
    ) {
      var a = n[o],
        l = r[o];
      if (typeof a == "function") {
        e += ";" + l + "=";
        var c = a.toString();
        if (a.prototype)
          if (c.indexOf("[native code]") != -1) {
            var h = c.indexOf(" ", 8) + 1;
            e += c.slice(h, c.indexOf("(", h));
          } else {
            e += c;
            for (var u in a.prototype)
              e +=
                ";" + l + ".prototype." + u + "=" + a.prototype[u].toString();
          }
        else e += c;
      } else t[l] = a;
    }
    return [e, t];
  },
  vo = [],
  g_ = function (s) {
    var e = [];
    for (var t in s)
      (s[t] instanceof nt || s[t] instanceof Wt || s[t] instanceof $n) &&
        e.push((s[t] = new s[t].constructor(s[t])).buffer);
    return e;
  },
  zd = function (s, e, t, n) {
    var i;
    if (!vo[t]) {
      for (var r = "", o = {}, a = s.length - 1, l = 0; l < a; ++l)
        (i = nu(s[l], r, o)), (r = i[0]), (o = i[1]);
      vo[t] = nu(s[a], r, o);
    }
    var c = Ds({}, vo[t][1]);
    return m_(
      vo[t][0] +
        ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" +
        e.toString() +
        "}",
      t,
      c,
      g_(c),
      n
    );
  },
  kr = function () {
    return [
      nt,
      Wt,
      $n,
      Or,
      Ur,
      Ss,
      nc,
      Pd,
      Dd,
      Nd,
      Ts,
      vn,
      bo,
      pn,
      Mo,
      Ps,
      xn,
      Is,
      Wr,
      bi,
      rc,
    ];
  },
  Hr = function () {
    return [
      nt,
      Wt,
      $n,
      Or,
      Ur,
      Ss,
      Do,
      bl,
      Id,
      Kn,
      Fd,
      Er,
      Ts,
      Bd,
      jn,
      vn,
      An,
      or,
      So,
      Fo,
      Ml,
      ar,
      us,
      Sl,
      Ps,
      xn,
      Od,
      Bi,
      Fs,
      bi,
    ];
  },
  kd = function () {
    return [sc, ac, ht, zr, Ud];
  },
  Hd = function () {
    return [oc, Wd];
  },
  Gd = function () {
    return [lc, ht, ic];
  },
  Vd = function () {
    return [Xd];
  },
  bi = function (s) {
    return postMessage(s, [s.buffer]);
  },
  rc = function (s) {
    return s && s.size && new nt(s.size);
  },
  Gr = function (s, e, t, n, i, r) {
    var o = zd(t, n, i, function (a, l) {
      o.terminate(), r(a, l);
    });
    return (
      o.postMessage([s, e], e.consume ? [s.buffer] : []),
      function () {
        o.terminate();
      }
    );
  },
  yn = function (s) {
    return (
      (s.ondata = function (e, t) {
        return postMessage([e, t], [e.buffer]);
      }),
      function (e) {
        return s.push(e.data[0], e.data[1]);
      }
    );
  },
  Vr = function (s, e, t, n, i) {
    var r,
      o = zd(s, n, i, function (a, l) {
        a
          ? (o.terminate(), e.ondata.call(e, a))
          : (l[1] && o.terminate(), e.ondata.call(e, a, l[0], l[1]));
      });
    o.postMessage(t),
      (e.push = function (a, l) {
        if (r) throw "stream finished";
        if (!e.ondata) throw "no stream handler";
        o.postMessage([a, (r = l)], [a.buffer]);
      }),
      (e.terminate = function () {
        o.terminate();
      });
  },
  Jt = function (s, e) {
    return s[e] | (s[e + 1] << 8);
  },
  It = function (s, e) {
    return (s[e] | (s[e + 1] << 8) | (s[e + 2] << 16) | (s[e + 3] << 24)) >>> 0;
  },
  Xa = function (s, e) {
    return It(s, e) + It(s, e + 4) * 4294967296;
  },
  ht = function (s, e, t) {
    for (; t; ++e) (s[e] = t), (t >>>= 8);
  },
  sc = function (s, e) {
    var t = e.filename;
    if (
      ((s[0] = 31),
      (s[1] = 139),
      (s[2] = 8),
      (s[8] = e.level < 2 ? 4 : e.level == 9 ? 2 : 0),
      (s[9] = 3),
      e.mtime != 0 &&
        ht(s, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)),
      t)
    ) {
      s[3] = 8;
      for (var n = 0; n <= t.length; ++n) s[n + 10] = t.charCodeAt(n);
    }
  },
  oc = function (s) {
    if (s[0] != 31 || s[1] != 139 || s[2] != 8) throw "invalid gzip data";
    var e = s[3],
      t = 10;
    e & 4 && (t += s[10] | ((s[11] << 8) + 2));
    for (var n = ((e >> 3) & 1) + ((e >> 4) & 1); n > 0; n -= !s[t++]);
    return t + (e & 2);
  },
  Wd = function (s) {
    var e = s.length;
    return (
      (s[e - 4] | (s[e - 3] << 8) | (s[e - 2] << 16) | (s[e - 1] << 24)) >>> 0
    );
  },
  ac = function (s) {
    return 10 + ((s.filename && s.filename.length + 1) || 0);
  },
  lc = function (s, e) {
    var t = e.level,
      n = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
    (s[0] = 120), (s[1] = (n << 6) | (n ? 32 - 2 * n : 1));
  },
  Xd = function (s) {
    if ((s[0] & 15) != 8 || s[0] >>> 4 > 7 || ((s[0] << 8) | s[1]) % 31)
      throw "invalid zlib data";
    if (s[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
  };
function cc(s, e) {
  return (
    !e && typeof s == "function" && ((e = s), (s = {})), (this.ondata = e), s
  );
}
var Fn = (function () {
    function s(e, t) {
      !t && typeof e == "function" && ((t = e), (e = {})),
        (this.ondata = t),
        (this.o = e || {});
    }
    return (
      (s.prototype.p = function (e, t) {
        this.ondata(Bi(e, this.o, 0, 0, !t), t);
      }),
      (s.prototype.push = function (e, t) {
        if (this.d) throw "stream finished";
        if (!this.ondata) throw "no stream handler";
        (this.d = t), this.p(e, t || !1);
      }),
      s
    );
  })(),
  jd = (function () {
    function s(e, t) {
      Vr(
        [
          Hr,
          function () {
            return [yn, Fn];
          },
        ],
        this,
        cc.call(this, e, t),
        function (n) {
          var i = new Fn(n.data);
          onmessage = yn(i);
        },
        6
      );
    }
    return s;
  })();
function qd(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  return Gr(
    s,
    e,
    [Hr],
    function (n) {
      return bi(Fs(n.data[0], n.data[1]));
    },
    0,
    t
  );
}
function Fs(s, e) {
  return Bi(s, e || {}, 0, 0);
}
var rn = (function () {
    function s(e) {
      (this.s = {}), (this.p = new nt(0)), (this.ondata = e);
    }
    return (
      (s.prototype.e = function (e) {
        if (this.d) throw "stream finished";
        if (!this.ondata) throw "no stream handler";
        var t = this.p.length,
          n = new nt(t + e.length);
        n.set(this.p), n.set(e, t), (this.p = n);
      }),
      (s.prototype.c = function (e) {
        this.d = this.s.i = e || !1;
        var t = this.s.b,
          n = Is(this.p, this.o, this.s);
        this.ondata(xn(n, t, this.s.b), this.d),
          (this.o = xn(n, this.s.b - 32768)),
          (this.s.b = this.o.length),
          (this.p = xn(this.p, (this.s.p / 8) | 0)),
          (this.s.p &= 7);
      }),
      (s.prototype.push = function (e, t) {
        this.e(e), this.c(t);
      }),
      s
    );
  })(),
  hc = (function () {
    function s(e) {
      (this.ondata = e),
        Vr(
          [
            kr,
            function () {
              return [yn, rn];
            },
          ],
          this,
          0,
          function () {
            var t = new rn();
            onmessage = yn(t);
          },
          7
        );
    }
    return s;
  })();
function uc(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  return Gr(
    s,
    e,
    [kr],
    function (n) {
      return bi(Wr(n.data[0], rc(n.data[1])));
    },
    1,
    t
  );
}
function Wr(s, e) {
  return Is(s, e);
}
var No = (function () {
    function s(e, t) {
      (this.c = zr()), (this.l = 0), (this.v = 1), Fn.call(this, e, t);
    }
    return (
      (s.prototype.push = function (e, t) {
        Fn.prototype.push.call(this, e, t);
      }),
      (s.prototype.p = function (e, t) {
        this.c.p(e), (this.l += e.length);
        var n = Bi(e, this.o, this.v && ac(this.o), t && 8, !t);
        this.v && (sc(n, this.o), (this.v = 0)),
          t && (ht(n, n.length - 8, this.c.d()), ht(n, n.length - 4, this.l)),
          this.ondata(n, t);
      }),
      s
    );
  })(),
  iu = (function () {
    function s(e, t) {
      Vr(
        [
          Hr,
          kd,
          function () {
            return [yn, Fn, No];
          },
        ],
        this,
        cc.call(this, e, t),
        function (n) {
          var i = new No(n.data);
          onmessage = yn(i);
        },
        8
      );
    }
    return s;
  })();
function ru(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  return Gr(
    s,
    e,
    [
      Hr,
      kd,
      function () {
        return [Bo];
      },
    ],
    function (n) {
      return bi(Bo(n.data[0], n.data[1]));
    },
    2,
    t
  );
}
function Bo(s, e) {
  e || (e = {});
  var t = zr(),
    n = s.length;
  t.p(s);
  var i = Bi(s, e, ac(e), 8),
    r = i.length;
  return sc(i, e), ht(i, r - 8, t.d()), ht(i, r - 4, n), i;
}
var Oo = (function () {
    function s(e) {
      (this.v = 1), rn.call(this, e);
    }
    return (
      (s.prototype.push = function (e, t) {
        if ((rn.prototype.e.call(this, e), this.v)) {
          var n = this.p.length > 3 ? oc(this.p) : 4;
          if (n >= this.p.length && !t) return;
          (this.p = this.p.subarray(n)), (this.v = 0);
        }
        if (t) {
          if (this.p.length < 8) throw "invalid gzip stream";
          this.p = this.p.subarray(0, -8);
        }
        rn.prototype.c.call(this, t);
      }),
      s
    );
  })(),
  Yd = (function () {
    function s(e) {
      (this.ondata = e),
        Vr(
          [
            kr,
            Hd,
            function () {
              return [yn, rn, Oo];
            },
          ],
          this,
          0,
          function () {
            var t = new Oo();
            onmessage = yn(t);
          },
          9
        );
    }
    return s;
  })();
function Zd(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  return Gr(
    s,
    e,
    [
      kr,
      Hd,
      function () {
        return [Uo];
      },
    ],
    function (n) {
      return bi(Uo(n.data[0]));
    },
    3,
    t
  );
}
function Uo(s, e) {
  return Is(s.subarray(oc(s), -8), e || new nt(Wd(s)));
}
var Tl = (function () {
    function s(e, t) {
      (this.c = ic()), (this.v = 1), Fn.call(this, e, t);
    }
    return (
      (s.prototype.push = function (e, t) {
        Fn.prototype.push.call(this, e, t);
      }),
      (s.prototype.p = function (e, t) {
        this.c.p(e);
        var n = Bi(e, this.o, this.v && 2, t && 4, !t);
        this.v && (lc(n, this.o), (this.v = 0)),
          t && ht(n, n.length - 4, this.c.d()),
          this.ondata(n, t);
      }),
      s
    );
  })(),
  v_ = (function () {
    function s(e, t) {
      Vr(
        [
          Hr,
          Gd,
          function () {
            return [yn, Fn, Tl];
          },
        ],
        this,
        cc.call(this, e, t),
        function (n) {
          var i = new Tl(n.data);
          onmessage = yn(i);
        },
        10
      );
    }
    return s;
  })();
function x_(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  return Gr(
    s,
    e,
    [
      Hr,
      Gd,
      function () {
        return [El];
      },
    ],
    function (n) {
      return bi(El(n.data[0], n.data[1]));
    },
    4,
    t
  );
}
function El(s, e) {
  e || (e = {});
  var t = ic();
  t.p(s);
  var n = Bi(s, e, 2, 4);
  return lc(n, e), ht(n, n.length - 4, t.d()), n;
}
var zo = (function () {
    function s(e) {
      (this.v = 1), rn.call(this, e);
    }
    return (
      (s.prototype.push = function (e, t) {
        if ((rn.prototype.e.call(this, e), this.v)) {
          if (this.p.length < 2 && !t) return;
          (this.p = this.p.subarray(2)), (this.v = 0);
        }
        if (t) {
          if (this.p.length < 4) throw "invalid zlib stream";
          this.p = this.p.subarray(0, -4);
        }
        rn.prototype.c.call(this, t);
      }),
      s
    );
  })(),
  $d = (function () {
    function s(e) {
      (this.ondata = e),
        Vr(
          [
            kr,
            Vd,
            function () {
              return [yn, rn, zo];
            },
          ],
          this,
          0,
          function () {
            var t = new zo();
            onmessage = yn(t);
          },
          11
        );
    }
    return s;
  })();
function Kd(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  return Gr(
    s,
    e,
    [
      kr,
      Vd,
      function () {
        return [qn];
      },
    ],
    function (n) {
      return bi(qn(n.data[0], rc(n.data[1])));
    },
    5,
    t
  );
}
function qn(s, e) {
  return Is((Xd(s), s.subarray(2, -4)), e);
}
var Jd = (function () {
    function s(e) {
      (this.G = Oo), (this.I = rn), (this.Z = zo), (this.ondata = e);
    }
    return (
      (s.prototype.push = function (e, t) {
        if (!this.ondata) throw "no stream handler";
        if (this.s) this.s.push(e, t);
        else {
          if (this.p && this.p.length) {
            var n = new nt(this.p.length + e.length);
            n.set(this.p), n.set(e, this.p.length);
          } else this.p = e;
          if (this.p.length > 2) {
            var i = this,
              r = function () {
                i.ondata.apply(i, arguments);
              };
            (this.s =
              this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8
                ? new this.G(r)
                : (this.p[0] & 15) != 8 ||
                  this.p[0] >> 4 > 7 ||
                  ((this.p[0] << 8) | this.p[1]) % 31
                ? new this.I(r)
                : new this.Z(r)),
              this.s.push(this.p, t),
              (this.p = null);
          }
        }
      }),
      s
    );
  })(),
  y_ = (function () {
    function s(e) {
      (this.G = Yd), (this.I = hc), (this.Z = $d), (this.ondata = e);
    }
    return (
      (s.prototype.push = function (e, t) {
        Jd.prototype.push.call(this, e, t);
      }),
      s
    );
  })();
function __(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  return s[0] == 31 && s[1] == 139 && s[2] == 8
    ? Zd(s, e, t)
    : (s[0] & 15) != 8 || s[0] >> 4 > 7 || ((s[0] << 8) | s[1]) % 31
    ? uc(s, e, t)
    : Kd(s, e, t);
}
function w_(s, e) {
  return s[0] == 31 && s[1] == 139 && s[2] == 8
    ? Uo(s, e)
    : (s[0] & 15) != 8 || s[0] >> 4 > 7 || ((s[0] << 8) | s[1]) % 31
    ? Wr(s, e)
    : qn(s, e);
}
var dc = function (s, e, t, n) {
    for (var i in s) {
      var r = s[i],
        o = e + i;
      r instanceof nt
        ? (t[o] = [r, n])
        : Array.isArray(r)
        ? (t[o] = [r[0], Ds(n, r[1])])
        : dc(r, o + "/", t, n);
    }
  },
  su = typeof TextEncoder != "undefined" && new TextEncoder(),
  Al = typeof TextDecoder != "undefined" && new TextDecoder(),
  Qd = 0;
try {
  Al.decode(jn, { stream: !0 }), (Qd = 1);
} catch {}
var ef = function (s) {
    for (var e = "", t = 0; ; ) {
      var n = s[t++],
        i = (n > 127) + (n > 223) + (n > 239);
      if (t + i > s.length) return [e, xn(s, t - 1)];
      i
        ? i == 3
          ? ((n =
              (((n & 15) << 18) |
                ((s[t++] & 63) << 12) |
                ((s[t++] & 63) << 6) |
                (s[t++] & 63)) -
              65536),
            (e += String.fromCharCode(55296 | (n >> 10), 56320 | (n & 1023))))
          : i & 1
          ? (e += String.fromCharCode(((n & 31) << 6) | (s[t++] & 63)))
          : (e += String.fromCharCode(
              ((n & 15) << 12) | ((s[t++] & 63) << 6) | (s[t++] & 63)
            ))
        : (e += String.fromCharCode(n));
    }
  },
  b_ = (function () {
    function s(e) {
      (this.ondata = e), Qd ? (this.t = new TextDecoder()) : (this.p = jn);
    }
    return (
      (s.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback";
        if (((t = !!t), this.t)) {
          if ((this.ondata(this.t.decode(e, { stream: !0 }), t), t)) {
            if (this.t.decode().length) throw "invalid utf-8 data";
            this.t = null;
          }
          return;
        }
        if (!this.p) throw "stream finished";
        var n = new nt(this.p.length + e.length);
        n.set(this.p), n.set(e, this.p.length);
        var i = ef(n),
          r = i[0],
          o = i[1];
        if (t) {
          if (o.length) throw "invalid utf-8 data";
          this.p = null;
        } else this.p = o;
        this.ondata(r, t);
      }),
      s
    );
  })(),
  M_ = (function () {
    function s(e) {
      this.ondata = e;
    }
    return (
      (s.prototype.push = function (e, t) {
        if (!this.ondata) throw "no callback";
        if (this.d) throw "stream finished";
        this.ondata(xi(e), (this.d = t || !1));
      }),
      s
    );
  })();
function xi(s, e) {
  if (e) {
    for (var t = new nt(s.length), n = 0; n < s.length; ++n)
      t[n] = s.charCodeAt(n);
    return t;
  }
  if (su) return su.encode(s);
  for (
    var i = s.length,
      r = new nt(s.length + (s.length >> 1)),
      o = 0,
      a = function (h) {
        r[o++] = h;
      },
      n = 0;
    n < i;
    ++n
  ) {
    if (o + 5 > r.length) {
      var l = new nt(o + 8 + ((i - n) << 1));
      l.set(r), (r = l);
    }
    var c = s.charCodeAt(n);
    c < 128 || e
      ? a(c)
      : c < 2048
      ? (a(192 | (c >> 6)), a(128 | (c & 63)))
      : c > 55295 && c < 57344
      ? ((c = (65536 + (c & (1023 << 10))) | (s.charCodeAt(++n) & 1023)),
        a(240 | (c >> 18)),
        a(128 | ((c >> 12) & 63)),
        a(128 | ((c >> 6) & 63)),
        a(128 | (c & 63)))
      : (a(224 | (c >> 12)), a(128 | ((c >> 6) & 63)), a(128 | (c & 63)));
  }
  return xn(r, 0, o);
}
function fc(s, e) {
  if (e) {
    for (var t = "", n = 0; n < s.length; n += 16384)
      t += String.fromCharCode.apply(null, s.subarray(n, n + 16384));
    return t;
  } else {
    if (Al) return Al.decode(s);
    var i = ef(s),
      r = i[0],
      o = i[1];
    if (o.length) throw "invalid utf-8 data";
    return r;
  }
}
var tf = function (s) {
    return s == 1 ? 3 : s < 6 ? 2 : s == 9 ? 1 : 0;
  },
  nf = function (s, e) {
    return e + 30 + Jt(s, e + 26) + Jt(s, e + 28);
  },
  rf = function (s, e, t) {
    var n = Jt(s, e + 28),
      i = fc(s.subarray(e + 46, e + 46 + n), !(Jt(s, e + 8) & 2048)),
      r = e + 46 + n,
      o = It(s, e + 20),
      a = t && o == 4294967295 ? sf(s, r) : [o, It(s, e + 24), It(s, e + 42)],
      l = a[0],
      c = a[1],
      h = a[2];
    return [Jt(s, e + 10), l, c, i, r + Jt(s, e + 30) + Jt(s, e + 32), h];
  },
  sf = function (s, e) {
    for (; Jt(s, e) != 1; e += 4 + Jt(s, e + 2));
    return [Xa(s, e + 12), Xa(s, e + 4), Xa(s, e + 20)];
  },
  fi = function (s) {
    var e = 0;
    if (s)
      for (var t in s) {
        var n = s[t].length;
        if (n > 65535) throw "extra field too long";
        e += n + 4;
      }
    return e;
  },
  Ar = function (s, e, t, n, i, r, o, a) {
    var l = n.length,
      c = t.extra,
      h = a && a.length,
      u = fi(c);
    ht(s, e, o != null ? 33639248 : 67324752),
      (e += 4),
      o != null && ((s[e++] = 20), (s[e++] = t.os)),
      (s[e] = 20),
      (e += 2),
      (s[e++] = (t.flag << 1) | (r == null && 8)),
      (s[e++] = i && 8),
      (s[e++] = t.compression & 255),
      (s[e++] = t.compression >> 8);
    var d = new Date(t.mtime == null ? Date.now() : t.mtime),
      f = d.getFullYear() - 1980;
    if (f < 0 || f > 119) throw "date not in range 1980-2099";
    if (
      (ht(
        s,
        e,
        (f << 25) |
          ((d.getMonth() + 1) << 21) |
          (d.getDate() << 16) |
          (d.getHours() << 11) |
          (d.getMinutes() << 5) |
          (d.getSeconds() >>> 1)
      ),
      (e += 4),
      r != null && (ht(s, e, t.crc), ht(s, e + 4, r), ht(s, e + 8, t.size)),
      ht(s, e + 12, l),
      ht(s, e + 14, u),
      (e += 16),
      o != null &&
        (ht(s, e, h), ht(s, e + 6, t.attrs), ht(s, e + 10, o), (e += 14)),
      s.set(n, e),
      (e += l),
      u)
    )
      for (var m in c) {
        var v = c[m],
          y = v.length;
        ht(s, e, +m), ht(s, e + 2, y), s.set(v, e + 4), (e += 4 + y);
      }
    return h && (s.set(a, e), (e += h)), e;
  },
  pc = function (s, e, t, n, i) {
    ht(s, e, 101010256),
      ht(s, e + 8, t),
      ht(s, e + 10, t),
      ht(s, e + 12, n),
      ht(s, e + 16, i);
  },
  Es = (function () {
    function s(e) {
      (this.filename = e),
        (this.c = zr()),
        (this.size = 0),
        (this.compression = 0);
    }
    return (
      (s.prototype.process = function (e, t) {
        this.ondata(null, e, t);
      }),
      (s.prototype.push = function (e, t) {
        if (!this.ondata)
          throw "no callback - add to ZIP archive before pushing";
        this.c.p(e),
          (this.size += e.length),
          t && (this.crc = this.c.d()),
          this.process(e, t || !1);
      }),
      s
    );
  })(),
  S_ = (function () {
    function s(e, t) {
      var n = this;
      t || (t = {}),
        Es.call(this, e),
        (this.d = new Fn(t, function (i, r) {
          n.ondata(null, i, r);
        })),
        (this.compression = 8),
        (this.flag = tf(t.level));
    }
    return (
      (s.prototype.process = function (e, t) {
        try {
          this.d.push(e, t);
        } catch (n) {
          this.ondata(n, null, t);
        }
      }),
      (s.prototype.push = function (e, t) {
        Es.prototype.push.call(this, e, t);
      }),
      s
    );
  })(),
  T_ = (function () {
    function s(e, t) {
      var n = this;
      t || (t = {}),
        Es.call(this, e),
        (this.d = new jd(t, function (i, r, o) {
          n.ondata(i, r, o);
        })),
        (this.compression = 8),
        (this.flag = tf(t.level)),
        (this.terminate = this.d.terminate);
    }
    return (
      (s.prototype.process = function (e, t) {
        this.d.push(e, t);
      }),
      (s.prototype.push = function (e, t) {
        Es.prototype.push.call(this, e, t);
      }),
      s
    );
  })(),
  E_ = (function () {
    function s(e) {
      (this.ondata = e), (this.u = []), (this.d = 1);
    }
    return (
      (s.prototype.add = function (e) {
        var t = this;
        if (this.d & 2) throw "stream finished";
        var n = xi(e.filename),
          i = n.length,
          r = e.comment,
          o = r && xi(r),
          a = i != e.filename.length || (o && r.length != o.length),
          l = i + fi(e.extra) + 30;
        if (i > 65535) throw "filename too long";
        var c = new nt(l);
        Ar(c, 0, e, n, a);
        var h = [c],
          u = function () {
            for (var y = 0, p = h; y < p.length; y++) {
              var g = p[y];
              t.ondata(null, g, !1);
            }
            h = [];
          },
          d = this.d;
        this.d = 0;
        var f = this.u.length,
          m = Ds(e, {
            f: n,
            u: a,
            o,
            t: function () {
              e.terminate && e.terminate();
            },
            r: function () {
              if ((u(), d)) {
                var y = t.u[f + 1];
                y ? y.r() : (t.d = 1);
              }
              d = 1;
            },
          }),
          v = 0;
        (e.ondata = function (y, p, g) {
          if (y) t.ondata(y, p, g), t.terminate();
          else if (((v += p.length), h.push(p), g)) {
            var w = new nt(16);
            ht(w, 0, 134695760),
              ht(w, 4, e.crc),
              ht(w, 8, v),
              ht(w, 12, e.size),
              h.push(w),
              (m.c = v),
              (m.b = l + v + 16),
              (m.crc = e.crc),
              (m.size = e.size),
              d && m.r(),
              (d = 1);
          } else d && u();
        }),
          this.u.push(m);
      }),
      (s.prototype.end = function () {
        var e = this;
        if (this.d & 2)
          throw this.d & 1 ? "stream finishing" : "stream finished";
        this.d
          ? this.e()
          : this.u.push({
              r: function () {
                !(e.d & 1) || (e.u.splice(-1, 1), e.e());
              },
              t: function () {},
            }),
          (this.d = 3);
      }),
      (s.prototype.e = function () {
        for (var e = 0, t = 0, n = 0, i = 0, r = this.u; i < r.length; i++) {
          var o = r[i];
          n += 46 + o.f.length + fi(o.extra) + (o.o ? o.o.length : 0);
        }
        for (var a = new nt(n + 22), l = 0, c = this.u; l < c.length; l++) {
          var o = c[l];
          Ar(a, e, o, o.f, o.u, o.c, t, o.o),
            (e += 46 + o.f.length + fi(o.extra) + (o.o ? o.o.length : 0)),
            (t += o.b);
        }
        pc(a, e, this.u.length, n, t), this.ondata(null, a, !0), (this.d = 2);
      }),
      (s.prototype.terminate = function () {
        for (var e = 0, t = this.u; e < t.length; e++) {
          var n = t[e];
          n.t();
        }
        this.d = 2;
      }),
      s
    );
  })();
function A_(s, e, t) {
  if ((t || ((t = e), (e = {})), typeof t != "function")) throw "no callback";
  var n = {};
  dc(s, "", n, e);
  var i = Object.keys(n),
    r = i.length,
    o = 0,
    a = 0,
    l = r,
    c = new Array(r),
    h = [],
    u = function () {
      for (var v = 0; v < h.length; ++v) h[v]();
    },
    d = function () {
      var v = new nt(a + 22),
        y = o,
        p = a - o;
      a = 0;
      for (var g = 0; g < l; ++g) {
        var w = c[g];
        try {
          var b = w.c.length;
          Ar(v, a, w, w.f, w.u, b);
          var _ = 30 + w.f.length + fi(w.extra),
            E = a + _;
          v.set(w.c, E),
            Ar(v, o, w, w.f, w.u, b, a, w.m),
            (o += 16 + _ + (w.m ? w.m.length : 0)),
            (a = E + b);
        } catch (L) {
          return t(L, null);
        }
      }
      pc(v, o, c.length, p, y), t(null, v);
    };
  r || d();
  for (
    var f = function (v) {
        var y = i[v],
          p = n[y],
          g = p[0],
          w = p[1],
          b = zr(),
          _ = g.length;
        b.p(g);
        var E = xi(y),
          L = E.length,
          D = w.comment,
          V = D && xi(D),
          F = V && V.length,
          M = fi(w.extra),
          A = w.level == 0 ? 0 : 8,
          N = function (O, H) {
            if (O) u(), t(O, null);
            else {
              var G = H.length;
              (c[v] = Ds(w, {
                size: _,
                crc: b.d(),
                c: H,
                f: E,
                m: V,
                u: L != y.length || (V && D.length != F),
                compression: A,
              })),
                (o += 30 + L + M + G),
                (a += 76 + 2 * (L + M) + (F || 0) + G),
                --r || d();
            }
          };
        if ((L > 65535 && N("filename too long", null), !A)) N(null, g);
        else if (_ < 16e4)
          try {
            N(null, Fs(g, w));
          } catch (O) {
            N(O, null);
          }
        else h.push(qd(g, w, N));
      },
      m = 0;
    m < l;
    ++m
  )
    f(m);
  return u;
}
function C_(s, e) {
  e || (e = {});
  var t = {},
    n = [];
  dc(s, "", t, e);
  var i = 0,
    r = 0;
  for (var o in t) {
    var a = t[o],
      l = a[0],
      c = a[1],
      h = c.level == 0 ? 0 : 8,
      u = xi(o),
      d = u.length,
      f = c.comment,
      m = f && xi(f),
      v = m && m.length,
      y = fi(c.extra);
    if (d > 65535) throw "filename too long";
    var p = h ? Fs(l, c) : l,
      g = p.length,
      w = zr();
    w.p(l),
      n.push(
        Ds(c, {
          size: l.length,
          crc: w.d(),
          c: p,
          f: u,
          m,
          u: d != o.length || (m && f.length != v),
          o: i,
          compression: h,
        })
      ),
      (i += 30 + d + y + g),
      (r += 76 + 2 * (d + y) + (v || 0) + g);
  }
  for (var b = new nt(r + 22), _ = i, E = r - i, L = 0; L < n.length; ++L) {
    var u = n[L];
    Ar(b, u.o, u, u.f, u.u, u.c.length);
    var D = 30 + u.f.length + fi(u.extra);
    b.set(u.c, u.o + D),
      Ar(b, i, u, u.f, u.u, u.c.length, u.o, u.m),
      (i += 16 + D + (u.m ? u.m.length : 0));
  }
  return pc(b, i, n.length, E, _), b;
}
var of = (function () {
    function s() {}
    return (
      (s.prototype.push = function (e, t) {
        this.ondata(null, e, t);
      }),
      (s.compression = 0),
      s
    );
  })(),
  R_ = (function () {
    function s() {
      var e = this;
      this.i = new rn(function (t, n) {
        e.ondata(null, t, n);
      });
    }
    return (
      (s.prototype.push = function (e, t) {
        try {
          this.i.push(e, t);
        } catch (n) {
          this.ondata(n, e, t);
        }
      }),
      (s.compression = 8),
      s
    );
  })(),
  L_ = (function () {
    function s(e, t) {
      var n = this;
      t < 32e4
        ? (this.i = new rn(function (i, r) {
            n.ondata(null, i, r);
          }))
        : ((this.i = new hc(function (i, r, o) {
            n.ondata(i, r, o);
          })),
          (this.terminate = this.i.terminate));
    }
    return (
      (s.prototype.push = function (e, t) {
        this.i.terminate && (e = xn(e, 0)), this.i.push(e, t);
      }),
      (s.compression = 8),
      s
    );
  })(),
  P_ = (function () {
    function s(e) {
      (this.onfile = e), (this.k = []), (this.o = { 0: of }), (this.p = jn);
    }
    return (
      (s.prototype.push = function (e, t) {
        var n = this;
        if (!this.onfile) throw "no callback";
        if (!this.p) throw "stream finished";
        if (this.c > 0) {
          var i = Math.min(this.c, e.length),
            r = e.subarray(0, i);
          if (
            ((this.c -= i),
            this.d ? this.d.push(r, !this.c) : this.k[0].push(r),
            (e = e.subarray(i)),
            e.length)
          )
            return this.push(e, t);
        } else {
          var o = 0,
            a = 0,
            l = void 0,
            c = void 0;
          this.p.length
            ? e.length
              ? ((c = new nt(this.p.length + e.length)),
                c.set(this.p),
                c.set(e, this.p.length))
              : (c = this.p)
            : (c = e);
          for (
            var h = c.length,
              u = this.c,
              d = u && this.d,
              f = function () {
                var p,
                  g = It(c, a);
                if (g == 67324752) {
                  (o = 1), (l = a), (m.d = null), (m.c = 0);
                  var w = Jt(c, a + 6),
                    b = Jt(c, a + 8),
                    _ = w & 2048,
                    E = w & 8,
                    L = Jt(c, a + 26),
                    D = Jt(c, a + 28);
                  if (h > a + 30 + L + D) {
                    var V = [];
                    m.k.unshift(V), (o = 2);
                    var F = It(c, a + 18),
                      M = It(c, a + 22),
                      A = fc(c.subarray(a + 30, (a += 30 + L)), !_);
                    F == 4294967295
                      ? ((p = E ? [-2] : sf(c, a)), (F = p[0]), (M = p[1]))
                      : E && (F = -1),
                      (a += D),
                      (m.c = F);
                    var N,
                      O = {
                        name: A,
                        compression: b,
                        start: function () {
                          if (!O.ondata) throw "no callback";
                          if (!F) O.ondata(null, jn, !0);
                          else {
                            var H = n.o[b];
                            if (!H) throw "unknown compression type " + b;
                            (N = F < 0 ? new H(A) : new H(A, F, M)),
                              (N.ondata = function (Q, ie, re) {
                                O.ondata(Q, ie, re);
                              });
                            for (var G = 0, W = V; G < W.length; G++) {
                              var k = W[G];
                              N.push(k, !1);
                            }
                            n.k[0] == V && n.c ? (n.d = N) : N.push(jn, !0);
                          }
                        },
                        terminate: function () {
                          N && N.terminate && N.terminate();
                        },
                      };
                    F >= 0 && ((O.size = F), (O.originalSize = M)), m.onfile(O);
                  }
                  return "break";
                } else if (u) {
                  if (g == 134695760)
                    return (
                      (l = a += 12 + (u == -2 && 8)),
                      (o = 3),
                      (m.c = 0),
                      "break"
                    );
                  if (g == 33639248)
                    return (l = a -= 4), (o = 3), (m.c = 0), "break";
                }
              },
              m = this;
            a < h - 4;
            ++a
          ) {
            var v = f();
            if (v === "break") break;
          }
          if (((this.p = jn), u < 0)) {
            var y = o
              ? c.subarray(
                  0,
                  l - 12 - (u == -2 && 8) - (It(c, l - 16) == 134695760 && 4)
                )
              : c.subarray(0, a);
            d ? d.push(y, !!o) : this.k[+(o == 2)].push(y);
          }
          if (o & 2) return this.push(c.subarray(a), t);
          this.p = c.subarray(a);
        }
        if (t) {
          if (this.c) throw "invalid zip file";
          this.p = null;
        }
      }),
      (s.prototype.register = function (e) {
        this.o[e.compression] = e;
      }),
      s
    );
  })();
function I_(s, e) {
  if (typeof e != "function") throw "no callback";
  for (
    var t = [],
      n = function () {
        for (var d = 0; d < t.length; ++d) t[d]();
      },
      i = {},
      r = s.length - 22;
    It(s, r) != 101010256;
    --r
  )
    if (!r || s.length - r > 65558) {
      e("invalid zip file", null);
      return;
    }
  var o = Jt(s, r + 8);
  o || e(null, {});
  var a = o,
    l = It(s, r + 16),
    c = l == 4294967295;
  if (c) {
    if (((r = It(s, r - 12)), It(s, r) != 101075792)) {
      e("invalid zip file", null);
      return;
    }
    (a = o = It(s, r + 32)), (l = It(s, r + 48));
  }
  for (
    var h = function (d) {
        var f = rf(s, l, c),
          m = f[0],
          v = f[1],
          y = f[2],
          p = f[3],
          g = f[4],
          w = f[5],
          b = nf(s, w);
        l = g;
        var _ = function (L, D) {
          L ? (n(), e(L, null)) : ((i[p] = D), --o || e(null, i));
        };
        if (!m) _(null, xn(s, b, b + v));
        else if (m == 8) {
          var E = s.subarray(b, b + v);
          if (v < 32e4)
            try {
              _(null, Wr(E, new nt(y)));
            } catch (L) {
              _(L, null);
            }
          else t.push(uc(E, { size: y }, _));
        } else _("unknown compression type " + m, null);
      },
      u = 0;
    u < a;
    ++u
  )
    h();
  return n;
}
function D_(s) {
  for (var e = {}, t = s.length - 22; It(s, t) != 101010256; --t)
    if (!t || s.length - t > 65558) throw "invalid zip file";
  var n = Jt(s, t + 8);
  if (!n) return {};
  var i = It(s, t + 16),
    r = i == 4294967295;
  if (r) {
    if (((t = It(s, t - 12)), It(s, t) != 101075792)) throw "invalid zip file";
    (n = It(s, t + 32)), (i = It(s, t + 48));
  }
  for (var o = 0; o < n; ++o) {
    var a = rf(s, i, r),
      l = a[0],
      c = a[1],
      h = a[2],
      u = a[3],
      d = a[4],
      f = a[5],
      m = nf(s, f);
    if (((i = d), !l)) e[u] = xn(s, m, m + c);
    else if (l == 8) e[u] = Wr(s.subarray(m, m + c), new nt(h));
    else throw "unknown compression type " + l;
  }
  return e;
}
var Cl = Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Deflate: Fn,
  AsyncDeflate: jd,
  deflate: qd,
  deflateSync: Fs,
  Inflate: rn,
  AsyncInflate: hc,
  inflate: uc,
  inflateSync: Wr,
  Gzip: No,
  AsyncGzip: iu,
  gzip: ru,
  gzipSync: Bo,
  Gunzip: Oo,
  AsyncGunzip: Yd,
  gunzip: Zd,
  gunzipSync: Uo,
  Zlib: Tl,
  AsyncZlib: v_,
  zlib: x_,
  zlibSync: El,
  Unzlib: zo,
  AsyncUnzlib: $d,
  unzlib: Kd,
  unzlibSync: qn,
  compress: ru,
  AsyncCompress: iu,
  compressSync: Bo,
  Compress: No,
  Decompress: Jd,
  AsyncDecompress: y_,
  decompress: __,
  decompressSync: w_,
  DecodeUTF8: b_,
  EncodeUTF8: M_,
  strToU8: xi,
  strFromU8: fc,
  ZipPassThrough: Es,
  ZipDeflate: S_,
  AsyncZipDeflate: T_,
  Zip: E_,
  zip: A_,
  zipSync: C_,
  UnzipPassThrough: of,
  UnzipInflate: R_,
  AsyncUnzipInflate: L_,
  Unzip: P_,
  unzip: I_,
  unzipSync: D_,
});
function af(s, e, t) {
  const n = t.length - s - 1;
  if (e >= t[n]) return n - 1;
  if (e <= t[s]) return s;
  let i = s,
    r = n,
    o = Math.floor((i + r) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? (r = o) : (i = o), (o = Math.floor((i + r) / 2));
  return o;
}
function F_(s, e, t, n) {
  const i = [],
    r = [],
    o = [];
  i[0] = 1;
  for (let a = 1; a <= t; ++a) {
    (r[a] = e - n[s + 1 - a]), (o[a] = n[s + a] - e);
    let l = 0;
    for (let c = 0; c < a; ++c) {
      const h = o[c + 1],
        u = r[a - c],
        d = i[c] / (h + u);
      (i[c] = l + h * d), (l = u * d);
    }
    i[a] = l;
  }
  return i;
}
function N_(s, e, t, n) {
  const i = af(s, n, e),
    r = F_(i, n, s, e),
    o = new ct(0, 0, 0, 0);
  for (let a = 0; a <= s; ++a) {
    const l = t[i - s + a],
      c = r[a],
      h = l.w * c;
    (o.x += l.x * h), (o.y += l.y * h), (o.z += l.z * h), (o.w += l.w * c);
  }
  return o;
}
function B_(s, e, t, n, i) {
  const r = [];
  for (let u = 0; u <= t; ++u) r[u] = 0;
  const o = [];
  for (let u = 0; u <= n; ++u) o[u] = r.slice(0);
  const a = [];
  for (let u = 0; u <= t; ++u) a[u] = r.slice(0);
  a[0][0] = 1;
  const l = r.slice(0),
    c = r.slice(0);
  for (let u = 1; u <= t; ++u) {
    (l[u] = e - i[s + 1 - u]), (c[u] = i[s + u] - e);
    let d = 0;
    for (let f = 0; f < u; ++f) {
      const m = c[f + 1],
        v = l[u - f];
      a[u][f] = m + v;
      const y = a[f][u - 1] / a[u][f];
      (a[f][u] = d + m * y), (d = v * y);
    }
    a[u][u] = d;
  }
  for (let u = 0; u <= t; ++u) o[0][u] = a[u][t];
  for (let u = 0; u <= t; ++u) {
    let d = 0,
      f = 1;
    const m = [];
    for (let v = 0; v <= t; ++v) m[v] = r.slice(0);
    m[0][0] = 1;
    for (let v = 1; v <= n; ++v) {
      let y = 0;
      const p = u - v,
        g = t - v;
      u >= v && ((m[f][0] = m[d][0] / a[g + 1][p]), (y = m[f][0] * a[p][g]));
      const w = p >= -1 ? 1 : -p,
        b = u - 1 <= g ? v - 1 : t - u;
      for (let E = w; E <= b; ++E)
        (m[f][E] = (m[d][E] - m[d][E - 1]) / a[g + 1][p + E]),
          (y += m[f][E] * a[p + E][g]);
      u <= g &&
        ((m[f][v] = -m[d][v - 1] / a[g + 1][u]), (y += m[f][v] * a[u][g])),
        (o[v][u] = y);
      const _ = d;
      (d = f), (f = _);
    }
  }
  let h = t;
  for (let u = 1; u <= n; ++u) {
    for (let d = 0; d <= t; ++d) o[u][d] *= h;
    h *= t - u;
  }
  return o;
}
function O_(s, e, t, n, i) {
  const r = i < s ? i : s,
    o = [],
    a = af(s, n, e),
    l = B_(a, n, s, r, e),
    c = [];
  for (let h = 0; h < t.length; ++h) {
    const u = t[h].clone(),
      d = u.w;
    (u.x *= d), (u.y *= d), (u.z *= d), (c[h] = u);
  }
  for (let h = 0; h <= r; ++h) {
    const u = c[a - s].clone().multiplyScalar(l[h][0]);
    for (let d = 1; d <= s; ++d)
      u.add(c[a - s + d].clone().multiplyScalar(l[h][d]));
    o[h] = u;
  }
  for (let h = r + 1; h <= i + 1; ++h) o[h] = new ct(0, 0, 0);
  return o;
}
function U_(s, e) {
  let t = 1;
  for (let i = 2; i <= s; ++i) t *= i;
  let n = 1;
  for (let i = 2; i <= e; ++i) n *= i;
  for (let i = 2; i <= s - e; ++i) n *= i;
  return t / n;
}
function z_(s) {
  const e = s.length,
    t = [],
    n = [];
  for (let r = 0; r < e; ++r) {
    const o = s[r];
    (t[r] = new P(o.x, o.y, o.z)), (n[r] = o.w);
  }
  const i = [];
  for (let r = 0; r < e; ++r) {
    const o = t[r].clone();
    for (let a = 1; a <= r; ++a)
      o.sub(i[r - a].clone().multiplyScalar(U_(r, a) * n[a]));
    i[r] = o.divideScalar(n[0]);
  }
  return i;
}
function k_(s, e, t, n, i) {
  const r = O_(s, e, t, n, i);
  return z_(r);
}
class ou extends ln {
  constructor(e, t, n, i, r) {
    super();
    (this.degree = e),
      (this.knots = t),
      (this.controlPoints = []),
      (this.startKnot = i || 0),
      (this.endKnot = r || this.knots.length - 1);
    for (let o = 0; o < n.length; ++o) {
      const a = n[o];
      this.controlPoints[o] = new ct(a.x, a.y, a.z, a.w);
    }
  }
  getPoint(e, t = new P()) {
    const n = t,
      i =
        this.knots[this.startKnot] +
        e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
      r = N_(this.degree, this.knots, this.controlPoints, i);
    return r.w !== 1 && r.divideScalar(r.w), n.set(r.x, r.y, r.z);
  }
  getTangent(e, t = new P()) {
    const n = t,
      i =
        this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
      r = k_(this.degree, this.knots, this.controlPoints, i, 1);
    return n.copy(r[1]).normalize(), n;
  }
}
let et, Pt, en;
class dw extends cn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this,
      o = r.path === "" ? Tn.extractUrlBase(e) : r.path,
      a = new Pn(this.manager);
    a.setPath(r.path),
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(r.requestHeader),
      a.setWithCredentials(r.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            t(r.parse(l, o));
          } catch (c) {
            i ? i(c) : console.error(c), r.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
  parse(e, t) {
    if (j_(e)) et = new X_().parse(e);
    else {
      const i = uf(e);
      if (!q_(i)) throw new Error("THREE.FBXLoader: Unknown format.");
      if (lu(i) < 7e3)
        throw new Error(
          "THREE.FBXLoader: FBX version not supported, FileVersion: " + lu(i)
        );
      et = new W_().parse(i);
    }
    const n = new Zl(this.manager)
      .setPath(this.resourcePath || t)
      .setCrossOrigin(this.crossOrigin);
    return new H_(n, this.manager).parse(et);
  }
}
class H_ {
  constructor(e, t) {
    (this.textureLoader = e), (this.manager = t);
  }
  parse() {
    Pt = this.parseConnections();
    const e = this.parseImages(),
      t = this.parseTextures(e),
      n = this.parseMaterials(t),
      i = this.parseDeformers(),
      r = new G_().parse(i);
    return this.parseScene(i, r, n), en;
  }
  parseConnections() {
    const e = new Map();
    return (
      "Connections" in et &&
        et.Connections.connections.forEach(function (n) {
          const i = n[0],
            r = n[1],
            o = n[2];
          e.has(i) || e.set(i, { parents: [], children: [] });
          const a = { ID: r, relationship: o };
          e.get(i).parents.push(a),
            e.has(r) || e.set(r, { parents: [], children: [] });
          const l = { ID: i, relationship: o };
          e.get(r).children.push(l);
        }),
      e
    );
  }
  parseImages() {
    const e = {},
      t = {};
    if ("Video" in et.Objects) {
      const n = et.Objects.Video;
      for (const i in n) {
        const r = n[i],
          o = parseInt(i);
        if (((e[o] = r.RelativeFilename || r.Filename), "Content" in r)) {
          const a =
              r.Content instanceof ArrayBuffer && r.Content.byteLength > 0,
            l = typeof r.Content == "string" && r.Content !== "";
          if (a || l) {
            const c = this.parseImage(n[i]);
            t[r.RelativeFilename || r.Filename] = c;
          }
        }
      }
    }
    for (const n in e) {
      const i = e[n];
      t[i] !== void 0 ? (e[n] = t[i]) : (e[n] = e[n].split("\\").pop());
    }
    return e;
  }
  parseImage(e) {
    const t = e.Content,
      n = e.RelativeFilename || e.Filename,
      i = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
    let r;
    switch (i) {
      case "bmp":
        r = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        r = "image/jpeg";
        break;
      case "png":
        r = "image/png";
        break;
      case "tif":
        r = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null &&
          console.warn("FBXLoader: TGA loader not found, skipping ", n),
          (r = "image/tga");
        break;
      default:
        console.warn('FBXLoader: Image type "' + i + '" is not supported.');
        return;
    }
    if (typeof t == "string") return "data:" + r + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: r }));
    }
  }
  parseTextures(e) {
    const t = new Map();
    if ("Texture" in et.Objects) {
      const n = et.Objects.Texture;
      for (const i in n) {
        const r = this.parseTexture(n[i], e);
        t.set(parseInt(i), r);
      }
    }
    return t;
  }
  parseTexture(e, t) {
    const n = this.loadTexture(e, t);
    (n.ID = e.id), (n.name = e.attrName);
    const i = e.WrapModeU,
      r = e.WrapModeV,
      o = i !== void 0 ? i.value : 0,
      a = r !== void 0 ? r.value : 0;
    if (
      ((n.wrapS = o === 0 ? pi : Zt),
      (n.wrapT = a === 0 ? pi : Zt),
      "Scaling" in e)
    ) {
      const l = e.Scaling.value;
      (n.repeat.x = l[0]), (n.repeat.y = l[1]);
    }
    return n;
  }
  loadTexture(e, t) {
    let n;
    const i = this.textureLoader.path,
      r = Pt.get(e.id).children;
    r !== void 0 &&
      r.length > 0 &&
      t[r[0].ID] !== void 0 &&
      ((n = t[r[0].ID]),
      (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) &&
        this.textureLoader.setPath(void 0));
    let o;
    const a = e.FileName.slice(-3).toLowerCase();
    if (a === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null
        ? (console.warn(
            "FBXLoader: TGA loader not found, creating placeholder texture for",
            e.RelativeFilename
          ),
          (o = new At()))
        : (l.setPath(this.textureLoader.path), (o = l.load(n)));
    } else
      a === "psd"
        ? (console.warn(
            "FBXLoader: PSD textures are not supported, creating placeholder texture for",
            e.RelativeFilename
          ),
          (o = new At()))
        : (o = this.textureLoader.load(n));
    return this.textureLoader.setPath(i), o;
  }
  parseMaterials(e) {
    const t = new Map();
    if ("Material" in et.Objects) {
      const n = et.Objects.Material;
      for (const i in n) {
        const r = this.parseMaterial(n[i], e);
        r !== null && t.set(parseInt(i), r);
      }
    }
    return t;
  }
  parseMaterial(e, t) {
    const n = e.id,
      i = e.attrName;
    let r = e.ShadingModel;
    if ((typeof r == "object" && (r = r.value), !Pt.has(n))) return null;
    const o = this.parseParameters(e, t, n);
    let a;
    switch (r.toLowerCase()) {
      case "phong":
        a = new hs();
        break;
      case "lambert":
        a = new Yl();
        break;
      default:
        console.warn(
          'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',
          r
        ),
          (a = new hs());
        break;
    }
    return a.setValues(o), (a.name = i), a;
  }
  parseParameters(e, t, n) {
    const i = {};
    e.BumpFactor && (i.bumpScale = e.BumpFactor.value),
      e.Diffuse
        ? (i.color = new ye().fromArray(e.Diffuse.value))
        : e.DiffuseColor &&
          (e.DiffuseColor.type === "Color" ||
            e.DiffuseColor.type === "ColorRGB") &&
          (i.color = new ye().fromArray(e.DiffuseColor.value)),
      e.DisplacementFactor &&
        (i.displacementScale = e.DisplacementFactor.value),
      e.Emissive
        ? (i.emissive = new ye().fromArray(e.Emissive.value))
        : e.EmissiveColor &&
          (e.EmissiveColor.type === "Color" ||
            e.EmissiveColor.type === "ColorRGB") &&
          (i.emissive = new ye().fromArray(e.EmissiveColor.value)),
      e.EmissiveFactor &&
        (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
      e.Opacity && (i.opacity = parseFloat(e.Opacity.value)),
      i.opacity < 1 && (i.transparent = !0),
      e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value),
      e.Shininess && (i.shininess = e.Shininess.value),
      e.Specular
        ? (i.specular = new ye().fromArray(e.Specular.value))
        : e.SpecularColor &&
          e.SpecularColor.type === "Color" &&
          (i.specular = new ye().fromArray(e.SpecularColor.value));
    const r = this;
    return (
      Pt.get(n).children.forEach(function (o) {
        const a = o.relationship;
        switch (a) {
          case "Bump":
            i.bumpMap = r.getTexture(t, o.ID);
            break;
          case "Maya|TEX_ao_map":
            i.aoMap = r.getTexture(t, o.ID);
            break;
          case "DiffuseColor":
          case "Maya|TEX_color_map":
            (i.map = r.getTexture(t, o.ID)),
              i.map !== void 0 && (i.map.encoding = it);
            break;
          case "DisplacementColor":
            i.displacementMap = r.getTexture(t, o.ID);
            break;
          case "EmissiveColor":
            (i.emissiveMap = r.getTexture(t, o.ID)),
              i.emissiveMap !== void 0 && (i.emissiveMap.encoding = it);
            break;
          case "NormalMap":
          case "Maya|TEX_normal_map":
            i.normalMap = r.getTexture(t, o.ID);
            break;
          case "ReflectionColor":
            (i.envMap = r.getTexture(t, o.ID)),
              i.envMap !== void 0 &&
                ((i.envMap.mapping = Eo), (i.envMap.encoding = it));
            break;
          case "SpecularColor":
            (i.specularMap = r.getTexture(t, o.ID)),
              i.specularMap !== void 0 && (i.specularMap.encoding = it);
            break;
          case "TransparentColor":
          case "TransparencyFactor":
            (i.alphaMap = r.getTexture(t, o.ID)), (i.transparent = !0);
            break;
          case "AmbientColor":
          case "ShininessExponent":
          case "SpecularFactor":
          case "VectorDisplacementColor":
          default:
            console.warn(
              "THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",
              a
            );
            break;
        }
      }),
      i
    );
  }
  getTexture(e, t) {
    return (
      "LayeredTexture" in et.Objects &&
        t in et.Objects.LayeredTexture &&
        (console.warn(
          "THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."
        ),
        (t = Pt.get(t).children[0].ID)),
      e.get(t)
    );
  }
  parseDeformers() {
    const e = {},
      t = {};
    if ("Deformer" in et.Objects) {
      const n = et.Objects.Deformer;
      for (const i in n) {
        const r = n[i],
          o = Pt.get(parseInt(i));
        if (r.attrType === "Skin") {
          const a = this.parseSkeleton(o, n);
          (a.ID = i),
            o.parents.length > 1 &&
              console.warn(
                "THREE.FBXLoader: skeleton attached to more than one geometry is not supported."
              ),
            (a.geometryID = o.parents[0].ID),
            (e[i] = a);
        } else if (r.attrType === "BlendShape") {
          const a = { id: i };
          (a.rawTargets = this.parseMorphTargets(o, n)),
            (a.id = i),
            o.parents.length > 1 &&
              console.warn(
                "THREE.FBXLoader: morph target attached to more than one geometry is not supported."
              ),
            (t[i] = a);
        }
      }
    }
    return { skeletons: e, morphTargets: t };
  }
  parseSkeleton(e, t) {
    const n = [];
    return (
      e.children.forEach(function (i) {
        const r = t[i.ID];
        if (r.attrType !== "Cluster") return;
        const o = {
          ID: i.ID,
          indices: [],
          weights: [],
          transformLink: new be().fromArray(r.TransformLink.a),
        };
        "Indexes" in r &&
          ((o.indices = r.Indexes.a), (o.weights = r.Weights.a)),
          n.push(o);
      }),
      { rawBones: n, bones: [] }
    );
  }
  parseMorphTargets(e, t) {
    const n = [];
    for (let i = 0; i < e.children.length; i++) {
      const r = e.children[i],
        o = t[r.ID],
        a = {
          name: o.attrName,
          initialWeight: o.DeformPercent,
          id: o.id,
          fullWeights: o.FullWeights.a,
        };
      if (o.attrType !== "BlendShapeChannel") return;
      (a.geoID = Pt.get(parseInt(r.ID)).children.filter(function (l) {
        return l.relationship === void 0;
      })[0].ID),
        n.push(a);
    }
    return n;
  }
  parseScene(e, t, n) {
    en = new Ln();
    const i = this.parseModels(e.skeletons, t, n),
      r = et.Objects.Model,
      o = this;
    i.forEach(function (l) {
      const c = r[l.ID];
      o.setLookAtProperties(l, c),
        Pt.get(l.ID).parents.forEach(function (u) {
          const d = i.get(u.ID);
          d !== void 0 && d.add(l);
        }),
        l.parent === null && en.add(l);
    }),
      this.bindSkeleton(e.skeletons, t, i),
      this.createAmbientLight(),
      en.traverse(function (l) {
        if (l.userData.transformData) {
          l.parent &&
            ((l.userData.transformData.parentMatrix = l.parent.matrix),
            (l.userData.transformData.parentMatrixWorld =
              l.parent.matrixWorld));
          const c = cf(l.userData.transformData);
          l.applyMatrix4(c), l.updateWorldMatrix();
        }
      });
    const a = new V_().parse();
    en.children.length === 1 &&
      en.children[0].isGroup &&
      ((en.children[0].animations = a), (en = en.children[0])),
      (en.animations = a);
  }
  parseModels(e, t, n) {
    const i = new Map(),
      r = et.Objects.Model;
    for (const o in r) {
      const a = parseInt(o),
        l = r[o],
        c = Pt.get(a);
      let h = this.buildSkeleton(c, e, a, l.attrName);
      if (!h) {
        switch (l.attrType) {
          case "Camera":
            h = this.createCamera(c);
            break;
          case "Light":
            h = this.createLight(c);
            break;
          case "Mesh":
            h = this.createMesh(c, t, n);
            break;
          case "NurbsCurve":
            h = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            h = new xs();
            break;
          case "Null":
          default:
            h = new Ln();
            break;
        }
        (h.name = l.attrName ? ot.sanitizeNodeName(l.attrName) : ""),
          (h.ID = a);
      }
      this.getTransformData(h, l), i.set(a, h);
    }
    return i;
  }
  buildSkeleton(e, t, n, i) {
    let r = null;
    return (
      e.parents.forEach(function (o) {
        for (const a in t) {
          const l = t[a];
          l.rawBones.forEach(function (c, h) {
            if (c.ID === o.ID) {
              const u = r;
              (r = new xs()),
                r.matrixWorld.copy(c.transformLink),
                (r.name = i ? ot.sanitizeNodeName(i) : ""),
                (r.ID = n),
                (l.bones[h] = r),
                u !== null && r.add(u);
            }
          });
        }
      }),
      r
    );
  }
  createCamera(e) {
    let t, n;
    if (
      (e.children.forEach(function (i) {
        const r = et.Objects.NodeAttribute[i.ID];
        r !== void 0 && (n = r);
      }),
      n === void 0)
    )
      t = new at();
    else {
      let i = 0;
      n.CameraProjectionType !== void 0 &&
        n.CameraProjectionType.value === 1 &&
        (i = 1);
      let r = 1;
      n.NearPlane !== void 0 && (r = n.NearPlane.value / 1e3);
      let o = 1e3;
      n.FarPlane !== void 0 && (o = n.FarPlane.value / 1e3);
      let a = window.innerWidth,
        l = window.innerHeight;
      n.AspectWidth !== void 0 &&
        n.AspectHeight !== void 0 &&
        ((a = n.AspectWidth.value), (l = n.AspectHeight.value));
      const c = a / l;
      let h = 45;
      n.FieldOfView !== void 0 && (h = n.FieldOfView.value);
      const u = n.FocalLength ? n.FocalLength.value : null;
      switch (i) {
        case 0:
          (t = new Yt(h, c, r, o)), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new Ni(-a / 2, a / 2, l / 2, -l / 2, r, o);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + i + "."),
            (t = new at());
          break;
      }
    }
    return t;
  }
  createLight(e) {
    let t, n;
    if (
      (e.children.forEach(function (i) {
        const r = et.Objects.NodeAttribute[i.ID];
        r !== void 0 && (n = r);
      }),
      n === void 0)
    )
      t = new at();
    else {
      let i;
      n.LightType === void 0 ? (i = 0) : (i = n.LightType.value);
      let r = 16777215;
      n.Color !== void 0 && (r = new ye().fromArray(n.Color.value));
      let o = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
      n.CastLightOnObject !== void 0 &&
        n.CastLightOnObject.value === 0 &&
        (o = 0);
      let a = 0;
      n.FarAttenuationEnd !== void 0 &&
        (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0
          ? (a = 0)
          : (a = n.FarAttenuationEnd.value));
      const l = 1;
      switch (i) {
        case 0:
          t = new Io(r, o, a, l);
          break;
        case 1:
          t = new Jl(r, o);
          break;
        case 2:
          let c = Math.PI / 3;
          n.InnerAngle !== void 0 && (c = Sn.degToRad(n.InnerAngle.value));
          let h = 0;
          n.OuterAngle !== void 0 &&
            ((h = Sn.degToRad(n.OuterAngle.value)), (h = Math.max(h, 1))),
            (t = new Kl(r, o, a, c, h, l));
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " +
              n.LightType.value +
              ", defaulting to a PointLight."
          ),
            (t = new Io(r, o));
          break;
      }
      n.CastShadows !== void 0 &&
        n.CastShadows.value === 1 &&
        (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, n) {
    let i,
      r = null,
      o = null;
    const a = [];
    return (
      e.children.forEach(function (l) {
        t.has(l.ID) && (r = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID));
      }),
      a.length > 1
        ? (o = a)
        : a.length > 0
        ? (o = a[0])
        : ((o = new hs({ color: 13421772 })), a.push(o)),
      "color" in r.attributes &&
        a.forEach(function (l) {
          l.vertexColors = !0;
        }),
      r.FBX_Deformer
        ? ((i = new qo(r, o)), i.normalizeSkinWeights())
        : (i = new jt(r, o)),
      i
    );
  }
  createCurve(e, t) {
    const n = e.children.reduce(function (r, o) {
        return t.has(o.ID) && (r = t.get(o.ID)), r;
      }, null),
      i = new Nn({ color: 3342591, linewidth: 1 });
    return new Rs(n, i);
  }
  getTransformData(e, t) {
    const n = {};
    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)),
      "RotationOrder" in t
        ? (n.eulerOrder = hf(t.RotationOrder.value))
        : (n.eulerOrder = "ZYX"),
      "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value),
      "PreRotation" in t && (n.preRotation = t.PreRotation.value),
      "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value),
      "PostRotation" in t && (n.postRotation = t.PostRotation.value),
      "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value),
      "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value),
      "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value),
      "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value),
      "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value),
      (e.userData.transformData = n);
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t &&
      Pt.get(e.ID).children.forEach(function (i) {
        if (i.relationship === "LookAtProperty") {
          const r = et.Objects.Model[i.ID];
          if ("Lcl_Translation" in r) {
            const o = r.Lcl_Translation.value;
            e.target !== void 0
              ? (e.target.position.fromArray(o), en.add(e.target))
              : e.lookAt(new P().fromArray(o));
          }
        }
      });
  }
  bindSkeleton(e, t, n) {
    const i = this.parsePoseNodes();
    for (const r in e) {
      const o = e[r];
      Pt.get(parseInt(o.ID)).parents.forEach(function (l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          Pt.get(c).parents.forEach(function (u) {
            n.has(u.ID) && n.get(u.ID).bind(new Yo(o.bones), i[u.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in et.Objects) {
      const t = et.Objects.Pose;
      for (const n in t)
        if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
          const i = t[n].PoseNode;
          Array.isArray(i)
            ? i.forEach(function (r) {
                e[r.Node] = new be().fromArray(r.Matrix.a);
              })
            : (e[i.Node] = new be().fromArray(i.Matrix.a));
        }
    }
    return e;
  }
  createAmbientLight() {
    if ("GlobalSettings" in et && "AmbientColor" in et.GlobalSettings) {
      const e = et.GlobalSettings.AmbientColor.value,
        t = e[0],
        n = e[1],
        i = e[2];
      if (t !== 0 || n !== 0 || i !== 0) {
        const r = new ye(t, n, i);
        en.add(new vd(r, 1));
      }
    }
  }
}
class G_ {
  parse(e) {
    const t = new Map();
    if ("Geometry" in et.Objects) {
      const n = et.Objects.Geometry;
      for (const i in n) {
        const r = Pt.get(parseInt(i)),
          o = this.parseGeometry(r, n[i], e);
        t.set(parseInt(i), o);
      }
    }
    return t;
  }
  parseGeometry(e, t, n) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, n);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  parseMeshGeometry(e, t, n) {
    const i = n.skeletons,
      r = [],
      o = e.parents.map(function (u) {
        return et.Objects.Model[u.ID];
      });
    if (o.length === 0) return;
    const a = e.children.reduce(function (u, d) {
      return i[d.ID] !== void 0 && (u = i[d.ID]), u;
    }, null);
    e.children.forEach(function (u) {
      n.morphTargets[u.ID] !== void 0 && r.push(n.morphTargets[u.ID]);
    });
    const l = o[0],
      c = {};
    "RotationOrder" in l && (c.eulerOrder = hf(l.RotationOrder.value)),
      "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)),
      "GeometricTranslation" in l &&
        (c.translation = l.GeometricTranslation.value),
      "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value),
      "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const h = cf(c);
    return this.genGeometry(t, a, r, h);
  }
  genGeometry(e, t, n, i) {
    const r = new tt();
    e.attrName && (r.name = e.attrName);
    const o = this.parseGeoNode(e, t),
      a = this.genBuffers(o),
      l = new Je(a.vertex, 3);
    if (
      (l.applyMatrix4(i),
      r.setAttribute("position", l),
      a.colors.length > 0 && r.setAttribute("color", new Je(a.colors, 3)),
      t &&
        (r.setAttribute("skinIndex", new Fl(a.weightsIndices, 4)),
        r.setAttribute("skinWeight", new Je(a.vertexWeights, 4)),
        (r.FBX_Deformer = t)),
      a.normal.length > 0)
    ) {
      const c = new Gt().getNormalMatrix(i),
        h = new Je(a.normal, 3);
      h.applyNormalMatrix(c), r.setAttribute("normal", h);
    }
    if (
      (a.uvs.forEach(function (c, h) {
        let u = "uv" + (h + 1).toString();
        h === 0 && (u = "uv"), r.setAttribute(u, new Je(a.uvs[h], 2));
      }),
      o.material && o.material.mappingType !== "AllSame")
    ) {
      let c = a.materialIndex[0],
        h = 0;
      if (
        (a.materialIndex.forEach(function (u, d) {
          u !== c && (r.addGroup(h, d - h, c), (c = u), (h = d));
        }),
        r.groups.length > 0)
      ) {
        const u = r.groups[r.groups.length - 1],
          d = u.start + u.count;
        d !== a.materialIndex.length &&
          r.addGroup(d, a.materialIndex.length - d, c);
      }
      r.groups.length === 0 &&
        r.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
    }
    return this.addMorphTargets(r, e, n, i), r;
  }
  parseGeoNode(e, t) {
    const n = {};
    if (
      ((n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : []),
      (n.vertexIndices =
        e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : []),
      e.LayerElementColor &&
        (n.color = this.parseVertexColors(e.LayerElementColor[0])),
      e.LayerElementMaterial &&
        (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])),
      e.LayerElementNormal &&
        (n.normal = this.parseNormals(e.LayerElementNormal[0])),
      e.LayerElementUV)
    ) {
      n.uv = [];
      let i = 0;
      for (; e.LayerElementUV[i]; )
        e.LayerElementUV[i].UV && n.uv.push(this.parseUVs(e.LayerElementUV[i])),
          i++;
    }
    return (
      (n.weightTable = {}),
      t !== null &&
        ((n.skeleton = t),
        t.rawBones.forEach(function (i, r) {
          i.indices.forEach(function (o, a) {
            n.weightTable[o] === void 0 && (n.weightTable[o] = []),
              n.weightTable[o].push({ id: r, weight: i.weights[a] });
          });
        })),
      n
    );
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: [],
    };
    let n = 0,
      i = 0,
      r = !1,
      o = [],
      a = [],
      l = [],
      c = [],
      h = [],
      u = [];
    const d = this;
    return (
      e.vertexIndices.forEach(function (f, m) {
        let v,
          y = !1;
        f < 0 && ((f = f ^ -1), (y = !0));
        let p = [],
          g = [];
        if ((o.push(f * 3, f * 3 + 1, f * 3 + 2), e.color)) {
          const w = xo(m, n, f, e.color);
          l.push(w[0], w[1], w[2]);
        }
        if (e.skeleton) {
          if (
            (e.weightTable[f] !== void 0 &&
              e.weightTable[f].forEach(function (w) {
                g.push(w.weight), p.push(w.id);
              }),
            g.length > 4)
          ) {
            r ||
              (console.warn(
                "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
              ),
              (r = !0));
            const w = [0, 0, 0, 0],
              b = [0, 0, 0, 0];
            g.forEach(function (_, E) {
              let L = _,
                D = p[E];
              b.forEach(function (V, F, M) {
                if (L > V) {
                  (M[F] = L), (L = V);
                  const A = w[F];
                  (w[F] = D), (D = A);
                }
              });
            }),
              (p = w),
              (g = b);
          }
          for (; g.length < 4; ) g.push(0), p.push(0);
          for (let w = 0; w < 4; ++w) h.push(g[w]), u.push(p[w]);
        }
        if (e.normal) {
          const w = xo(m, n, f, e.normal);
          a.push(w[0], w[1], w[2]);
        }
        e.material &&
          e.material.mappingType !== "AllSame" &&
          (v = xo(m, n, f, e.material)[0]),
          e.uv &&
            e.uv.forEach(function (w, b) {
              const _ = xo(m, n, f, w);
              c[b] === void 0 && (c[b] = []), c[b].push(_[0]), c[b].push(_[1]);
            }),
          i++,
          y &&
            (d.genFace(t, e, o, v, a, l, c, h, u, i),
            n++,
            (i = 0),
            (o = []),
            (a = []),
            (l = []),
            (c = []),
            (h = []),
            (u = []));
      }),
      t
    );
  }
  genFace(e, t, n, i, r, o, a, l, c, h) {
    for (let u = 2; u < h; u++)
      e.vertex.push(t.vertexPositions[n[0]]),
        e.vertex.push(t.vertexPositions[n[1]]),
        e.vertex.push(t.vertexPositions[n[2]]),
        e.vertex.push(t.vertexPositions[n[(u - 1) * 3]]),
        e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 1]]),
        e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 2]]),
        e.vertex.push(t.vertexPositions[n[u * 3]]),
        e.vertex.push(t.vertexPositions[n[u * 3 + 1]]),
        e.vertex.push(t.vertexPositions[n[u * 3 + 2]]),
        t.skeleton &&
          (e.vertexWeights.push(l[0]),
          e.vertexWeights.push(l[1]),
          e.vertexWeights.push(l[2]),
          e.vertexWeights.push(l[3]),
          e.vertexWeights.push(l[(u - 1) * 4]),
          e.vertexWeights.push(l[(u - 1) * 4 + 1]),
          e.vertexWeights.push(l[(u - 1) * 4 + 2]),
          e.vertexWeights.push(l[(u - 1) * 4 + 3]),
          e.vertexWeights.push(l[u * 4]),
          e.vertexWeights.push(l[u * 4 + 1]),
          e.vertexWeights.push(l[u * 4 + 2]),
          e.vertexWeights.push(l[u * 4 + 3]),
          e.weightsIndices.push(c[0]),
          e.weightsIndices.push(c[1]),
          e.weightsIndices.push(c[2]),
          e.weightsIndices.push(c[3]),
          e.weightsIndices.push(c[(u - 1) * 4]),
          e.weightsIndices.push(c[(u - 1) * 4 + 1]),
          e.weightsIndices.push(c[(u - 1) * 4 + 2]),
          e.weightsIndices.push(c[(u - 1) * 4 + 3]),
          e.weightsIndices.push(c[u * 4]),
          e.weightsIndices.push(c[u * 4 + 1]),
          e.weightsIndices.push(c[u * 4 + 2]),
          e.weightsIndices.push(c[u * 4 + 3])),
        t.color &&
          (e.colors.push(o[0]),
          e.colors.push(o[1]),
          e.colors.push(o[2]),
          e.colors.push(o[(u - 1) * 3]),
          e.colors.push(o[(u - 1) * 3 + 1]),
          e.colors.push(o[(u - 1) * 3 + 2]),
          e.colors.push(o[u * 3]),
          e.colors.push(o[u * 3 + 1]),
          e.colors.push(o[u * 3 + 2])),
        t.material &&
          t.material.mappingType !== "AllSame" &&
          (e.materialIndex.push(i),
          e.materialIndex.push(i),
          e.materialIndex.push(i)),
        t.normal &&
          (e.normal.push(r[0]),
          e.normal.push(r[1]),
          e.normal.push(r[2]),
          e.normal.push(r[(u - 1) * 3]),
          e.normal.push(r[(u - 1) * 3 + 1]),
          e.normal.push(r[(u - 1) * 3 + 2]),
          e.normal.push(r[u * 3]),
          e.normal.push(r[u * 3 + 1]),
          e.normal.push(r[u * 3 + 2])),
        t.uv &&
          t.uv.forEach(function (d, f) {
            e.uvs[f] === void 0 && (e.uvs[f] = []),
              e.uvs[f].push(a[f][0]),
              e.uvs[f].push(a[f][1]),
              e.uvs[f].push(a[f][(u - 1) * 2]),
              e.uvs[f].push(a[f][(u - 1) * 2 + 1]),
              e.uvs[f].push(a[f][u * 2]),
              e.uvs[f].push(a[f][u * 2 + 1]);
          });
  }
  addMorphTargets(e, t, n, i) {
    if (n.length === 0) return;
    (e.morphTargetsRelative = !0), (e.morphAttributes.position = []);
    const r = this;
    n.forEach(function (o) {
      o.rawTargets.forEach(function (a) {
        const l = et.Objects.Geometry[a.geoID];
        l !== void 0 && r.genMorphGeometry(e, t, l, i, a.name);
      });
    });
  }
  genMorphGeometry(e, t, n, i, r) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [],
      a = n.Vertices !== void 0 ? n.Vertices.a : [],
      l = n.Indexes !== void 0 ? n.Indexes.a : [],
      c = e.attributes.position.count * 3,
      h = new Float32Array(c);
    for (let m = 0; m < l.length; m++) {
      const v = l[m] * 3;
      (h[v] = a[m * 3]), (h[v + 1] = a[m * 3 + 1]), (h[v + 2] = a[m * 3 + 2]);
    }
    const u = { vertexIndices: o, vertexPositions: h },
      d = this.genBuffers(u),
      f = new Je(d.vertex, 3);
    (f.name = r || n.attrName),
      f.applyMatrix4(i),
      e.morphAttributes.position.push(f);
  }
  parseNormals(e) {
    const t = e.MappingInformationType,
      n = e.ReferenceInformationType,
      i = e.Normals.a;
    let r = [];
    return (
      n === "IndexToDirect" &&
        ("NormalIndex" in e
          ? (r = e.NormalIndex.a)
          : "NormalsIndex" in e && (r = e.NormalsIndex.a)),
      { dataSize: 3, buffer: i, indices: r, mappingType: t, referenceType: n }
    );
  }
  parseUVs(e) {
    const t = e.MappingInformationType,
      n = e.ReferenceInformationType,
      i = e.UV.a;
    let r = [];
    return (
      n === "IndexToDirect" && (r = e.UVIndex.a),
      { dataSize: 2, buffer: i, indices: r, mappingType: t, referenceType: n }
    );
  }
  parseVertexColors(e) {
    const t = e.MappingInformationType,
      n = e.ReferenceInformationType,
      i = e.Colors.a;
    let r = [];
    return (
      n === "IndexToDirect" && (r = e.ColorIndex.a),
      { dataSize: 4, buffer: i, indices: r, mappingType: t, referenceType: n }
    );
  }
  parseMaterialIndices(e) {
    const t = e.MappingInformationType,
      n = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n,
      };
    const i = e.Materials.a,
      r = [];
    for (let o = 0; o < i.length; ++o) r.push(o);
    return {
      dataSize: 1,
      buffer: i,
      indices: r,
      mappingType: t,
      referenceType: n,
    };
  }
  parseNurbsGeometry(e) {
    if (ou === void 0)
      return (
        console.error(
          "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
        ),
        new tt()
      );
    const t = parseInt(e.Order);
    if (isNaN(t))
      return (
        console.error(
          "THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",
          e.Order,
          e.id
        ),
        new tt()
      );
    const n = t - 1,
      i = e.KnotVector.a,
      r = [],
      o = e.Points.a;
    for (let u = 0, d = o.length; u < d; u += 4)
      r.push(new ct().fromArray(o, u));
    let a, l;
    if (e.Form === "Closed") r.push(r[0]);
    else if (e.Form === "Periodic") {
      (a = n), (l = i.length - 1 - a);
      for (let u = 0; u < n; ++u) r.push(r[u]);
    }
    const h = new ou(n, i, r, a, l).getPoints(r.length * 12);
    return new tt().setFromPoints(h);
  }
}
class V_ {
  parse() {
    const e = [],
      t = this.parseClips();
    if (t !== void 0)
      for (const n in t) {
        const i = t[n],
          r = this.addClip(i);
        e.push(r);
      }
    return e;
  }
  parseClips() {
    if (et.Objects.AnimationCurve === void 0) return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  parseAnimationCurveNodes() {
    const e = et.Objects.AnimationCurveNode,
      t = new Map();
    for (const n in e) {
      const i = e[n];
      if (i.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const r = { id: i.id, attr: i.attrName, curves: {} };
        t.set(r.id, r);
      }
    }
    return t;
  }
  parseAnimationCurves(e) {
    const t = et.Objects.AnimationCurve;
    for (const n in t) {
      const i = {
          id: t[n].id,
          times: t[n].KeyTime.a.map(Y_),
          values: t[n].KeyValueFloat.a,
        },
        r = Pt.get(i.id);
      if (r !== void 0) {
        const o = r.parents[0].ID,
          a = r.parents[0].relationship;
        a.match(/X/)
          ? (e.get(o).curves.x = i)
          : a.match(/Y/)
          ? (e.get(o).curves.y = i)
          : a.match(/Z/)
          ? (e.get(o).curves.z = i)
          : a.match(/d|DeformPercent/) &&
            e.has(o) &&
            (e.get(o).curves.morph = i);
      }
    }
  }
  parseAnimationLayers(e) {
    const t = et.Objects.AnimationLayer,
      n = new Map();
    for (const i in t) {
      const r = [],
        o = Pt.get(parseInt(i));
      o !== void 0 &&
        (o.children.forEach(function (l, c) {
          if (e.has(l.ID)) {
            const h = e.get(l.ID);
            if (
              h.curves.x !== void 0 ||
              h.curves.y !== void 0 ||
              h.curves.z !== void 0
            ) {
              if (r[c] === void 0) {
                const u = Pt.get(l.ID).parents.filter(function (d) {
                  return d.relationship !== void 0;
                })[0].ID;
                if (u !== void 0) {
                  const d = et.Objects.Model[u.toString()];
                  if (d === void 0) {
                    console.warn(
                      "THREE.FBXLoader: Encountered a unused curve.",
                      l
                    );
                    return;
                  }
                  const f = {
                    modelName: d.attrName
                      ? ot.sanitizeNodeName(d.attrName)
                      : "",
                    ID: d.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1],
                  };
                  en.traverse(function (m) {
                    m.ID === d.id &&
                      ((f.transform = m.matrix),
                      m.userData.transformData &&
                        (f.eulerOrder = m.userData.transformData.eulerOrder));
                  }),
                    f.transform || (f.transform = new be()),
                    "PreRotation" in d && (f.preRotation = d.PreRotation.value),
                    "PostRotation" in d &&
                      (f.postRotation = d.PostRotation.value),
                    (r[c] = f);
                }
              }
              r[c] && (r[c][h.attr] = h);
            } else if (h.curves.morph !== void 0) {
              if (r[c] === void 0) {
                const u = Pt.get(l.ID).parents.filter(function (p) {
                    return p.relationship !== void 0;
                  })[0].ID,
                  d = Pt.get(u).parents[0].ID,
                  f = Pt.get(d).parents[0].ID,
                  m = Pt.get(f).parents[0].ID,
                  v = et.Objects.Model[m],
                  y = {
                    modelName: v.attrName
                      ? ot.sanitizeNodeName(v.attrName)
                      : "",
                    morphName: et.Objects.Deformer[u].attrName,
                  };
                r[c] = y;
              }
              r[c][h.attr] = h;
            }
          }
        }),
        n.set(parseInt(i), r));
    }
    return n;
  }
  parseAnimStacks(e) {
    const t = et.Objects.AnimationStack,
      n = {};
    for (const i in t) {
      const r = Pt.get(parseInt(i)).children;
      r.length > 1 &&
        console.warn(
          "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
        );
      const o = e.get(r[0].ID);
      n[i] = { name: t[i].attrName, layer: o };
    }
    return n;
  }
  addClip(e) {
    let t = [];
    const n = this;
    return (
      e.layer.forEach(function (i) {
        t = t.concat(n.generateTracks(i));
      }),
      new Po(e.name, -1, t)
    );
  }
  generateTracks(e) {
    const t = [];
    let n = new P(),
      i = new Dt(),
      r = new P();
    if (
      (e.transform && e.transform.decompose(n, i, r),
      (n = n.toArray()),
      (i = new mn().setFromQuaternion(i, e.eulerOrder).toArray()),
      (r = r.toArray()),
      e.T !== void 0 && Object.keys(e.T.curves).length > 0)
    ) {
      const o = this.generateVectorTrack(
        e.modelName,
        e.T.curves,
        n,
        "position"
      );
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(
        e.modelName,
        e.R.curves,
        i,
        e.preRotation,
        e.postRotation,
        e.eulerOrder
      );
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, r, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, n, i) {
    const r = this.getTimesForAllAxes(t),
      o = this.getKeyframeTrackValues(r, t, n);
    return new Sr(e + "." + i, r, o);
  }
  generateRotationTrack(e, t, n, i, r, o) {
    t.x !== void 0 &&
      (this.interpolateRotations(t.x),
      (t.x.values = t.x.values.map(Sn.degToRad))),
      t.y !== void 0 &&
        (this.interpolateRotations(t.y),
        (t.y.values = t.y.values.map(Sn.degToRad))),
      t.z !== void 0 &&
        (this.interpolateRotations(t.z),
        (t.z.values = t.z.values.map(Sn.degToRad)));
    const a = this.getTimesForAllAxes(t),
      l = this.getKeyframeTrackValues(a, t, n);
    i !== void 0 &&
      ((i = i.map(Sn.degToRad)),
      i.push(o),
      (i = new mn().fromArray(i)),
      (i = new Dt().setFromEuler(i))),
      r !== void 0 &&
        ((r = r.map(Sn.degToRad)),
        r.push(o),
        (r = new mn().fromArray(r)),
        (r = new Dt().setFromEuler(r).invert()));
    const c = new Dt(),
      h = new mn(),
      u = [];
    for (let d = 0; d < l.length; d += 3)
      h.set(l[d], l[d + 1], l[d + 2], o),
        c.setFromEuler(h),
        i !== void 0 && c.premultiply(i),
        r !== void 0 && c.multiply(r),
        c.toArray(u, (d / 3) * 4);
    return new vi(e + ".quaternion", a, u);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph,
      n = t.values.map(function (r) {
        return r / 100;
      }),
      i = en.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Mr(
      e.modelName + ".morphTargetInfluences[" + i + "]",
      t.times,
      n
    );
  }
  getTimesForAllAxes(e) {
    let t = [];
    if (
      (e.x !== void 0 && (t = t.concat(e.x.times)),
      e.y !== void 0 && (t = t.concat(e.y.times)),
      e.z !== void 0 && (t = t.concat(e.z.times)),
      (t = t.sort(function (n, i) {
        return n - i;
      })),
      t.length > 1)
    ) {
      let n = 1,
        i = t[0];
      for (let r = 1; r < t.length; r++) {
        const o = t[r];
        o !== i && ((t[n] = o), (i = o), n++);
      }
      t = t.slice(0, n);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, n) {
    const i = n,
      r = [];
    let o = -1,
      a = -1,
      l = -1;
    return (
      e.forEach(function (c) {
        if (
          (t.x && (o = t.x.times.indexOf(c)),
          t.y && (a = t.y.times.indexOf(c)),
          t.z && (l = t.z.times.indexOf(c)),
          o !== -1)
        ) {
          const h = t.x.values[o];
          r.push(h), (i[0] = h);
        } else r.push(i[0]);
        if (a !== -1) {
          const h = t.y.values[a];
          r.push(h), (i[1] = h);
        } else r.push(i[1]);
        if (l !== -1) {
          const h = t.z.values[l];
          r.push(h), (i[2] = h);
        } else r.push(i[2]);
      }),
      r
    );
  }
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const n = e.values[t - 1],
        i = e.values[t] - n,
        r = Math.abs(i);
      if (r >= 180) {
        const o = r / 180,
          a = i / o;
        let l = n + a;
        const c = e.times[t - 1],
          u = (e.times[t] - c) / o;
        let d = c + u;
        const f = [],
          m = [];
        for (; d < e.times[t]; ) f.push(d), (d += u), m.push(l), (l += a);
        (e.times = cu(e.times, t, f)), (e.values = cu(e.values, t, m));
      }
    }
  }
}
class W_ {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), (this.currentIndent += 1);
  }
  popStack() {
    this.nodeStack.pop(), (this.currentIndent -= 1);
  }
  setCurrentProp(e, t) {
    (this.currentProp = e), (this.currentPropName = t);
  }
  parse(e) {
    (this.currentIndent = 0),
      (this.allNodes = new lf()),
      (this.nodeStack = []),
      (this.currentProp = []),
      (this.currentPropName = "");
    const t = this,
      n = e.split(/[\r\n]+/);
    return (
      n.forEach(function (i, r) {
        const o = i.match(/^[\s\t]*;/),
          a = i.match(/^[\s\t]*$/);
        if (o || a) return;
        const l = i.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
          c = i.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
          h = i.match("^\\t{" + (t.currentIndent - 1) + "}}");
        l
          ? t.parseNodeBegin(i, l)
          : c
          ? t.parseNodeProperty(i, c, n[++r])
          : h
          ? t.popStack()
          : i.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(i);
      }),
      this.allNodes
    );
  }
  parseNodeBegin(e, t) {
    const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
      i = t[2].split(",").map(function (l) {
        return l.trim().replace(/^"/, "").replace(/"$/, "");
      }),
      r = { name: n },
      o = this.parseNodeAttr(i),
      a = this.getCurrentNode();
    this.currentIndent === 0
      ? this.allNodes.add(n, r)
      : n in a
      ? (n === "PoseNode"
          ? a.PoseNode.push(r)
          : a[n].id !== void 0 && ((a[n] = {}), (a[n][a[n].id] = a[n])),
        o.id !== "" && (a[n][o.id] = r))
      : typeof o.id == "number"
      ? ((a[n] = {}), (a[n][o.id] = r))
      : n !== "Properties70" && (n === "PoseNode" ? (a[n] = [r]) : (a[n] = r)),
      typeof o.id == "number" && (r.id = o.id),
      o.name !== "" && (r.attrName = o.name),
      o.type !== "" && (r.attrType = o.type),
      this.pushStack(r);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && ((t = parseInt(e[0])), isNaN(t) && (t = e[0]));
    let n = "",
      i = "";
    return (
      e.length > 1 && ((n = e[1].replace(/^(\w+)::/, "")), (i = e[2])),
      { id: t, name: n, type: i }
    );
  }
  parseNodeProperty(e, t, n) {
    let i = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
      r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    i === "Content" &&
      r === "," &&
      (r = n.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, i, r);
      return;
    }
    if (i === "C") {
      const l = r.split(",").slice(1),
        c = parseInt(l[0]),
        h = parseInt(l[1]);
      let u = r.split(",").slice(3);
      (u = u.map(function (d) {
        return d.trim().replace(/^"/, "");
      })),
        (i = "connections"),
        (r = [c, h]),
        $_(r, u),
        o[i] === void 0 && (o[i] = []);
    }
    i === "Node" && (o.id = r),
      i in o && Array.isArray(o[i])
        ? o[i].push(r)
        : i !== "a"
        ? (o[i] = r)
        : (o.a = r),
      this.setCurrentProp(o, i),
      i === "a" && r.slice(-1) !== "," && (o.a = qa(r));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    (t.a += e), e.slice(-1) !== "," && (t.a = qa(t.a));
  }
  parseNodeSpecialProperty(e, t, n) {
    const i = n.split('",').map(function (h) {
        return h.trim().replace(/^\"/, "").replace(/\s/, "_");
      }),
      r = i[0],
      o = i[1],
      a = i[2],
      l = i[3];
    let c = i[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = qa(c);
        break;
    }
    (this.getPrevNode()[r] = { type: o, type2: a, flag: l, value: c }),
      this.setCurrentProp(this.getPrevNode(), r);
  }
}
class X_ {
  parse(e) {
    const t = new au(e);
    t.skip(23);
    const n = t.getUint32();
    if (n < 6400)
      throw new Error(
        "THREE.FBXLoader: FBX version not supported, FileVersion: " + n
      );
    const i = new lf();
    for (; !this.endOfContent(t); ) {
      const r = this.parseNode(t, n);
      r !== null && i.add(r.name, r);
    }
    return i;
  }
  endOfContent(e) {
    return e.size() % 16 === 0
      ? ((e.getOffset() + 160 + 16) & -16) >= e.size()
      : e.getOffset() + 160 + 16 >= e.size();
  }
  parseNode(e, t) {
    const n = {},
      i = t >= 7500 ? e.getUint64() : e.getUint32(),
      r = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(),
      a = e.getString(o);
    if (i === 0) return null;
    const l = [];
    for (let d = 0; d < r; d++) l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "",
      h = l.length > 1 ? l[1] : "",
      u = l.length > 2 ? l[2] : "";
    for (
      n.singleProperty = r === 1 && e.getOffset() === i;
      i > e.getOffset();

    ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(a, n, d);
    }
    return (
      (n.propertyList = l),
      typeof c == "number" && (n.id = c),
      h !== "" && (n.attrName = h),
      u !== "" && (n.attrType = u),
      a !== "" && (n.name = a),
      n
    );
  }
  parseSubNode(e, t, n) {
    if (n.singleProperty === !0) {
      const i = n.propertyList[0];
      Array.isArray(i) ? ((t[n.name] = n), (n.a = i)) : (t[n.name] = i);
    } else if (e === "Connections" && n.name === "C") {
      const i = [];
      n.propertyList.forEach(function (r, o) {
        o !== 0 && i.push(r);
      }),
        t.connections === void 0 && (t.connections = []),
        t.connections.push(i);
    } else if (n.name === "Properties70")
      Object.keys(n).forEach(function (r) {
        t[r] = n[r];
      });
    else if (e === "Properties70" && n.name === "P") {
      let i = n.propertyList[0],
        r = n.propertyList[1];
      const o = n.propertyList[2],
        a = n.propertyList[3];
      let l;
      i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")),
        r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")),
        r === "Color" ||
        r === "ColorRGB" ||
        r === "Vector" ||
        r === "Vector3D" ||
        r.indexOf("Lcl_") === 0
          ? (l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]])
          : (l = n.propertyList[4]),
        (t[i] = { type: r, type2: o, flag: a, value: l });
    } else
      t[n.name] === void 0
        ? typeof n.id == "number"
          ? ((t[n.name] = {}), (t[n.name][n.id] = n))
          : (t[n.name] = n)
        : n.name === "PoseNode"
        ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]),
          t[n.name].push(n))
        : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let n;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return (n = e.getUint32()), e.getArrayBuffer(n);
      case "S":
        return (n = e.getUint32()), e.getString(n);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const i = e.getUint32(),
          r = e.getUint32(),
          o = e.getUint32();
        if (r === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(i);
            case "d":
              return e.getFloat64Array(i);
            case "f":
              return e.getFloat32Array(i);
            case "i":
              return e.getInt32Array(i);
            case "l":
              return e.getInt64Array(i);
          }
        typeof Cl == "undefined" &&
          console.error(
            "THREE.FBXLoader: External library fflate.min.js required."
          );
        const a = qn(new Uint8Array(e.getArrayBuffer(o))),
          l = new au(a.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(i);
          case "d":
            return l.getFloat64Array(i);
          case "f":
            return l.getFloat32Array(i);
          case "i":
            return l.getInt32Array(i);
          case "l":
            return l.getInt64Array(i);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class au {
  constructor(e, t) {
    (this.dv = new DataView(e)),
      (this.offset = 0),
      (this.littleEndian = t !== void 0 ? t : !0);
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let n = 0; n < e; n++) t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return (this.offset += 1), e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return (this.offset += 2), e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return (this.offset += 4), e;
  }
  getInt32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++) t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return (this.offset += 4), e;
  }
  getInt64() {
    let e, t;
    return (
      this.littleEndian
        ? ((e = this.getUint32()), (t = this.getUint32()))
        : ((t = this.getUint32()), (e = this.getUint32())),
      t & 2147483648
        ? ((t = ~t & 4294967295),
          (e = ~e & 4294967295),
          e === 4294967295 && (t = (t + 1) & 4294967295),
          (e = (e + 1) & 4294967295),
          -(t * 4294967296 + e))
        : t * 4294967296 + e
    );
  }
  getInt64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++) t.push(this.getInt64());
    return t;
  }
  getUint64() {
    let e, t;
    return (
      this.littleEndian
        ? ((e = this.getUint32()), (t = this.getUint32()))
        : ((t = this.getUint32()), (e = this.getUint32())),
      t * 4294967296 + e
    );
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return (this.offset += 4), e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++) t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return (this.offset += 8), e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++) t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return (this.offset += e), t;
  }
  getString(e) {
    let t = [];
    for (let i = 0; i < e; i++) t[i] = this.getUint8();
    const n = t.indexOf(0);
    return n >= 0 && (t = t.slice(0, n)), Tn.decodeText(new Uint8Array(t));
  }
}
class lf {
  add(e, t) {
    this[e] = t;
  }
}
function j_(s) {
  const e = "Kaydara FBX Binary  \0";
  return s.byteLength >= e.length && e === uf(s, 0, e.length);
}
function q_(s) {
  const e = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\",
  ];
  let t = 0;
  function n(i) {
    const r = s[i - 1];
    return (s = s.slice(t + i)), t++, r;
  }
  for (let i = 0; i < e.length; ++i) if (n(1) === e[i]) return !1;
  return !0;
}
function lu(s) {
  const e = /FBXVersion: (\d+)/,
    t = s.match(e);
  if (t) return parseInt(t[1]);
  throw new Error(
    "THREE.FBXLoader: Cannot find the version number for the file given."
  );
}
function Y_(s) {
  return s / 46186158e3;
}
const Z_ = [];
function xo(s, e, t, n) {
  let i;
  switch (n.mappingType) {
    case "ByPolygonVertex":
      i = s;
      break;
    case "ByPolygon":
      i = e;
      break;
    case "ByVertice":
      i = t;
      break;
    case "AllSame":
      i = n.indices[0];
      break;
    default:
      console.warn(
        "THREE.FBXLoader: unknown attribute mapping type " + n.mappingType
      );
  }
  n.referenceType === "IndexToDirect" && (i = n.indices[i]);
  const r = i * n.dataSize,
    o = r + n.dataSize;
  return K_(Z_, n.buffer, r, o);
}
const ja = new mn(),
  rr = new P();
function cf(s) {
  const e = new be(),
    t = new be(),
    n = new be(),
    i = new be(),
    r = new be(),
    o = new be(),
    a = new be(),
    l = new be(),
    c = new be(),
    h = new be(),
    u = new be(),
    d = new be(),
    f = s.inheritType ? s.inheritType : 0;
  if (
    (s.translation && e.setPosition(rr.fromArray(s.translation)), s.preRotation)
  ) {
    const F = s.preRotation.map(Sn.degToRad);
    F.push(s.eulerOrder), t.makeRotationFromEuler(ja.fromArray(F));
  }
  if (s.rotation) {
    const F = s.rotation.map(Sn.degToRad);
    F.push(s.eulerOrder), n.makeRotationFromEuler(ja.fromArray(F));
  }
  if (s.postRotation) {
    const F = s.postRotation.map(Sn.degToRad);
    F.push(s.eulerOrder), i.makeRotationFromEuler(ja.fromArray(F)), i.invert();
  }
  s.scale && r.scale(rr.fromArray(s.scale)),
    s.scalingOffset && a.setPosition(rr.fromArray(s.scalingOffset)),
    s.scalingPivot && o.setPosition(rr.fromArray(s.scalingPivot)),
    s.rotationOffset && l.setPosition(rr.fromArray(s.rotationOffset)),
    s.rotationPivot && c.setPosition(rr.fromArray(s.rotationPivot)),
    s.parentMatrixWorld &&
      (u.copy(s.parentMatrix), h.copy(s.parentMatrixWorld));
  const m = t.clone().multiply(n).multiply(i),
    v = new be();
  v.extractRotation(h);
  const y = new be();
  y.copyPosition(h);
  const p = y.clone().invert().multiply(h),
    g = v.clone().invert().multiply(p),
    w = r,
    b = new be();
  if (f === 0) b.copy(v).multiply(m).multiply(g).multiply(w);
  else if (f === 1) b.copy(v).multiply(g).multiply(m).multiply(w);
  else {
    const M = new be().scale(new P().setFromMatrixScale(u)).clone().invert(),
      A = g.clone().multiply(M);
    b.copy(v).multiply(m).multiply(A).multiply(w);
  }
  const _ = c.clone().invert(),
    E = o.clone().invert();
  let L = e
    .clone()
    .multiply(l)
    .multiply(c)
    .multiply(t)
    .multiply(n)
    .multiply(i)
    .multiply(_)
    .multiply(a)
    .multiply(o)
    .multiply(r)
    .multiply(E);
  const D = new be().copyPosition(L),
    V = h.clone().multiply(D);
  return (
    d.copyPosition(V), (L = d.clone().multiply(b)), L.premultiply(h.invert()), L
  );
}
function hf(s) {
  s = s || 0;
  const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
  return s === 6
    ? (console.warn(
        "THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."
      ),
      e[0])
    : e[s];
}
function qa(s) {
  return s.split(",").map(function (t) {
    return parseFloat(t);
  });
}
function uf(s, e, t) {
  return (
    e === void 0 && (e = 0),
    t === void 0 && (t = s.byteLength),
    Tn.decodeText(new Uint8Array(s, e, t))
  );
}
function $_(s, e) {
  for (let t = 0, n = s.length, i = e.length; t < i; t++, n++) s[n] = e[t];
}
function K_(s, e, t, n) {
  for (let i = t, r = 0; i < n; i++, r++) s[r] = e[i];
  return s;
}
function cu(s, e, t) {
  return s.slice(0, e).concat(t).concat(s.slice(e));
}
const Ya = new WeakMap();
class fw extends cn {
  constructor(e) {
    super(e);
    (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, n, i) {
    const r = new Pn(this.manager);
    r.setPath(this.path),
      r.setResponseType("arraybuffer"),
      r.setRequestHeader(this.requestHeader),
      r.setWithCredentials(this.withCredentials),
      r.load(
        e,
        (o) => {
          const a = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(o, a).then(t).catch(i);
        },
        n,
        i
      );
  }
  decodeDracoFile(e, t, n, i) {
    const r = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
    };
    this.decodeGeometry(e, r).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const c = t.attributeTypes[l];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
    }
    const n = JSON.stringify(t);
    if (Ya.has(e)) {
      const l = Ya.get(e);
      if (l.key === n) return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const r = this.workerNextTaskID++,
      o = e.byteLength,
      a = this._getWorker(r, o)
        .then(
          (l) => (
            (i = l),
            new Promise((c, h) => {
              (i._callbacks[r] = { resolve: c, reject: h }),
                i.postMessage(
                  { type: "decode", id: r, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((l) => this._createGeometry(l.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          i && r && this._releaseTask(i, r);
        }),
      Ya.set(e, { key: n, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new tt();
    e.index && t.setIndex(new St(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n],
        r = i.name,
        o = i.array,
        a = i.itemSize;
      t.setAttribute(r, new St(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new Pn(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(t),
      n.setWithCredentials(this.withCredentials),
      new Promise((i, r) => {
        n.load(e, i, void 0, r);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((n) => {
        const i = n[0];
        e || (this.decoderConfig.wasmBinary = n[1]);
        const r = J_.toString(),
          o = [
            "/* draco decoder */",
            i,
            "",
            "/* worker */",
            r.substring(r.indexOf("{") + 1, r.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([o]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        (i._callbacks = {}),
          (i._taskCosts = {}),
          (i._taskLoad = 0),
          i.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (i.onmessage = function (r) {
            const o = r.data;
            switch (o.type) {
              case "decode":
                i._callbacks[o.id].resolve(o);
                break;
              case "error":
                i._callbacks[o.id].reject(o);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"'
                );
            }
          }),
          this.workerPool.push(i);
      } else
        this.workerPool.sort(function (i, r) {
          return i._taskLoad > r._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[e] = t), (n._taskLoad += t), n;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function J_() {
  let s, e;
  onmessage = function (o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        (s = a.decoderConfig),
          (e = new Promise(function (h) {
            (s.onModuleLoaded = function (u) {
              h({ draco: u });
            }),
              DracoDecoderModule(s);
          }));
        break;
      case "decode":
        const l = a.buffer,
          c = a.taskConfig;
        e.then((h) => {
          const u = h.draco,
            d = new u.Decoder(),
            f = new u.DecoderBuffer();
          f.Init(new Int8Array(l), l.byteLength);
          try {
            const m = t(u, d, f, c),
              v = m.attributes.map((y) => y.array.buffer);
            m.index && v.push(m.index.array.buffer),
              self.postMessage({ type: "decode", id: a.id, geometry: m }, v);
          } catch (m) {
            console.error(m),
              self.postMessage({ type: "error", id: a.id, error: m.message });
          } finally {
            u.destroy(f), u.destroy(d);
          }
        });
        break;
    }
  };
  function t(o, a, l, c) {
    const h = c.attributeIDs,
      u = c.attributeTypes;
    let d, f;
    const m = a.GetEncodedGeometryType(l);
    if (m === o.TRIANGULAR_MESH)
      (d = new o.Mesh()), (f = a.DecodeBufferToMesh(l, d));
    else if (m === o.POINT_CLOUD)
      (d = new o.PointCloud()), (f = a.DecodeBufferToPointCloud(l, d));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const v = { index: null, attributes: [] };
    for (const y in h) {
      const p = self[u[y]];
      let g, w;
      if (c.useUniqueIDs) (w = h[y]), (g = a.GetAttributeByUniqueId(d, w));
      else {
        if (((w = a.GetAttributeId(d, o[h[y]])), w === -1)) continue;
        g = a.GetAttribute(d, w);
      }
      v.attributes.push(i(o, a, d, y, p, g));
    }
    return m === o.TRIANGULAR_MESH && (v.index = n(o, a, d)), o.destroy(d), v;
  }
  function n(o, a, l) {
    const h = l.num_faces() * 3,
      u = h * 4,
      d = o._malloc(u);
    a.GetTrianglesUInt32Array(l, u, d);
    const f = new Uint32Array(o.HEAPF32.buffer, d, h).slice();
    return o._free(d), { array: f, itemSize: 1 };
  }
  function i(o, a, l, c, h, u) {
    const d = u.num_components(),
      m = l.num_points() * d,
      v = m * h.BYTES_PER_ELEMENT,
      y = r(o, h),
      p = o._malloc(v);
    a.GetAttributeDataArrayForAllPoints(l, u, y, v, p);
    const g = new h(o.HEAPF32.buffer, p, m).slice();
    return o._free(p), { name: c, array: g, itemSize: d };
  }
  function r(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
class pw extends fd {
  constructor(e) {
    super(e);
    this.type = nn;
  }
  parse(e) {
    const a = function (w, b) {
        switch (w) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (b || ""));
            break;
          case 2:
            console.error("THREE.RGBELoader Write Error: " + (b || ""));
            break;
          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (b || ""));
            break;
          default:
          case 4:
            console.error("THREE.RGBELoader: Error: " + (b || ""));
        }
        return -1;
      },
      u = `
`,
      d = function (w, b, _) {
        b = b || 1024;
        let L = w.pos,
          D = -1,
          V = 0,
          F = "",
          M = String.fromCharCode.apply(
            null,
            new Uint16Array(w.subarray(L, L + 128))
          );
        for (; 0 > (D = M.indexOf(u)) && V < b && L < w.byteLength; )
          (F += M),
            (V += M.length),
            (L += 128),
            (M += String.fromCharCode.apply(
              null,
              new Uint16Array(w.subarray(L, L + 128))
            ));
        return -1 < D
          ? (_ !== !1 && (w.pos += V + D + 1), F + M.slice(0, D))
          : !1;
      },
      f = function (w) {
        const b = /^#\?(\S+)/,
          _ = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          E = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          L = /^\s*FORMAT=(\S+)\s*$/,
          D = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          V = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let F, M;
        if (w.pos >= w.byteLength || !(F = d(w)))
          return a(1, "no header found");
        if (!(M = F.match(b))) return a(3, "bad initial token");
        for (
          V.valid |= 1,
            V.programtype = M[1],
            V.string +=
              F +
              `
`;
          (F = d(w)), F !== !1;

        ) {
          if (
            ((V.string +=
              F +
              `
`),
            F.charAt(0) === "#")
          ) {
            V.comments +=
              F +
              `
`;
            continue;
          }
          if (
            ((M = F.match(_)) && (V.gamma = parseFloat(M[1])),
            (M = F.match(E)) && (V.exposure = parseFloat(M[1])),
            (M = F.match(L)) && ((V.valid |= 2), (V.format = M[1])),
            (M = F.match(D)) &&
              ((V.valid |= 4),
              (V.height = parseInt(M[1], 10)),
              (V.width = parseInt(M[2], 10))),
            V.valid & 2 && V.valid & 4)
          )
            break;
        }
        return V.valid & 2
          ? V.valid & 4
            ? V
            : a(3, "missing image size specifier")
          : a(3, "missing format specifier");
      },
      m = function (w, b, _) {
        const E = b;
        if (E < 8 || E > 32767 || w[0] !== 2 || w[1] !== 2 || w[2] & 128)
          return new Uint8Array(w);
        if (E !== ((w[2] << 8) | w[3])) return a(3, "wrong scanline width");
        const L = new Uint8Array(4 * b * _);
        if (!L.length) return a(4, "unable to allocate buffer space");
        let D = 0,
          V = 0;
        const F = 4 * E,
          M = new Uint8Array(4),
          A = new Uint8Array(F);
        let N = _;
        for (; N > 0 && V < w.byteLength; ) {
          if (V + 4 > w.byteLength) return a(1);
          if (
            ((M[0] = w[V++]),
            (M[1] = w[V++]),
            (M[2] = w[V++]),
            (M[3] = w[V++]),
            M[0] != 2 || M[1] != 2 || ((M[2] << 8) | M[3]) != E)
          )
            return a(3, "bad rgbe scanline format");
          let O = 0,
            H;
          for (; O < F && V < w.byteLength; ) {
            H = w[V++];
            const W = H > 128;
            if ((W && (H -= 128), H === 0 || O + H > F))
              return a(3, "bad scanline data");
            if (W) {
              const k = w[V++];
              for (let Q = 0; Q < H; Q++) A[O++] = k;
            } else A.set(w.subarray(V, V + H), O), (O += H), (V += H);
          }
          const G = E;
          for (let W = 0; W < G; W++) {
            let k = 0;
            (L[D] = A[W + k]),
              (k += E),
              (L[D + 1] = A[W + k]),
              (k += E),
              (L[D + 2] = A[W + k]),
              (k += E),
              (L[D + 3] = A[W + k]),
              (D += 4);
          }
          N--;
        }
        return L;
      },
      v = function (w, b, _, E) {
        const L = w[b + 3],
          D = Math.pow(2, L - 128) / 255;
        (_[E + 0] = w[b + 0] * D),
          (_[E + 1] = w[b + 1] * D),
          (_[E + 2] = w[b + 2] * D),
          (_[E + 3] = 1);
      },
      y = function (w, b, _, E) {
        const L = w[b + 3],
          D = Math.pow(2, L - 128) / 255;
        (_[E + 0] = dr.toHalfFloat(Math.min(w[b + 0] * D, 65504))),
          (_[E + 1] = dr.toHalfFloat(Math.min(w[b + 1] * D, 65504))),
          (_[E + 2] = dr.toHalfFloat(Math.min(w[b + 2] * D, 65504))),
          (_[E + 3] = dr.toHalfFloat(1));
      },
      p = new Uint8Array(e);
    p.pos = 0;
    const g = f(p);
    if (g !== -1) {
      const w = g.width,
        b = g.height,
        _ = m(p.subarray(p.pos), w, b);
      if (_ !== -1) {
        let E, L, D, V;
        switch (this.type) {
          case tn:
            V = _.length / 4;
            const F = new Float32Array(V * 4);
            for (let A = 0; A < V; A++) v(_, A * 4, F, A * 4);
            (E = F), (D = tn);
            break;
          case nn:
            V = _.length / 4;
            const M = new Uint16Array(V * 4);
            for (let A = 0; A < V; A++) y(_, A * 4, M, A * 4);
            (E = M), (D = nn);
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: w,
          height: b,
          data: E,
          header: g.string,
          gamma: g.gamma,
          exposure: g.exposure,
          format: L,
          type: D,
        };
      }
    }
    return null;
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function r(o, a) {
      switch (o.type) {
        case tn:
          (o.encoding = an),
            (o.minFilter = st),
            (o.magFilter = st),
            (o.generateMipmaps = !1),
            (o.flipY = !0);
          break;
        case nn:
          (o.encoding = an),
            (o.minFilter = st),
            (o.magFilter = st),
            (o.generateMipmaps = !1),
            (o.flipY = !0);
          break;
      }
      t && t(o, a);
    }
    return super.load(e, r, n, i);
  }
}
class mw extends fd {
  constructor(e) {
    super(e);
    this.type = nn;
  }
  parse(e) {
    const V = Math.pow(2.7182818, 2.2);
    function F(x, S) {
      let I = 0;
      for (let j = 0; j < 65536; ++j)
        (j == 0 || x[j >> 3] & (1 << (j & 7))) && (S[I++] = j);
      const z = I - 1;
      for (; I < 65536; ) S[I++] = 0;
      return z;
    }
    function M(x) {
      for (let S = 0; S < 16384; S++)
        (x[S] = {}), (x[S].len = 0), (x[S].lit = 0), (x[S].p = null);
    }
    const A = { l: 0, c: 0, lc: 0 };
    function N(x, S, I, z, j) {
      for (; I < x; ) (S = (S << 8) | Te(z, j)), (I += 8);
      (I -= x), (A.l = (S >> I) & ((1 << x) - 1)), (A.c = S), (A.lc = I);
    }
    const O = new Array(59);
    function H(x) {
      for (let I = 0; I <= 58; ++I) O[I] = 0;
      for (let I = 0; I < 65537; ++I) O[x[I]] += 1;
      let S = 0;
      for (let I = 58; I > 0; --I) {
        const z = (S + O[I]) >> 1;
        (O[I] = S), (S = z);
      }
      for (let I = 0; I < 65537; ++I) {
        const z = x[I];
        z > 0 && (x[I] = z | (O[z]++ << 6));
      }
    }
    function G(x, S, I, z, j, X) {
      const he = S;
      let ge = 0,
        xe = 0;
      for (; z <= j; z++) {
        if (he.value - S.value > I) return !1;
        N(6, ge, xe, x, he);
        const le = A.l;
        if (((ge = A.c), (xe = A.lc), (X[z] = le), le == 63)) {
          if (he.value - S.value > I)
            throw new Error("Something wrong with hufUnpackEncTable");
          N(8, ge, xe, x, he);
          let se = A.l + 6;
          if (((ge = A.c), (xe = A.lc), z + se > j + 1))
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; se--; ) X[z++] = 0;
          z--;
        } else if (le >= 59) {
          let se = le - 59 + 2;
          if (z + se > j + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; se--; ) X[z++] = 0;
          z--;
        }
      }
      H(X);
    }
    function W(x) {
      return x & 63;
    }
    function k(x) {
      return x >> 6;
    }
    function Q(x, S, I, z) {
      for (; S <= I; S++) {
        const j = k(x[S]),
          X = W(x[S]);
        if (j >> X) throw new Error("Invalid table entry");
        if (X > 14) {
          const he = z[j >> (X - 14)];
          if (he.len) throw new Error("Invalid table entry");
          if ((he.lit++, he.p)) {
            const ge = he.p;
            he.p = new Array(he.lit);
            for (let xe = 0; xe < he.lit - 1; ++xe) he.p[xe] = ge[xe];
          } else he.p = new Array(1);
          he.p[he.lit - 1] = S;
        } else if (X) {
          let he = 0;
          for (let ge = 1 << (14 - X); ge > 0; ge--) {
            const xe = z[(j << (14 - X)) + he];
            if (xe.len || xe.p) throw new Error("Invalid table entry");
            (xe.len = X), (xe.lit = S), he++;
          }
        }
      }
      return !0;
    }
    const ie = { c: 0, lc: 0 };
    function re(x, S, I, z) {
      (x = (x << 8) | Te(I, z)), (S += 8), (ie.c = x), (ie.lc = S);
    }
    const ee = { c: 0, lc: 0 };
    function Me(x, S, I, z, j, X, he, ge, xe) {
      if (x == S) {
        z < 8 && (re(I, z, j, X), (I = ie.c), (z = ie.lc)), (z -= 8);
        let le = I >> z;
        if (((le = new Uint8Array([le])[0]), ge.value + le > xe)) return !1;
        const se = he[ge.value - 1];
        for (; le-- > 0; ) he[ge.value++] = se;
      } else if (ge.value < xe) he[ge.value++] = x;
      else return !1;
      (ee.c = I), (ee.lc = z);
    }
    function Be(x) {
      return x & 65535;
    }
    function Re(x) {
      const S = Be(x);
      return S > 32767 ? S - 65536 : S;
    }
    const Z = { a: 0, b: 0 };
    function qe(x, S) {
      const I = Re(x),
        j = Re(S),
        X = I + (j & 1) + (j >> 1),
        he = X,
        ge = X - j;
      (Z.a = he), (Z.b = ge);
    }
    function ke(x, S) {
      const I = Be(x),
        z = Be(S),
        j = (I - (z >> 1)) & 65535,
        X = (z + j - 32768) & 65535;
      (Z.a = X), (Z.b = j);
    }
    function Fe(x, S, I, z, j, X, he) {
      const ge = he < 16384,
        xe = I > j ? j : I;
      let le = 1,
        se,
        Pe;
      for (; le <= xe; ) le <<= 1;
      for (le >>= 1, se = le, le >>= 1; le >= 1; ) {
        Pe = 0;
        const we = Pe + X * (j - se),
          Oe = X * le,
          Xe = X * se,
          Ne = z * le,
          Ue = z * se;
        let Ge, pt, xt, yt;
        for (; Pe <= we; Pe += Xe) {
          let _t = Pe;
          const lt = Pe + z * (I - se);
          for (; _t <= lt; _t += Ue) {
            const Ot = _t + Ne,
              dn = _t + Oe,
              kt = dn + Ne;
            ge
              ? (qe(x[_t + S], x[dn + S]),
                (Ge = Z.a),
                (xt = Z.b),
                qe(x[Ot + S], x[kt + S]),
                (pt = Z.a),
                (yt = Z.b),
                qe(Ge, pt),
                (x[_t + S] = Z.a),
                (x[Ot + S] = Z.b),
                qe(xt, yt),
                (x[dn + S] = Z.a),
                (x[kt + S] = Z.b))
              : (ke(x[_t + S], x[dn + S]),
                (Ge = Z.a),
                (xt = Z.b),
                ke(x[Ot + S], x[kt + S]),
                (pt = Z.a),
                (yt = Z.b),
                ke(Ge, pt),
                (x[_t + S] = Z.a),
                (x[Ot + S] = Z.b),
                ke(xt, yt),
                (x[dn + S] = Z.a),
                (x[kt + S] = Z.b));
          }
          if (I & le) {
            const Ot = _t + Oe;
            ge ? qe(x[_t + S], x[Ot + S]) : ke(x[_t + S], x[Ot + S]),
              (Ge = Z.a),
              (x[Ot + S] = Z.b),
              (x[_t + S] = Ge);
          }
        }
        if (j & le) {
          let _t = Pe;
          const lt = Pe + z * (I - se);
          for (; _t <= lt; _t += Ue) {
            const Ot = _t + Ne;
            ge ? qe(x[_t + S], x[Ot + S]) : ke(x[_t + S], x[Ot + S]),
              (Ge = Z.a),
              (x[Ot + S] = Z.b),
              (x[_t + S] = Ge);
          }
        }
        (se = le), (le >>= 1);
      }
      return Pe;
    }
    function Ie(x, S, I, z, j, X, he, ge, xe) {
      let le = 0,
        se = 0;
      const Pe = he,
        we = Math.trunc(z.value + (j + 7) / 8);
      for (; z.value < we; )
        for (re(le, se, I, z), le = ie.c, se = ie.lc; se >= 14; ) {
          const Xe = (le >> (se - 14)) & 16383,
            Ne = S[Xe];
          if (Ne.len)
            (se -= Ne.len),
              Me(Ne.lit, X, le, se, I, z, ge, xe, Pe),
              (le = ee.c),
              (se = ee.lc);
          else {
            if (!Ne.p) throw new Error("hufDecode issues");
            let Ue;
            for (Ue = 0; Ue < Ne.lit; Ue++) {
              const Ge = W(x[Ne.p[Ue]]);
              for (; se < Ge && z.value < we; )
                re(le, se, I, z), (le = ie.c), (se = ie.lc);
              if (
                se >= Ge &&
                k(x[Ne.p[Ue]]) == ((le >> (se - Ge)) & ((1 << Ge) - 1))
              ) {
                (se -= Ge),
                  Me(Ne.p[Ue], X, le, se, I, z, ge, xe, Pe),
                  (le = ee.c),
                  (se = ee.lc);
                break;
              }
            }
            if (Ue == Ne.lit) throw new Error("hufDecode issues");
          }
        }
      const Oe = (8 - j) & 7;
      for (le >>= Oe, se -= Oe; se > 0; ) {
        const Xe = S[(le << (14 - se)) & 16383];
        if (Xe.len)
          (se -= Xe.len),
            Me(Xe.lit, X, le, se, I, z, ge, xe, Pe),
            (le = ee.c),
            (se = ee.lc);
        else throw new Error("hufDecode issues");
      }
      return !0;
    }
    function Ze(x, S, I, z, j, X) {
      const he = { value: 0 },
        ge = I.value,
        xe = ve(S, I),
        le = ve(S, I);
      I.value += 4;
      const se = ve(S, I);
      if (((I.value += 4), xe < 0 || xe >= 65537 || le < 0 || le >= 65537))
        throw new Error("Something wrong with HUF_ENCSIZE");
      const Pe = new Array(65537),
        we = new Array(16384);
      M(we);
      const Oe = z - (I.value - ge);
      if ((G(x, I, Oe, xe, le, Pe), se > 8 * (z - (I.value - ge))))
        throw new Error("Something wrong with hufUncompress");
      Q(Pe, xe, le, we), Ie(Pe, we, x, I, se, le, X, j, he);
    }
    function K(x, S, I) {
      for (let z = 0; z < I; ++z) S[z] = x[S[z]];
    }
    function de(x) {
      for (let S = 1; S < x.length; S++) {
        const I = x[S - 1] + x[S] - 128;
        x[S] = I;
      }
    }
    function pe(x, S) {
      let I = 0,
        z = Math.floor((x.length + 1) / 2),
        j = 0;
      const X = x.length - 1;
      for (; !(j > X || ((S[j++] = x[I++]), j > X)); ) S[j++] = x[z++];
    }
    function De(x) {
      let S = x.byteLength;
      const I = new Array();
      let z = 0;
      const j = new DataView(x);
      for (; S > 0; ) {
        const X = j.getInt8(z++);
        if (X < 0) {
          const he = -X;
          S -= he + 1;
          for (let ge = 0; ge < he; ge++) I.push(j.getUint8(z++));
        } else {
          const he = X;
          S -= 2;
          const ge = j.getUint8(z++);
          for (let xe = 0; xe < he + 1; xe++) I.push(ge);
        }
      }
      return I;
    }
    function Ee(x, S, I, z, j, X) {
      let he = new DataView(X.buffer);
      const ge = I[x.idx[0]].width,
        xe = I[x.idx[0]].height,
        le = 3,
        se = Math.floor(ge / 8),
        Pe = Math.ceil(ge / 8),
        we = Math.ceil(xe / 8),
        Oe = ge - (Pe - 1) * 8,
        Xe = xe - (we - 1) * 8,
        Ne = { value: 0 },
        Ue = new Array(le),
        Ge = new Array(le),
        pt = new Array(le),
        xt = new Array(le),
        yt = new Array(le);
      for (let lt = 0; lt < le; ++lt)
        (yt[lt] = S[x.idx[lt]]),
          (Ue[lt] = lt < 1 ? 0 : Ue[lt - 1] + Pe * we),
          (Ge[lt] = new Float32Array(64)),
          (pt[lt] = new Uint16Array(64)),
          (xt[lt] = new Uint16Array(Pe * 64));
      for (let lt = 0; lt < we; ++lt) {
        let Ot = 8;
        lt == we - 1 && (Ot = Xe);
        let dn = 8;
        for (let ft = 0; ft < Pe; ++ft) {
          ft == Pe - 1 && (dn = Oe);
          for (let gt = 0; gt < le; ++gt)
            pt[gt].fill(0),
              (pt[gt][0] = j[Ue[gt]++]),
              We(Ne, z, pt[gt]),
              ze(pt[gt], Ge[gt]),
              $e(Ge[gt]);
          ut(Ge);
          for (let gt = 0; gt < le; ++gt) R(Ge[gt], xt[gt], ft * 64);
        }
        let kt = 0;
        for (let ft = 0; ft < le; ++ft) {
          const gt = I[x.idx[ft]].type;
          for (let On = 8 * lt; On < 8 * lt + Ot; ++On) {
            kt = yt[ft][On];
            for (let qr = 0; qr < se; ++qr) {
              const En = qr * 64 + (On & 7) * 8;
              he.setUint16(kt + 0 * 2 * gt, xt[ft][En + 0], !0),
                he.setUint16(kt + 1 * 2 * gt, xt[ft][En + 1], !0),
                he.setUint16(kt + 2 * 2 * gt, xt[ft][En + 2], !0),
                he.setUint16(kt + 3 * 2 * gt, xt[ft][En + 3], !0),
                he.setUint16(kt + 4 * 2 * gt, xt[ft][En + 4], !0),
                he.setUint16(kt + 5 * 2 * gt, xt[ft][En + 5], !0),
                he.setUint16(kt + 6 * 2 * gt, xt[ft][En + 6], !0),
                he.setUint16(kt + 7 * 2 * gt, xt[ft][En + 7], !0),
                (kt += 8 * 2 * gt);
            }
          }
          if (se != Pe)
            for (let On = 8 * lt; On < 8 * lt + Ot; ++On) {
              const qr = yt[ft][On] + 8 * se * 2 * gt,
                En = se * 64 + (On & 7) * 8;
              for (let Bs = 0; Bs < dn; ++Bs)
                he.setUint16(qr + Bs * 2 * gt, xt[ft][En + Bs], !0);
            }
        }
      }
      const _t = new Uint16Array(ge);
      he = new DataView(X.buffer);
      for (let lt = 0; lt < le; ++lt) {
        I[x.idx[lt]].decoded = !0;
        const Ot = I[x.idx[lt]].type;
        if (I[lt].type == 2)
          for (let dn = 0; dn < xe; ++dn) {
            const kt = yt[lt][dn];
            for (let ft = 0; ft < ge; ++ft)
              _t[ft] = he.getUint16(kt + ft * 2 * Ot, !0);
            for (let ft = 0; ft < ge; ++ft)
              he.setFloat32(kt + ft * 2 * Ot, ue(_t[ft]), !0);
          }
      }
    }
    function We(x, S, I) {
      let z,
        j = 1;
      for (; j < 64; )
        (z = S[x.value]),
          z == 65280
            ? (j = 64)
            : z >> 8 == 255
            ? (j += z & 255)
            : ((I[j] = z), j++),
          x.value++;
    }
    function ze(x, S) {
      (S[0] = ue(x[0])),
        (S[1] = ue(x[1])),
        (S[2] = ue(x[5])),
        (S[3] = ue(x[6])),
        (S[4] = ue(x[14])),
        (S[5] = ue(x[15])),
        (S[6] = ue(x[27])),
        (S[7] = ue(x[28])),
        (S[8] = ue(x[2])),
        (S[9] = ue(x[4])),
        (S[10] = ue(x[7])),
        (S[11] = ue(x[13])),
        (S[12] = ue(x[16])),
        (S[13] = ue(x[26])),
        (S[14] = ue(x[29])),
        (S[15] = ue(x[42])),
        (S[16] = ue(x[3])),
        (S[17] = ue(x[8])),
        (S[18] = ue(x[12])),
        (S[19] = ue(x[17])),
        (S[20] = ue(x[25])),
        (S[21] = ue(x[30])),
        (S[22] = ue(x[41])),
        (S[23] = ue(x[43])),
        (S[24] = ue(x[9])),
        (S[25] = ue(x[11])),
        (S[26] = ue(x[18])),
        (S[27] = ue(x[24])),
        (S[28] = ue(x[31])),
        (S[29] = ue(x[40])),
        (S[30] = ue(x[44])),
        (S[31] = ue(x[53])),
        (S[32] = ue(x[10])),
        (S[33] = ue(x[19])),
        (S[34] = ue(x[23])),
        (S[35] = ue(x[32])),
        (S[36] = ue(x[39])),
        (S[37] = ue(x[45])),
        (S[38] = ue(x[52])),
        (S[39] = ue(x[54])),
        (S[40] = ue(x[20])),
        (S[41] = ue(x[22])),
        (S[42] = ue(x[33])),
        (S[43] = ue(x[38])),
        (S[44] = ue(x[46])),
        (S[45] = ue(x[51])),
        (S[46] = ue(x[55])),
        (S[47] = ue(x[60])),
        (S[48] = ue(x[21])),
        (S[49] = ue(x[34])),
        (S[50] = ue(x[37])),
        (S[51] = ue(x[47])),
        (S[52] = ue(x[50])),
        (S[53] = ue(x[56])),
        (S[54] = ue(x[59])),
        (S[55] = ue(x[61])),
        (S[56] = ue(x[35])),
        (S[57] = ue(x[36])),
        (S[58] = ue(x[48])),
        (S[59] = ue(x[49])),
        (S[60] = ue(x[57])),
        (S[61] = ue(x[58])),
        (S[62] = ue(x[62])),
        (S[63] = ue(x[63]));
    }
    function $e(x) {
      const S = 0.5 * Math.cos(0.7853975),
        I = 0.5 * Math.cos(3.14159 / 16),
        z = 0.5 * Math.cos(3.14159 / 8),
        j = 0.5 * Math.cos((3 * 3.14159) / 16),
        X = 0.5 * Math.cos((5 * 3.14159) / 16),
        he = 0.5 * Math.cos((3 * 3.14159) / 8),
        ge = 0.5 * Math.cos((7 * 3.14159) / 16),
        xe = new Array(4),
        le = new Array(4),
        se = new Array(4),
        Pe = new Array(4);
      for (let we = 0; we < 8; ++we) {
        const Oe = we * 8;
        (xe[0] = z * x[Oe + 2]),
          (xe[1] = he * x[Oe + 2]),
          (xe[2] = z * x[Oe + 6]),
          (xe[3] = he * x[Oe + 6]),
          (le[0] =
            I * x[Oe + 1] + j * x[Oe + 3] + X * x[Oe + 5] + ge * x[Oe + 7]),
          (le[1] =
            j * x[Oe + 1] - ge * x[Oe + 3] - I * x[Oe + 5] - X * x[Oe + 7]),
          (le[2] =
            X * x[Oe + 1] - I * x[Oe + 3] + ge * x[Oe + 5] + j * x[Oe + 7]),
          (le[3] =
            ge * x[Oe + 1] - X * x[Oe + 3] + j * x[Oe + 5] - I * x[Oe + 7]),
          (se[0] = S * (x[Oe + 0] + x[Oe + 4])),
          (se[3] = S * (x[Oe + 0] - x[Oe + 4])),
          (se[1] = xe[0] + xe[3]),
          (se[2] = xe[1] - xe[2]),
          (Pe[0] = se[0] + se[1]),
          (Pe[1] = se[3] + se[2]),
          (Pe[2] = se[3] - se[2]),
          (Pe[3] = se[0] - se[1]),
          (x[Oe + 0] = Pe[0] + le[0]),
          (x[Oe + 1] = Pe[1] + le[1]),
          (x[Oe + 2] = Pe[2] + le[2]),
          (x[Oe + 3] = Pe[3] + le[3]),
          (x[Oe + 4] = Pe[3] - le[3]),
          (x[Oe + 5] = Pe[2] - le[2]),
          (x[Oe + 6] = Pe[1] - le[1]),
          (x[Oe + 7] = Pe[0] - le[0]);
      }
      for (let we = 0; we < 8; ++we)
        (xe[0] = z * x[16 + we]),
          (xe[1] = he * x[16 + we]),
          (xe[2] = z * x[48 + we]),
          (xe[3] = he * x[48 + we]),
          (le[0] =
            I * x[8 + we] + j * x[24 + we] + X * x[40 + we] + ge * x[56 + we]),
          (le[1] =
            j * x[8 + we] - ge * x[24 + we] - I * x[40 + we] - X * x[56 + we]),
          (le[2] =
            X * x[8 + we] - I * x[24 + we] + ge * x[40 + we] + j * x[56 + we]),
          (le[3] =
            ge * x[8 + we] - X * x[24 + we] + j * x[40 + we] - I * x[56 + we]),
          (se[0] = S * (x[we] + x[32 + we])),
          (se[3] = S * (x[we] - x[32 + we])),
          (se[1] = xe[0] + xe[3]),
          (se[2] = xe[1] - xe[2]),
          (Pe[0] = se[0] + se[1]),
          (Pe[1] = se[3] + se[2]),
          (Pe[2] = se[3] - se[2]),
          (Pe[3] = se[0] - se[1]),
          (x[0 + we] = Pe[0] + le[0]),
          (x[8 + we] = Pe[1] + le[1]),
          (x[16 + we] = Pe[2] + le[2]),
          (x[24 + we] = Pe[3] + le[3]),
          (x[32 + we] = Pe[3] - le[3]),
          (x[40 + we] = Pe[2] - le[2]),
          (x[48 + we] = Pe[1] - le[1]),
          (x[56 + we] = Pe[0] - le[0]);
    }
    function ut(x) {
      for (let S = 0; S < 64; ++S) {
        const I = x[0][S],
          z = x[1][S],
          j = x[2][S];
        (x[0][S] = I + 1.5747 * j),
          (x[1][S] = I - 0.1873 * z - 0.4682 * j),
          (x[2][S] = I + 1.8556 * z);
      }
    }
    function R(x, S, I) {
      for (let z = 0; z < 64; ++z) S[I + z] = dr.toHalfFloat(T(x[z]));
    }
    function T(x) {
      return x <= 1
        ? Math.sign(x) * Math.pow(Math.abs(x), 2.2)
        : Math.sign(x) * Math.pow(V, Math.abs(x) - 1);
    }
    function te(x) {
      return new DataView(x.array.buffer, x.offset.value, x.size);
    }
    function ce(x) {
      const S = x.viewer.buffer.slice(x.offset.value, x.offset.value + x.size),
        I = new Uint8Array(De(S)),
        z = new Uint8Array(I.length);
      return de(I), pe(I, z), new DataView(z.buffer);
    }
    function _e(x) {
      const S = x.array.slice(x.offset.value, x.offset.value + x.size);
      typeof Cl == "undefined" &&
        console.error(
          "THREE.EXRLoader: External library fflate.min.js required."
        );
      const I = qn(S),
        z = new Uint8Array(I.length);
      return de(I), pe(I, z), new DataView(z.buffer);
    }
    function Le(x) {
      const S = x.viewer,
        I = { value: x.offset.value },
        z = new Uint16Array(
          x.width * x.scanlineBlockSize * (x.channels * x.type)
        ),
        j = new Uint8Array(8192);
      let X = 0;
      const he = new Array(x.channels);
      for (let Xe = 0; Xe < x.channels; Xe++)
        (he[Xe] = {}),
          (he[Xe].start = X),
          (he[Xe].end = he[Xe].start),
          (he[Xe].nx = x.width),
          (he[Xe].ny = x.lines),
          (he[Xe].size = x.type),
          (X += he[Xe].nx * he[Xe].ny * he[Xe].size);
      const ge = Ct(S, I),
        xe = Ct(S, I);
      if (xe >= 8192)
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      if (ge <= xe)
        for (let Xe = 0; Xe < xe - ge + 1; Xe++) j[Xe + ge] = Ve(S, I);
      const le = new Uint16Array(65536),
        se = F(j, le),
        Pe = ve(S, I);
      Ze(x.array, S, I, Pe, z, X);
      for (let Xe = 0; Xe < x.channels; ++Xe) {
        const Ne = he[Xe];
        for (let Ue = 0; Ue < he[Xe].size; ++Ue)
          Fe(z, Ne.start + Ue, Ne.nx, Ne.size, Ne.ny, Ne.nx * Ne.size, se);
      }
      K(le, z, X);
      let we = 0;
      const Oe = new Uint8Array(z.buffer.byteLength);
      for (let Xe = 0; Xe < x.lines; Xe++)
        for (let Ne = 0; Ne < x.channels; Ne++) {
          const Ue = he[Ne],
            Ge = Ue.nx * Ue.size,
            pt = new Uint8Array(z.buffer, Ue.end * 2, Ge * 2);
          Oe.set(pt, we), (we += Ge * 2), (Ue.end += Ge);
        }
      return new DataView(Oe.buffer);
    }
    function He(x) {
      const S = x.array.slice(x.offset.value, x.offset.value + x.size);
      typeof Cl == "undefined" &&
        console.error(
          "THREE.EXRLoader: External library fflate.min.js required."
        );
      const I = qn(S),
        z = x.lines * x.channels * x.width,
        j = x.type == 1 ? new Uint16Array(z) : new Uint32Array(z);
      let X = 0,
        he = 0;
      const ge = new Array(4);
      for (let xe = 0; xe < x.lines; xe++)
        for (let le = 0; le < x.channels; le++) {
          let se = 0;
          switch (x.type) {
            case 1:
              (ge[0] = X), (ge[1] = ge[0] + x.width), (X = ge[1] + x.width);
              for (let Pe = 0; Pe < x.width; ++Pe)
                (se += (I[ge[0]++] << 8) | I[ge[1]++]), (j[he] = se), he++;
              break;
            case 2:
              (ge[0] = X),
                (ge[1] = ge[0] + x.width),
                (ge[2] = ge[1] + x.width),
                (X = ge[2] + x.width);
              for (let Pe = 0; Pe < x.width; ++Pe)
                (se +=
                  (I[ge[0]++] << 24) | (I[ge[1]++] << 16) | (I[ge[2]++] << 8)),
                  (j[he] = se),
                  he++;
              break;
          }
        }
      return new DataView(j.buffer);
    }
    function ne(x) {
      const S = x.viewer,
        I = { value: x.offset.value },
        z = new Uint8Array(x.width * x.lines * (x.channels * x.type * 2)),
        j = {
          version: me(S, I),
          unknownUncompressedSize: me(S, I),
          unknownCompressedSize: me(S, I),
          acCompressedSize: me(S, I),
          dcCompressedSize: me(S, I),
          rleCompressedSize: me(S, I),
          rleUncompressedSize: me(S, I),
          rleRawSize: me(S, I),
          totalAcUncompressedCount: me(S, I),
          totalDcUncompressedCount: me(S, I),
          acCompression: me(S, I),
        };
      if (j.version < 2)
        throw new Error(
          "EXRLoader.parse: " +
            $.compression +
            " version " +
            j.version +
            " is unsupported"
        );
      const X = new Array();
      let he = Ct(S, I) - 2;
      for (; he > 0; ) {
        const Ne = U(S.buffer, I),
          Ue = Ve(S, I),
          Ge = (Ue >> 2) & 3,
          pt = (Ue >> 4) - 1,
          xt = new Int8Array([pt])[0],
          yt = Ve(S, I);
        X.push({ name: Ne, index: xt, type: yt, compression: Ge }),
          (he -= Ne.length + 3);
      }
      const ge = $.channels,
        xe = new Array(x.channels);
      for (let Ne = 0; Ne < x.channels; ++Ne) {
        const Ue = (xe[Ne] = {}),
          Ge = ge[Ne];
        (Ue.name = Ge.name),
          (Ue.compression = 0),
          (Ue.decoded = !1),
          (Ue.type = Ge.pixelType),
          (Ue.pLinear = Ge.pLinear),
          (Ue.width = x.width),
          (Ue.height = x.lines);
      }
      const le = { idx: new Array(3) };
      for (let Ne = 0; Ne < x.channels; ++Ne) {
        const Ue = xe[Ne];
        for (let Ge = 0; Ge < X.length; ++Ge) {
          const pt = X[Ge];
          Ue.name == pt.name &&
            ((Ue.compression = pt.compression),
            pt.index >= 0 && (le.idx[pt.index] = Ne),
            (Ue.offset = Ne));
        }
      }
      let se, Pe, we;
      if (j.acCompressedSize > 0)
        switch (j.acCompression) {
          case 0:
            (se = new Uint16Array(j.totalAcUncompressedCount)),
              Ze(
                x.array,
                S,
                I,
                j.acCompressedSize,
                se,
                j.totalAcUncompressedCount
              );
            break;
          case 1:
            const Ne = x.array.slice(
                I.value,
                I.value + j.totalAcUncompressedCount
              ),
              Ue = qn(Ne);
            (se = new Uint16Array(Ue.buffer)),
              (I.value += j.totalAcUncompressedCount);
            break;
        }
      if (j.dcCompressedSize > 0) {
        const Ne = { array: x.array, offset: I, size: j.dcCompressedSize };
        (Pe = new Uint16Array(_e(Ne).buffer)), (I.value += j.dcCompressedSize);
      }
      if (j.rleRawSize > 0) {
        const Ne = x.array.slice(I.value, I.value + j.rleCompressedSize),
          Ue = qn(Ne);
        (we = De(Ue.buffer)), (I.value += j.rleCompressedSize);
      }
      let Oe = 0;
      const Xe = new Array(xe.length);
      for (let Ne = 0; Ne < Xe.length; ++Ne) Xe[Ne] = new Array();
      for (let Ne = 0; Ne < x.lines; ++Ne)
        for (let Ue = 0; Ue < xe.length; ++Ue)
          Xe[Ue].push(Oe), (Oe += xe[Ue].width * x.type * 2);
      Ee(le, Xe, xe, se, Pe, z);
      for (let Ne = 0; Ne < xe.length; ++Ne) {
        const Ue = xe[Ne];
        if (!Ue.decoded)
          switch (Ue.compression) {
            case 2:
              let Ge = 0,
                pt = 0;
              for (let xt = 0; xt < x.lines; ++xt) {
                let yt = Xe[Ne][Ge];
                for (let _t = 0; _t < Ue.width; ++_t) {
                  for (let lt = 0; lt < 2 * Ue.type; ++lt)
                    z[yt++] = we[pt + lt * Ue.width * Ue.height];
                  pt++;
                }
                Ge++;
              }
              break;
            case 1:
            default:
              throw new Error(
                "EXRLoader.parse: unsupported channel compression"
              );
          }
      }
      return new DataView(z.buffer);
    }
    function U(x, S) {
      const I = new Uint8Array(x);
      let z = 0;
      for (; I[S.value + z] != 0; ) z += 1;
      const j = new TextDecoder().decode(I.slice(S.value, S.value + z));
      return (S.value = S.value + z + 1), j;
    }
    function fe(x, S, I) {
      const z = new TextDecoder().decode(
        new Uint8Array(x).slice(S.value, S.value + I)
      );
      return (S.value = S.value + I), z;
    }
    function Ce(x, S) {
      const I = B(x, S),
        z = ve(x, S);
      return [I, z];
    }
    function Se(x, S) {
      const I = ve(x, S),
        z = ve(x, S);
      return [I, z];
    }
    function B(x, S) {
      const I = x.getInt32(S.value, !0);
      return (S.value = S.value + 4), I;
    }
    function ve(x, S) {
      const I = x.getUint32(S.value, !0);
      return (S.value = S.value + 4), I;
    }
    function Te(x, S) {
      const I = x[S.value];
      return (S.value = S.value + 1), I;
    }
    function Ve(x, S) {
      const I = x.getUint8(S.value);
      return (S.value = S.value + 1), I;
    }
    const me = function (x, S) {
      let I;
      return (
        "getBigInt64" in DataView.prototype
          ? (I = Number(x.getBigInt64(S.value, !0)))
          : (I =
              x.getUint32(S.value + 4, !0) +
              Number(x.getUint32(S.value, !0) << 32)),
        (S.value += 8),
        I
      );
    };
    function oe(x, S) {
      const I = x.getFloat32(S.value, !0);
      return (S.value += 4), I;
    }
    function Ye(x, S) {
      return dr.toHalfFloat(oe(x, S));
    }
    function ue(x) {
      const S = (x & 31744) >> 10,
        I = x & 1023;
      return (
        (x >> 15 ? -1 : 1) *
        (S
          ? S === 31
            ? I
              ? NaN
              : 1 / 0
            : Math.pow(2, S - 15) * (1 + I / 1024)
          : 6103515625e-14 * (I / 1024))
      );
    }
    function Ct(x, S) {
      const I = x.getUint16(S.value, !0);
      return (S.value += 2), I;
    }
    function dt(x, S) {
      return ue(Ct(x, S));
    }
    function hn(x, S, I, z) {
      const j = I.value,
        X = [];
      for (; I.value < j + z - 1; ) {
        const he = U(S, I),
          ge = B(x, I),
          xe = Ve(x, I);
        I.value += 3;
        const le = B(x, I),
          se = B(x, I);
        X.push({
          name: he,
          pixelType: ge,
          pLinear: xe,
          xSampling: le,
          ySampling: se,
        });
      }
      return (I.value += 1), X;
    }
    function un(x, S) {
      const I = oe(x, S),
        z = oe(x, S),
        j = oe(x, S),
        X = oe(x, S),
        he = oe(x, S),
        ge = oe(x, S),
        xe = oe(x, S),
        le = oe(x, S);
      return {
        redX: I,
        redY: z,
        greenX: j,
        greenY: X,
        blueX: he,
        blueY: ge,
        whiteX: xe,
        whiteY: le,
      };
    }
    function Qo(x, S) {
      const I = [
          "NO_COMPRESSION",
          "RLE_COMPRESSION",
          "ZIPS_COMPRESSION",
          "ZIP_COMPRESSION",
          "PIZ_COMPRESSION",
          "PXR24_COMPRESSION",
          "B44_COMPRESSION",
          "B44A_COMPRESSION",
          "DWAA_COMPRESSION",
          "DWAB_COMPRESSION",
        ],
        z = Ve(x, S);
      return I[z];
    }
    function Oi(x, S) {
      const I = ve(x, S),
        z = ve(x, S),
        j = ve(x, S),
        X = ve(x, S);
      return { xMin: I, yMin: z, xMax: j, yMax: X };
    }
    function ea(x, S) {
      const I = ["INCREASING_Y"],
        z = Ve(x, S);
      return I[z];
    }
    function jr(x, S) {
      const I = oe(x, S),
        z = oe(x, S);
      return [I, z];
    }
    function Ns(x, S) {
      const I = oe(x, S),
        z = oe(x, S),
        j = oe(x, S);
      return [I, z, j];
    }
    function ta(x, S, I, z, j) {
      if (z === "string" || z === "stringvector" || z === "iccProfile")
        return fe(S, I, j);
      if (z === "chlist") return hn(x, S, I, j);
      if (z === "chromaticities") return un(x, I);
      if (z === "compression") return Qo(x, I);
      if (z === "box2i") return Oi(x, I);
      if (z === "lineOrder") return ea(x, I);
      if (z === "float") return oe(x, I);
      if (z === "v2f") return jr(x, I);
      if (z === "v3f") return Ns(x, I);
      if (z === "int") return B(x, I);
      if (z === "rational") return Ce(x, I);
      if (z === "timecode") return Se(x, I);
      if (z === "preview") return (I.value += j), "skipped";
      I.value += j;
    }
    function na(x, S, I) {
      const z = {};
      if (x.getUint32(0, !0) != 20000630)
        throw new Error(
          "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format."
        );
      z.version = x.getUint8(4);
      const j = x.getUint8(5);
      (z.spec = {
        singleTile: !!(j & 2),
        longName: !!(j & 4),
        deepFormat: !!(j & 8),
        multiPart: !!(j & 16),
      }),
        (I.value = 8);
      let X = !0;
      for (; X; ) {
        const he = U(S, I);
        if (he == 0) X = !1;
        else {
          const ge = U(S, I),
            xe = ve(x, I),
            le = ta(x, S, I, ge, xe);
          le === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${ge}'.`
              )
            : (z[he] = le);
        }
      }
      if (j != 0)
        throw (
          (console.error("EXRHeader:", z),
          new Error("THREE.EXRLoader: provided file is currently unsupported."))
        );
      return z;
    }
    function ia(x, S, I, z, j) {
      const X = {
        size: 0,
        viewer: S,
        array: I,
        offset: z,
        width: x.dataWindow.xMax - x.dataWindow.xMin + 1,
        height: x.dataWindow.yMax - x.dataWindow.yMin + 1,
        channels: x.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: x.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        encoding: null,
      };
      switch (x.compression) {
        case "NO_COMPRESSION":
          (X.lines = 1), (X.uncompress = te);
          break;
        case "RLE_COMPRESSION":
          (X.lines = 1), (X.uncompress = ce);
          break;
        case "ZIPS_COMPRESSION":
          (X.lines = 1), (X.uncompress = _e);
          break;
        case "ZIP_COMPRESSION":
          (X.lines = 16), (X.uncompress = _e);
          break;
        case "PIZ_COMPRESSION":
          (X.lines = 32), (X.uncompress = Le);
          break;
        case "PXR24_COMPRESSION":
          (X.lines = 16), (X.uncompress = He);
          break;
        case "DWAA_COMPRESSION":
          (X.lines = 32), (X.uncompress = ne);
          break;
        case "DWAB_COMPRESSION":
          (X.lines = 256), (X.uncompress = ne);
          break;
        default:
          throw new Error(
            "EXRLoader.parse: " + x.compression + " is unsupported"
          );
      }
      if (((X.scanlineBlockSize = X.lines), X.type == 1))
        switch (j) {
          case tn:
            (X.getter = dt), (X.inputSize = 2);
            break;
          case nn:
            (X.getter = Ct), (X.inputSize = 2);
            break;
        }
      else if (X.type == 2)
        switch (j) {
          case tn:
            (X.getter = oe), (X.inputSize = 4);
            break;
          case nn:
            (X.getter = Ye), (X.inputSize = 4);
        }
      else
        throw new Error(
          "EXRLoader.parse: unsupported pixelType " +
            X.type +
            " for " +
            x.compression +
            "."
        );
      X.blockCount = (x.dataWindow.yMax + 1) / X.scanlineBlockSize;
      for (let ge = 0; ge < X.blockCount; ge++) me(S, z);
      X.outputChannels = X.channels == 3 ? 4 : X.channels;
      const he = X.width * X.height * X.outputChannels;
      switch (j) {
        case tn:
          (X.byteArray = new Float32Array(he)),
            X.channels < X.outputChannels && X.byteArray.fill(1, 0, he);
          break;
        case nn:
          (X.byteArray = new Uint16Array(he)),
            X.channels < X.outputChannels && X.byteArray.fill(15360, 0, he);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", j);
          break;
      }
      return (
        (X.bytesPerLine = X.width * X.inputSize * X.channels),
        X.outputChannels == 4
          ? ((X.format = Nt), (X.encoding = an))
          : ((X.format = wu), (X.encoding = an)),
        X
      );
    }
    const C = new DataView(e),
      q = new Uint8Array(e),
      J = { value: 0 },
      $ = na(C, e, J),
      Y = ia($, C, q, J, this.type),
      je = { value: 0 },
      Ke = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let x = 0; x < Y.height / Y.scanlineBlockSize; x++) {
      const S = ve(C, J);
      (Y.size = ve(C, J)),
        (Y.lines =
          S + Y.scanlineBlockSize > Y.height
            ? Y.height - S
            : Y.scanlineBlockSize);
      const z = Y.size < Y.lines * Y.bytesPerLine ? Y.uncompress(Y) : te(Y);
      J.value += Y.size;
      for (let j = 0; j < Y.scanlineBlockSize; j++) {
        const X = j + x * Y.scanlineBlockSize;
        if (X >= Y.height) break;
        for (let he = 0; he < Y.channels; he++) {
          const ge = Ke[$.channels[he].name];
          for (let xe = 0; xe < Y.width; xe++) {
            je.value =
              (j * (Y.channels * Y.width) + he * Y.width + xe) * Y.inputSize;
            const le =
              (Y.height - 1 - X) * (Y.width * Y.outputChannels) +
              xe * Y.outputChannels +
              ge;
            Y.byteArray[le] = Y.getter(z, je);
          }
        }
      }
    }
    return {
      header: $,
      width: Y.width,
      height: Y.height,
      data: Y.byteArray,
      format: Y.format,
      encoding: Y.encoding,
      type: this.type,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function r(o, a) {
      (o.encoding = a.encoding),
        (o.minFilter = st),
        (o.magFilter = st),
        (o.generateMipmaps = !1),
        (o.flipY = !1),
        t && t(o, a);
    }
    return super.load(e, r, n, i);
  }
}
class Q_ {
  constructor(e = 4) {
    (this.pool = e),
      (this.queue = []),
      (this.workers = []),
      (this.workersResolve = []),
      (this.workerStatus = 0);
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)),
        (this.workers[e] = t);
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & (1 << e))) return e;
    return -1;
  }
  _onMessage(e, t) {
    const n = this.workersResolve[e];
    if ((n && n(t), this.queue.length)) {
      const { resolve: i, msg: r, transfer: o } = this.queue.shift();
      (this.workersResolve[e] = i), this.workers[e].postMessage(r, o);
    } else this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((n) => {
      const i = this._getIdleWorker();
      i !== -1
        ? (this._initWorker(i),
          (this.workerStatus |= 1 << i),
          (this.workersResolve[i] = n),
          this.workers[i].postMessage(e, t))
        : this.queue.push({ resolve: n, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()),
      (this.workersResolve.length = 0),
      (this.workers.length = 0),
      (this.queue.length = 0),
      (this.workerStatus = 0);
  }
}
const ew = 2,
  tw = 1,
  Za = new WeakMap();
let $a = 0;
class Yn extends cn {
  constructor(e) {
    super(e);
    (this.transcoderPath = ""),
      (this.transcoderBinary = null),
      (this.transcoderPending = null),
      (this.workerPool = new Q_()),
      (this.workerSourceURL = ""),
      (this.workerConfig = null),
      typeof MSC_TRANSCODER != "undefined" &&
        console.warn(
          'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
        );
  }
  setTranscoderPath(e) {
    return (this.transcoderPath = e), this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  detectSupport(e) {
    return (
      (this.workerConfig = {
        astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported:
          e.extensions.has("WEBGL_compressed_texture_pvrtc") ||
          e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      }),
      e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1),
      this
    );
  }
  init() {
    if (!this.transcoderPending) {
      const e = new Pn(this.manager);
      e.setPath(this.transcoderPath),
        e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"),
        n = new Pn(this.manager);
      n.setPath(this.transcoderPath),
        n.setResponseType("arraybuffer"),
        n.setWithCredentials(this.withCredentials);
      const i = n.loadAsync("basis_transcoder.wasm");
      (this.transcoderPending = Promise.all([t, i]).then(([r, o]) => {
        const a = Yn.BasisWorker.toString(),
          l = [
            "/* constants */",
            "let _EngineFormat = " + JSON.stringify(Yn.EngineFormat),
            "let _TranscoderFormat = " + JSON.stringify(Yn.TranscoderFormat),
            "let _BasisFormat = " + JSON.stringify(Yn.BasisFormat),
            "/* basis_transcoder.js */",
            r,
            "/* worker */",
            a.substring(a.indexOf("{") + 1, a.lastIndexOf("}")),
          ].join(`
`);
        (this.workerSourceURL = URL.createObjectURL(new Blob([l]))),
          (this.transcoderBinary = o),
          this.workerPool.setWorkerCreator(() => {
            const c = new Worker(this.workerSourceURL),
              h = this.transcoderBinary.slice(0);
            return (
              c.postMessage(
                {
                  type: "init",
                  config: this.workerConfig,
                  transcoderBinary: h,
                },
                [h]
              ),
              c
            );
          });
      })),
        $a > 0 &&
          console.warn(
            "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
          ),
        $a++;
    }
    return this.transcoderPending;
  }
  load(e, t, n, i) {
    if (this.workerConfig === null)
      throw new Error(
        "THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."
      );
    const r = new Pn(this.manager);
    r.setResponseType("arraybuffer"),
      r.setWithCredentials(this.withCredentials);
    const o = new fl();
    return (
      r.load(
        e,
        (a) => {
          if (Za.has(a)) return Za.get(a).promise.then(t).catch(i);
          this._createTexture([a])
            .then(function (l) {
              o.copy(l), (o.needsUpdate = !0), t && t(o);
            })
            .catch(i);
        },
        n,
        i
      ),
      o
    );
  }
  _createTextureFrom(e) {
    const {
      mipmaps: t,
      width: n,
      height: i,
      format: r,
      type: o,
      error: a,
      dfdTransferFn: l,
      dfdFlags: c,
    } = e;
    if (o === "error") return Promise.reject(a);
    const h = new fl(t, n, i, r, mi);
    return (
      (h.minFilter = t.length === 1 ? st : yi),
      (h.magFilter = st),
      (h.generateMipmaps = !1),
      (h.needsUpdate = !0),
      (h.encoding = l === ew ? it : an),
      (h.premultiplyAlpha = !!(c & tw)),
      h
    );
  }
  _createTexture(e, t = {}) {
    const n = t,
      i = this.init()
        .then(() =>
          this.workerPool.postMessage(
            { type: "transcode", buffers: e, taskConfig: n },
            e
          )
        )
        .then((r) => this._createTextureFrom(r.data));
    return Za.set(e[0], { promise: i }), i;
  }
  dispose() {
    return (
      this.workerPool.dispose(),
      this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
      $a--,
      this
    );
  }
}
Yn.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 };
Yn.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16,
};
Yn.EngineFormat = {
  RGBAFormat: Nt,
  RGBA_ASTC_4x4_Format: ol,
  RGBA_BPTC_Format: al,
  RGBA_ETC2_EAC_Format: sl,
  RGBA_PVRTC_4BPPV1_Format: il,
  RGBA_S3TC_DXT5_Format: wo,
  RGB_ETC1_Format: bu,
  RGB_ETC2_Format: rl,
  RGB_PVRTC_4BPPV1_Format: nl,
  RGB_S3TC_DXT1_Format: _o,
};
Yn.BasisWorker = function () {
  let s, e, t;
  const n = _EngineFormat,
    i = _TranscoderFormat,
    r = _BasisFormat;
  self.addEventListener("message", function (f) {
    const m = f.data;
    switch (m.type) {
      case "init":
        (s = m.config), o(m.transcoderBinary);
        break;
      case "transcode":
        e.then(() => {
          try {
            const {
                width: v,
                height: y,
                hasAlpha: p,
                mipmaps: g,
                format: w,
                dfdTransferFn: b,
                dfdFlags: _,
              } = a(m.buffers[0]),
              E = [];
            for (let L = 0; L < g.length; ++L) E.push(g[L].data.buffer);
            self.postMessage(
              {
                type: "transcode",
                id: m.id,
                width: v,
                height: y,
                hasAlpha: p,
                mipmaps: g,
                format: w,
                dfdTransferFn: b,
                dfdFlags: _,
              },
              E
            );
          } catch (v) {
            console.error(v),
              self.postMessage({ type: "error", id: m.id, error: v.message });
          }
        });
        break;
    }
  });
  function o(f) {
    e = new Promise((m) => {
      (t = { wasmBinary: f, onRuntimeInitialized: m }), BASIS(t);
    }).then(() => {
      t.initializeBasis(),
        t.KTX2File === void 0 &&
          console.warn(
            "THREE.KTX2Loader: Please update Basis Universal transcoder."
          );
    });
  }
  function a(f) {
    const m = new t.KTX2File(new Uint8Array(f));
    function v() {
      m.close(), m.delete();
    }
    if (!m.isValid())
      throw (
        (v(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file"))
      );
    const y = m.isUASTC() ? r.UASTC_4x4 : r.ETC1S,
      p = m.getWidth(),
      g = m.getHeight(),
      w = m.getLevels(),
      b = m.getHasAlpha(),
      _ = m.getDFDTransferFunc(),
      E = m.getDFDFlags(),
      { transcoderFormat: L, engineFormat: D } = u(y, p, g, b);
    if (!p || !g || !w)
      throw (v(), new Error("THREE.KTX2Loader:	Invalid texture"));
    if (!m.startTranscoding())
      throw (v(), new Error("THREE.KTX2Loader: .startTranscoding failed"));
    const V = [];
    for (let F = 0; F < w; F++) {
      const M = m.getImageLevelInfo(F, 0, 0),
        A = M.origWidth,
        N = M.origHeight,
        O = new Uint8Array(m.getImageTranscodedSizeInBytes(F, 0, 0, L));
      if (!m.transcodeImage(O, F, 0, 0, L, 0, -1, -1))
        throw (v(), new Error("THREE.KTX2Loader: .transcodeImage failed."));
      V.push({ data: O, width: A, height: N });
    }
    return (
      v(),
      {
        width: p,
        height: g,
        hasAlpha: b,
        mipmaps: V,
        format: D,
        dfdTransferFn: _,
        dfdFlags: E,
      }
    );
  }
  const l = [
      {
        if: "astcSupported",
        basisFormat: [r.UASTC_4x4],
        transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
        engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format],
        priorityETC1S: 1 / 0,
        priorityUASTC: 1,
        needsPowerOfTwo: !1,
      },
      {
        if: "bptcSupported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [i.BC7_M5, i.BC7_M5],
        engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format],
        priorityETC1S: 3,
        priorityUASTC: 2,
        needsPowerOfTwo: !1,
      },
      {
        if: "dxtSupported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [i.BC1, i.BC3],
        engineFormat: [n.RGB_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format],
        priorityETC1S: 4,
        priorityUASTC: 5,
        needsPowerOfTwo: !1,
      },
      {
        if: "etc2Supported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [i.ETC1, i.ETC2],
        engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format],
        priorityETC1S: 1,
        priorityUASTC: 3,
        needsPowerOfTwo: !1,
      },
      {
        if: "etc1Supported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [i.ETC1],
        engineFormat: [n.RGB_ETC1_Format],
        priorityETC1S: 2,
        priorityUASTC: 4,
        needsPowerOfTwo: !1,
      },
      {
        if: "pvrtcSupported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
        engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format],
        priorityETC1S: 5,
        priorityUASTC: 6,
        needsPowerOfTwo: !0,
      },
    ],
    c = l.sort(function (f, m) {
      return f.priorityETC1S - m.priorityETC1S;
    }),
    h = l.sort(function (f, m) {
      return f.priorityUASTC - m.priorityUASTC;
    });
  function u(f, m, v, y) {
    let p, g;
    const w = f === r.ETC1S ? c : h;
    for (let b = 0; b < w.length; b++) {
      const _ = w[b];
      if (
        !!s[_.if] &&
        !!_.basisFormat.includes(f) &&
        !(y && _.transcoderFormat.length < 2) &&
        !(_.needsPowerOfTwo && !(d(m) && d(v)))
      )
        return (
          (p = _.transcoderFormat[y ? 1 : 0]),
          (g = _.engineFormat[y ? 1 : 0]),
          { transcoderFormat: p, engineFormat: g }
        );
    }
    return (
      console.warn(
        "THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."
      ),
      (p = i.RGBA32),
      (g = n.RGBAFormat),
      { transcoderFormat: p, engineFormat: g }
    );
  }
  function d(f) {
    return f <= 2 ? !0 : (f & (f - 1)) === 0 && f !== 0;
  }
};
const hu = { type: "change" },
  Ka = { type: "start" },
  uu = { type: "end" };
class gw extends _i {
  constructor(e, t) {
    super();
    t === void 0 &&
      console.warn(
        'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
      ),
      t === document &&
        console.error(
          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
        ),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new P()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: Ui.ROTATE,
        MIDDLE: Ui.DOLLY,
        RIGHT: Ui.PAN,
      }),
      (this.touches = { ONE: zi.ROTATE, TWO: zi.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return a.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return a.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (U) {
        U.addEventListener("keydown", R), (this._domElementKeyEvents = U);
      }),
      (this.saveState = function () {
        n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom);
      }),
      (this.reset = function () {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(hu),
          n.update(),
          (r = i.NONE);
      }),
      (this.update = (function () {
        const U = new P(),
          fe = new Dt().setFromUnitVectors(e.up, new P(0, 1, 0)),
          Ce = fe.clone().invert(),
          Se = new P(),
          B = new Dt(),
          ve = 2 * Math.PI;
        return function () {
          const Ve = n.object.position;
          U.copy(Ve).sub(n.target),
            U.applyQuaternion(fe),
            a.setFromVector3(U),
            n.autoRotate && r === i.NONE && V(L()),
            n.enableDamping
              ? ((a.theta += l.theta * n.dampingFactor),
                (a.phi += l.phi * n.dampingFactor))
              : ((a.theta += l.theta), (a.phi += l.phi));
          let me = n.minAzimuthAngle,
            oe = n.maxAzimuthAngle;
          return (
            isFinite(me) &&
              isFinite(oe) &&
              (me < -Math.PI ? (me += ve) : me > Math.PI && (me -= ve),
              oe < -Math.PI ? (oe += ve) : oe > Math.PI && (oe -= ve),
              me <= oe
                ? (a.theta = Math.max(me, Math.min(oe, a.theta)))
                : (a.theta =
                    a.theta > (me + oe) / 2
                      ? Math.max(me, a.theta)
                      : Math.min(oe, a.theta))),
            (a.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, a.phi)
            )),
            a.makeSafe(),
            (a.radius *= c),
            (a.radius = Math.max(
              n.minDistance,
              Math.min(n.maxDistance, a.radius)
            )),
            n.enableDamping === !0
              ? n.target.addScaledVector(h, n.dampingFactor)
              : n.target.add(h),
            U.setFromSpherical(a),
            U.applyQuaternion(Ce),
            Ve.copy(n.target).add(U),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((l.theta *= 1 - n.dampingFactor),
                (l.phi *= 1 - n.dampingFactor),
                h.multiplyScalar(1 - n.dampingFactor))
              : (l.set(0, 0, 0), h.set(0, 0, 0)),
            (c = 1),
            u ||
            Se.distanceToSquared(n.object.position) > o ||
            8 * (1 - B.dot(n.object.quaternion)) > o
              ? (n.dispatchEvent(hu),
                Se.copy(n.object.position),
                B.copy(n.object.quaternion),
                (u = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.dispose = function () {
        n.domElement.removeEventListener("contextmenu", ce),
          n.domElement.removeEventListener("pointerdown", pe),
          n.domElement.removeEventListener("pointercancel", We),
          n.domElement.removeEventListener("wheel", ut),
          n.domElement.removeEventListener("pointermove", De),
          n.domElement.removeEventListener("pointerup", Ee),
          n._domElementKeyEvents !== null &&
            n._domElementKeyEvents.removeEventListener("keydown", R);
      });
    const n = this,
      i = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let r = i.NONE;
    const o = 1e-6,
      a = new Gh(),
      l = new Gh();
    let c = 1;
    const h = new P();
    let u = !1;
    const d = new ae(),
      f = new ae(),
      m = new ae(),
      v = new ae(),
      y = new ae(),
      p = new ae(),
      g = new ae(),
      w = new ae(),
      b = new ae(),
      _ = [],
      E = {};
    function L() {
      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function D() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function V(U) {
      l.theta -= U;
    }
    function F(U) {
      l.phi -= U;
    }
    const M = (function () {
        const U = new P();
        return function (Ce, Se) {
          U.setFromMatrixColumn(Se, 0), U.multiplyScalar(-Ce), h.add(U);
        };
      })(),
      A = (function () {
        const U = new P();
        return function (Ce, Se) {
          n.screenSpacePanning === !0
            ? U.setFromMatrixColumn(Se, 1)
            : (U.setFromMatrixColumn(Se, 0), U.crossVectors(n.object.up, U)),
            U.multiplyScalar(Ce),
            h.add(U);
        };
      })(),
      N = (function () {
        const U = new P();
        return function (Ce, Se) {
          const B = n.domElement;
          if (n.object.isPerspectiveCamera) {
            const ve = n.object.position;
            U.copy(ve).sub(n.target);
            let Te = U.length();
            (Te *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              M((2 * Ce * Te) / B.clientHeight, n.object.matrix),
              A((2 * Se * Te) / B.clientHeight, n.object.matrix);
          } else
            n.object.isOrthographicCamera
              ? (M(
                  (Ce * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    B.clientWidth,
                  n.object.matrix
                ),
                A(
                  (Se * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    B.clientHeight,
                  n.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (n.enablePan = !1));
        };
      })();
    function O(U) {
      n.object.isPerspectiveCamera
        ? (c /= U)
        : n.object.isOrthographicCamera
        ? ((n.object.zoom = Math.max(
            n.minZoom,
            Math.min(n.maxZoom, n.object.zoom * U)
          )),
          n.object.updateProjectionMatrix(),
          (u = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function H(U) {
      n.object.isPerspectiveCamera
        ? (c *= U)
        : n.object.isOrthographicCamera
        ? ((n.object.zoom = Math.max(
            n.minZoom,
            Math.min(n.maxZoom, n.object.zoom / U)
          )),
          n.object.updateProjectionMatrix(),
          (u = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function G(U) {
      d.set(U.clientX, U.clientY);
    }
    function W(U) {
      g.set(U.clientX, U.clientY);
    }
    function k(U) {
      v.set(U.clientX, U.clientY);
    }
    function Q(U) {
      f.set(U.clientX, U.clientY),
        m.subVectors(f, d).multiplyScalar(n.rotateSpeed);
      const fe = n.domElement;
      V((2 * Math.PI * m.x) / fe.clientHeight),
        F((2 * Math.PI * m.y) / fe.clientHeight),
        d.copy(f),
        n.update();
    }
    function ie(U) {
      w.set(U.clientX, U.clientY),
        b.subVectors(w, g),
        b.y > 0 ? O(D()) : b.y < 0 && H(D()),
        g.copy(w),
        n.update();
    }
    function re(U) {
      y.set(U.clientX, U.clientY),
        p.subVectors(y, v).multiplyScalar(n.panSpeed),
        N(p.x, p.y),
        v.copy(y),
        n.update();
    }
    function ee(U) {
      U.deltaY < 0 ? H(D()) : U.deltaY > 0 && O(D()), n.update();
    }
    function Me(U) {
      let fe = !1;
      switch (U.code) {
        case n.keys.UP:
          N(0, n.keyPanSpeed), (fe = !0);
          break;
        case n.keys.BOTTOM:
          N(0, -n.keyPanSpeed), (fe = !0);
          break;
        case n.keys.LEFT:
          N(n.keyPanSpeed, 0), (fe = !0);
          break;
        case n.keys.RIGHT:
          N(-n.keyPanSpeed, 0), (fe = !0);
          break;
      }
      fe && (U.preventDefault(), n.update());
    }
    function Be() {
      if (_.length === 1) d.set(_[0].pageX, _[0].pageY);
      else {
        const U = 0.5 * (_[0].pageX + _[1].pageX),
          fe = 0.5 * (_[0].pageY + _[1].pageY);
        d.set(U, fe);
      }
    }
    function Re() {
      if (_.length === 1) v.set(_[0].pageX, _[0].pageY);
      else {
        const U = 0.5 * (_[0].pageX + _[1].pageX),
          fe = 0.5 * (_[0].pageY + _[1].pageY);
        v.set(U, fe);
      }
    }
    function Z() {
      const U = _[0].pageX - _[1].pageX,
        fe = _[0].pageY - _[1].pageY,
        Ce = Math.sqrt(U * U + fe * fe);
      g.set(0, Ce);
    }
    function qe() {
      n.enableZoom && Z(), n.enablePan && Re();
    }
    function ke() {
      n.enableZoom && Z(), n.enableRotate && Be();
    }
    function Fe(U) {
      if (_.length == 1) f.set(U.pageX, U.pageY);
      else {
        const Ce = ne(U),
          Se = 0.5 * (U.pageX + Ce.x),
          B = 0.5 * (U.pageY + Ce.y);
        f.set(Se, B);
      }
      m.subVectors(f, d).multiplyScalar(n.rotateSpeed);
      const fe = n.domElement;
      V((2 * Math.PI * m.x) / fe.clientHeight),
        F((2 * Math.PI * m.y) / fe.clientHeight),
        d.copy(f);
    }
    function Ie(U) {
      if (_.length === 1) y.set(U.pageX, U.pageY);
      else {
        const fe = ne(U),
          Ce = 0.5 * (U.pageX + fe.x),
          Se = 0.5 * (U.pageY + fe.y);
        y.set(Ce, Se);
      }
      p.subVectors(y, v).multiplyScalar(n.panSpeed), N(p.x, p.y), v.copy(y);
    }
    function Ze(U) {
      const fe = ne(U),
        Ce = U.pageX - fe.x,
        Se = U.pageY - fe.y,
        B = Math.sqrt(Ce * Ce + Se * Se);
      w.set(0, B),
        b.set(0, Math.pow(w.y / g.y, n.zoomSpeed)),
        O(b.y),
        g.copy(w);
    }
    function K(U) {
      n.enableZoom && Ze(U), n.enablePan && Ie(U);
    }
    function de(U) {
      n.enableZoom && Ze(U), n.enableRotate && Fe(U);
    }
    function pe(U) {
      n.enabled !== !1 &&
        (_.length === 0 &&
          (n.domElement.setPointerCapture(U.pointerId),
          n.domElement.addEventListener("pointermove", De),
          n.domElement.addEventListener("pointerup", Ee)),
        _e(U),
        U.pointerType === "touch" ? T(U) : ze(U));
    }
    function De(U) {
      n.enabled !== !1 && (U.pointerType === "touch" ? te(U) : $e(U));
    }
    function Ee(U) {
      Le(U),
        _.length === 0 &&
          (n.domElement.releasePointerCapture(U.pointerId),
          n.domElement.removeEventListener("pointermove", De),
          n.domElement.removeEventListener("pointerup", Ee)),
        n.dispatchEvent(uu),
        (r = i.NONE);
    }
    function We(U) {
      Le(U);
    }
    function ze(U) {
      let fe;
      switch (U.button) {
        case 0:
          fe = n.mouseButtons.LEFT;
          break;
        case 1:
          fe = n.mouseButtons.MIDDLE;
          break;
        case 2:
          fe = n.mouseButtons.RIGHT;
          break;
        default:
          fe = -1;
      }
      switch (fe) {
        case Ui.DOLLY:
          if (n.enableZoom === !1) return;
          W(U), (r = i.DOLLY);
          break;
        case Ui.ROTATE:
          if (U.ctrlKey || U.metaKey || U.shiftKey) {
            if (n.enablePan === !1) return;
            k(U), (r = i.PAN);
          } else {
            if (n.enableRotate === !1) return;
            G(U), (r = i.ROTATE);
          }
          break;
        case Ui.PAN:
          if (U.ctrlKey || U.metaKey || U.shiftKey) {
            if (n.enableRotate === !1) return;
            G(U), (r = i.ROTATE);
          } else {
            if (n.enablePan === !1) return;
            k(U), (r = i.PAN);
          }
          break;
        default:
          r = i.NONE;
      }
      r !== i.NONE && n.dispatchEvent(Ka);
    }
    function $e(U) {
      if (n.enabled !== !1)
        switch (r) {
          case i.ROTATE:
            if (n.enableRotate === !1) return;
            Q(U);
            break;
          case i.DOLLY:
            if (n.enableZoom === !1) return;
            ie(U);
            break;
          case i.PAN:
            if (n.enablePan === !1) return;
            re(U);
            break;
        }
    }
    function ut(U) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        r !== i.NONE ||
        (U.preventDefault(), n.dispatchEvent(Ka), ee(U), n.dispatchEvent(uu));
    }
    function R(U) {
      n.enabled === !1 || n.enablePan === !1 || Me(U);
    }
    function T(U) {
      switch ((He(U), _.length)) {
        case 1:
          switch (n.touches.ONE) {
            case zi.ROTATE:
              if (n.enableRotate === !1) return;
              Be(), (r = i.TOUCH_ROTATE);
              break;
            case zi.PAN:
              if (n.enablePan === !1) return;
              Re(), (r = i.TOUCH_PAN);
              break;
            default:
              r = i.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case zi.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              qe(), (r = i.TOUCH_DOLLY_PAN);
              break;
            case zi.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              ke(), (r = i.TOUCH_DOLLY_ROTATE);
              break;
            default:
              r = i.NONE;
          }
          break;
        default:
          r = i.NONE;
      }
      r !== i.NONE && n.dispatchEvent(Ka);
    }
    function te(U) {
      switch ((He(U), r)) {
        case i.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          Fe(U), n.update();
          break;
        case i.TOUCH_PAN:
          if (n.enablePan === !1) return;
          Ie(U), n.update();
          break;
        case i.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          K(U), n.update();
          break;
        case i.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          de(U), n.update();
          break;
        default:
          r = i.NONE;
      }
    }
    function ce(U) {
      n.enabled !== !1 && U.preventDefault();
    }
    function _e(U) {
      _.push(U);
    }
    function Le(U) {
      delete E[U.pointerId];
      for (let fe = 0; fe < _.length; fe++)
        if (_[fe].pointerId == U.pointerId) {
          _.splice(fe, 1);
          return;
        }
    }
    function He(U) {
      let fe = E[U.pointerId];
      fe === void 0 && ((fe = new ae()), (E[U.pointerId] = fe)),
        fe.set(U.pageX, U.pageY);
    }
    function ne(U) {
      const fe = U.pointerId === _[0].pointerId ? _[1] : _[0];
      return E[fe.pointerId];
    }
    n.domElement.addEventListener("contextmenu", ce),
      n.domElement.addEventListener("pointerdown", pe),
      n.domElement.addEventListener("pointercancel", We),
      n.domElement.addEventListener("wheel", ut, { passive: !1 }),
      this.update();
  }
}
const Cr = {
  uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`,
};
class Xr {
  constructor() {
    (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1),
      (this.renderToScreen = !1);
  }
  setSize() {}
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
}
const nw = new Ni(-1, 1, 1, -1, 0, 1),
  mc = new tt();
mc.setAttribute("position", new Je([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
mc.setAttribute("uv", new Je([0, 2, 0, 0, 2, 0], 2));
class gc {
  constructor(e) {
    this._mesh = new jt(mc, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, nw);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class du extends Xr {
  constructor(e, t) {
    super();
    (this.textureID = t !== void 0 ? t : "tDiffuse"),
      e instanceof Vt
        ? ((this.uniforms = e.uniforms), (this.material = e))
        : e &&
          ((this.uniforms = vs.clone(e.uniforms)),
          (this.material = new Vt({
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
          }))),
      (this.fsQuad = new gc(this.material));
  }
  render(e, t, n) {
    this.uniforms[this.textureID] &&
      (this.uniforms[this.textureID].value = n.texture),
      (this.fsQuad.material = this.material),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(t),
          this.clear &&
            e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          this.fsQuad.render(e));
  }
}
class fu extends Xr {
  constructor(e, t) {
    super();
    (this.scene = e),
      (this.camera = t),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1);
  }
  render(e, t, n) {
    const i = e.getContext(),
      r = e.state;
    r.buffers.color.setMask(!1),
      r.buffers.depth.setMask(!1),
      r.buffers.color.setLocked(!0),
      r.buffers.depth.setLocked(!0);
    let o, a;
    this.inverse ? ((o = 0), (a = 1)) : ((o = 1), (a = 0)),
      r.buffers.stencil.setTest(!0),
      r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
      r.buffers.stencil.setFunc(i.ALWAYS, o, 4294967295),
      r.buffers.stencil.setClear(a),
      r.buffers.stencil.setLocked(!0),
      e.setRenderTarget(n),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      e.setRenderTarget(t),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      r.buffers.color.setLocked(!1),
      r.buffers.depth.setLocked(!1),
      r.buffers.stencil.setLocked(!1),
      r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
      r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
      r.buffers.stencil.setLocked(!0);
  }
}
class iw extends Xr {
  constructor() {
    super();
    this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class vw {
  constructor(e, t) {
    if (((this.renderer = e), t === void 0)) {
      const n = { minFilter: st, magFilter: st, format: Nt },
        i = e.getSize(new ae());
      (this._pixelRatio = e.getPixelRatio()),
        (this._width = i.width),
        (this._height = i.height),
        (t = new Bt(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio,
          n
        )),
        (t.texture.name = "EffectComposer.rt1");
    } else
      (this._pixelRatio = 1),
        (this._width = t.width),
        (this._height = t.height);
    (this.renderTarget1 = t),
      (this.renderTarget2 = t.clone()),
      (this.renderTarget2.texture.name = "EffectComposer.rt2"),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.renderToScreen = !0),
      (this.passes = []),
      Cr === void 0 &&
        console.error("THREE.EffectComposer relies on CopyShader"),
      du === void 0 &&
        console.error("THREE.EffectComposer relies on ShaderPass"),
      (this.copyPass = new du(Cr)),
      (this.clock = new ay());
  }
  swapBuffers() {
    const e = this.readBuffer;
    (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
  }
  addPass(e) {
    this.passes.push(e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled) return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let n = !1;
    for (let i = 0, r = this.passes.length; i < r; i++) {
      const o = this.passes[i];
      if (o.enabled !== !1) {
        if (
          ((o.renderToScreen =
            this.renderToScreen && this.isLastEnabledPass(i)),
          o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n),
          o.needsSwap)
        ) {
          if (n) {
            const a = this.renderer.getContext(),
              l = this.renderer.state.buffers.stencil;
            l.setFunc(a.NOTEQUAL, 1, 4294967295),
              this.copyPass.render(
                this.renderer,
                this.writeBuffer,
                this.readBuffer,
                e
              ),
              l.setFunc(a.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        fu !== void 0 &&
          (o instanceof fu ? (n = !0) : o instanceof iw && (n = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new ae());
      (this._pixelRatio = this.renderer.getPixelRatio()),
        (this._width = t.width),
        (this._height = t.height),
        (e = this.renderTarget1.clone()),
        e.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      (this.renderTarget1 = e),
      (this.renderTarget2 = e.clone()),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2);
  }
  setSize(e, t) {
    (this._width = e), (this._height = t);
    const n = this._width * this._pixelRatio,
      i = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
    for (let r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i);
  }
  setPixelRatio(e) {
    (this._pixelRatio = e), this.setSize(this._width, this._height);
  }
}
new Ni(-1, 1, 1, -1, 0, 1);
const df = new tt();
df.setAttribute("position", new Je([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
df.setAttribute("uv", new Je([0, 2, 0, 0, 2, 0], 2));
class xw extends Xr {
  constructor(e, t, n, i, r) {
    super();
    (this.scene = e),
      (this.camera = t),
      (this.overrideMaterial = n),
      (this.clearColor = i),
      (this.clearAlpha = r !== void 0 ? r : 0),
      (this.clear = !0),
      (this.clearDepth = !1),
      (this.needsSwap = !1),
      (this._oldClearColor = new ye());
  }
  render(e, t, n) {
    const i = e.autoClear;
    e.autoClear = !1;
    let r, o;
    this.overrideMaterial !== void 0 &&
      ((o = this.scene.overrideMaterial),
      (this.scene.overrideMaterial = this.overrideMaterial)),
      this.clearColor &&
        (e.getClearColor(this._oldClearColor),
        (r = e.getClearAlpha()),
        e.setClearColor(this.clearColor, this.clearAlpha)),
      this.clearDepth && e.clearDepth(),
      e.setRenderTarget(this.renderToScreen ? null : n),
      this.clear &&
        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
      e.render(this.scene, this.camera),
      this.clearColor && e.setClearColor(this._oldClearColor, r),
      this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = o),
      (e.autoClear = i);
  }
}
const pu = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new ye(0) },
    defaultOpacity: { value: 0 },
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`,
};
class As extends Xr {
  constructor(e, t, n, i) {
    super();
    (this.strength = t !== void 0 ? t : 1),
      (this.radius = n),
      (this.threshold = i),
      (this.resolution = e !== void 0 ? new ae(e.x, e.y) : new ae(256, 256)),
      (this.clearColor = new ye(0, 0, 0));
    const r = { minFilter: st, magFilter: st, format: Nt };
    (this.renderTargetsHorizontal = []),
      (this.renderTargetsVertical = []),
      (this.nMips = 5);
    let o = Math.round(this.resolution.x / 2),
      a = Math.round(this.resolution.y / 2);
    (this.renderTargetBright = new Bt(o, a, r)),
      (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"),
      (this.renderTargetBright.texture.generateMipmaps = !1);
    for (let d = 0; d < this.nMips; d++) {
      const f = new Bt(o, a, r);
      (f.texture.name = "UnrealBloomPass.h" + d),
        (f.texture.generateMipmaps = !1),
        this.renderTargetsHorizontal.push(f);
      const m = new Bt(o, a, r);
      (m.texture.name = "UnrealBloomPass.v" + d),
        (m.texture.generateMipmaps = !1),
        this.renderTargetsVertical.push(m),
        (o = Math.round(o / 2)),
        (a = Math.round(a / 2));
    }
    pu === void 0 &&
      console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
    const l = pu;
    (this.highPassUniforms = vs.clone(l.uniforms)),
      (this.highPassUniforms.luminosityThreshold.value = i),
      (this.highPassUniforms.smoothWidth.value = 0.01),
      (this.materialHighPassFilter = new Vt({
        uniforms: this.highPassUniforms,
        vertexShader: l.vertexShader,
        fragmentShader: l.fragmentShader,
        defines: {},
      })),
      (this.separableBlurMaterials = []);
    const c = [3, 5, 7, 9, 11];
    (o = Math.round(this.resolution.x / 2)),
      (a = Math.round(this.resolution.y / 2));
    for (let d = 0; d < this.nMips; d++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(c[d])),
        (this.separableBlurMaterials[d].uniforms.texSize.value = new ae(o, a)),
        (o = Math.round(o / 2)),
        (a = Math.round(a / 2));
    (this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
      (this.compositeMaterial.uniforms.blurTexture1.value =
        this.renderTargetsVertical[0].texture),
      (this.compositeMaterial.uniforms.blurTexture2.value =
        this.renderTargetsVertical[1].texture),
      (this.compositeMaterial.uniforms.blurTexture3.value =
        this.renderTargetsVertical[2].texture),
      (this.compositeMaterial.uniforms.blurTexture4.value =
        this.renderTargetsVertical[3].texture),
      (this.compositeMaterial.uniforms.blurTexture5.value =
        this.renderTargetsVertical[4].texture),
      (this.compositeMaterial.uniforms.bloomStrength.value = t),
      (this.compositeMaterial.uniforms.bloomRadius.value = 0.1),
      (this.compositeMaterial.needsUpdate = !0);
    const h = [1, 0.8, 0.6, 0.4, 0.2];
    (this.compositeMaterial.uniforms.bloomFactors.value = h),
      (this.bloomTintColors = [
        new P(1, 1, 1),
        new P(1, 1, 1),
        new P(1, 1, 1),
        new P(1, 1, 1),
        new P(1, 1, 1),
      ]),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      Cr === void 0 &&
        console.error("THREE.UnrealBloomPass relies on CopyShader");
    const u = Cr;
    (this.copyUniforms = vs.clone(u.uniforms)),
      (this.copyUniforms.opacity.value = 1),
      (this.materialCopy = new Vt({
        uniforms: this.copyUniforms,
        vertexShader: u.vertexShader,
        fragmentShader: u.fragmentShader,
        blending: To,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new ye()),
      (this.oldClearAlpha = 1),
      (this.basic = new Rn()),
      (this.fsQuad = new gc(null));
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
  }
  setSize(e, t) {
    let n = Math.round(e / 2),
      i = Math.round(t / 2);
    this.renderTargetBright.setSize(n, i);
    for (let r = 0; r < this.nMips; r++)
      this.renderTargetsHorizontal[r].setSize(n, i),
        this.renderTargetsVertical[r].setSize(n, i),
        (this.separableBlurMaterials[r].uniforms.texSize.value = new ae(n, i)),
        (n = Math.round(n / 2)),
        (i = Math.round(i / 2));
  }
  render(e, t, n, i, r) {
    e.getClearColor(this._oldClearColor),
      (this.oldClearAlpha = e.getClearAlpha());
    const o = e.autoClear;
    (e.autoClear = !1),
      e.setClearColor(this.clearColor, 0),
      r && e.state.buffers.stencil.setTest(!1),
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = n.texture),
        e.setRenderTarget(null),
        e.clear(),
        this.fsQuad.render(e)),
      (this.highPassUniforms.tDiffuse.value = n.texture),
      (this.highPassUniforms.luminosityThreshold.value = this.threshold),
      (this.fsQuad.material = this.materialHighPassFilter),
      e.setRenderTarget(this.renderTargetBright),
      e.clear(),
      this.fsQuad.render(e);
    let a = this.renderTargetBright;
    for (let l = 0; l < this.nMips; l++)
      (this.fsQuad.material = this.separableBlurMaterials[l]),
        (this.separableBlurMaterials[l].uniforms.colorTexture.value =
          a.texture),
        (this.separableBlurMaterials[l].uniforms.direction.value =
          As.BlurDirectionX),
        e.setRenderTarget(this.renderTargetsHorizontal[l]),
        e.clear(),
        this.fsQuad.render(e),
        (this.separableBlurMaterials[l].uniforms.colorTexture.value =
          this.renderTargetsHorizontal[l].texture),
        (this.separableBlurMaterials[l].uniforms.direction.value =
          As.BlurDirectionY),
        e.setRenderTarget(this.renderTargetsVertical[l]),
        e.clear(),
        this.fsQuad.render(e),
        (a = this.renderTargetsVertical[l]);
    (this.fsQuad.material = this.compositeMaterial),
      (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
      (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      e.setRenderTarget(this.renderTargetsHorizontal[0]),
      e.clear(),
      this.fsQuad.render(e),
      (this.fsQuad.material = this.materialCopy),
      (this.copyUniforms.tDiffuse.value =
        this.renderTargetsHorizontal[0].texture),
      r && e.state.buffers.stencil.setTest(!0),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(n), this.fsQuad.render(e)),
      e.setClearColor(this._oldClearColor, this.oldClearAlpha),
      (e.autoClear = o);
  }
  getSeperableBlurMaterial(e) {
    return new Vt({
      defines: { KERNEL_RADIUS: e, SIGMA: e },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new ae(0.5, 0.5) },
        direction: { value: new ae(0.5, 0.5) },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`,
    });
  }
  getCompositeMaterial(e) {
    return new Vt({
      defines: { NUM_MIPS: e },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        dirtTexture: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`,
    });
  }
}
As.BlurDirectionX = new ae(1, 0);
As.BlurDirectionY = new ae(0, 1);
class rw extends Xr {
  constructor(e, t, n, i) {
    super();
    (this.scene = e),
      (this.camera = t),
      (this.sampleLevel = 4),
      (this.unbiased = !0),
      (this.clearColor = n !== void 0 ? n : 0),
      (this.clearAlpha = i !== void 0 ? i : 0),
      (this._oldClearColor = new ye()),
      Cr === void 0 &&
        console.error("THREE.SSAARenderPass relies on CopyShader");
    const r = Cr;
    (this.copyUniforms = vs.clone(r.uniforms)),
      (this.copyMaterial = new Vt({
        uniforms: this.copyUniforms,
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        premultipliedAlpha: !0,
        transparent: !0,
        blending: To,
        depthTest: !1,
        depthWrite: !1,
      })),
      (this.fsQuad = new gc(this.copyMaterial));
  }
  dispose() {
    this.sampleRenderTarget &&
      (this.sampleRenderTarget.dispose(), (this.sampleRenderTarget = null));
  }
  setSize(e, t) {
    this.sampleRenderTarget && this.sampleRenderTarget.setSize(e, t);
  }
  render(e, t, n) {
    this.sampleRenderTarget ||
      ((this.sampleRenderTarget = new Bt(n.width, n.height, {
        minFilter: st,
        magFilter: st,
        format: Nt,
      })),
      (this.sampleRenderTarget.texture.name = "SSAARenderPass.sample"));
    const i = sw[Math.max(0, Math.min(this.sampleLevel, 5))],
      r = e.autoClear;
    (e.autoClear = !1), e.getClearColor(this._oldClearColor);
    const o = e.getClearAlpha(),
      a = 1 / i.length,
      l = 1 / 32;
    this.copyUniforms.tDiffuse.value = this.sampleRenderTarget.texture;
    const c = {
        fullWidth: n.width,
        fullHeight: n.height,
        offsetX: 0,
        offsetY: 0,
        width: n.width,
        height: n.height,
      },
      h = Object.assign({}, this.camera.view);
    h.enabled && Object.assign(c, h);
    for (let u = 0; u < i.length; u++) {
      const d = i[u];
      this.camera.setViewOffset &&
        this.camera.setViewOffset(
          c.fullWidth,
          c.fullHeight,
          c.offsetX + d[0] * 0.0625,
          c.offsetY + d[1] * 0.0625,
          c.width,
          c.height
        );
      let f = a;
      if (this.unbiased) {
        const m = -0.5 + (u + 0.5) / i.length;
        f += l * m;
      }
      (this.copyUniforms.opacity.value = f),
        e.setClearColor(this.clearColor, this.clearAlpha),
        e.setRenderTarget(this.sampleRenderTarget),
        e.clear(),
        e.render(this.scene, this.camera),
        e.setRenderTarget(this.renderToScreen ? null : t),
        u === 0 && (e.setClearColor(0, 0), e.clear()),
        this.fsQuad.render(e);
    }
    this.camera.setViewOffset && h.enabled
      ? this.camera.setViewOffset(
          h.fullWidth,
          h.fullHeight,
          h.offsetX,
          h.offsetY,
          h.width,
          h.height
        )
      : this.camera.clearViewOffset && this.camera.clearViewOffset(),
      (e.autoClear = r),
      e.setClearColor(this._oldClearColor, o);
  }
}
const sw = [
  [[0, 0]],
  [
    [4, 4],
    [-4, -4],
  ],
  [
    [-2, -6],
    [6, -2],
    [-6, 2],
    [2, 6],
  ],
  [
    [1, -3],
    [-1, 3],
    [5, 1],
    [-3, -5],
    [-5, 5],
    [-7, -1],
    [3, 7],
    [7, -7],
  ],
  [
    [1, 1],
    [-1, -3],
    [-3, 2],
    [4, -1],
    [-5, -2],
    [2, 5],
    [5, 3],
    [3, -5],
    [-2, 6],
    [0, -7],
    [-4, -6],
    [-6, 4],
    [-8, 0],
    [7, -4],
    [6, 7],
    [-7, -8],
  ],
  [
    [-4, -7],
    [-7, -5],
    [-3, -5],
    [-5, -4],
    [-1, -4],
    [-2, -2],
    [-6, -1],
    [-4, 0],
    [-7, 1],
    [-1, 2],
    [-6, 3],
    [-3, 3],
    [-7, 6],
    [-3, 6],
    [-5, 7],
    [-1, 7],
    [5, -7],
    [1, -6],
    [6, -5],
    [4, -4],
    [2, -3],
    [7, -2],
    [1, -1],
    [4, -1],
    [2, 1],
    [6, 2],
    [0, 4],
    [4, 4],
    [2, 5],
    [7, 5],
    [5, 6],
    [3, 7],
  ],
];
class yw extends rw {
  constructor(e, t, n, i) {
    super(e, t, n, i);
    (this.sampleLevel = 0), (this.accumulate = !1);
  }
  render(e, t, n, i) {
    if (this.accumulate === !1) {
      super.render(e, t, n, i), (this.accumulateIndex = -1);
      return;
    }
    const r = ow[5];
    this.sampleRenderTarget === void 0 &&
      ((this.sampleRenderTarget = new Bt(n.width, n.height, this.params)),
      (this.sampleRenderTarget.texture.name = "TAARenderPass.sample")),
      this.holdRenderTarget === void 0 &&
        ((this.holdRenderTarget = new Bt(n.width, n.height, this.params)),
        (this.holdRenderTarget.texture.name = "TAARenderPass.hold")),
      this.accumulateIndex === -1 &&
        (super.render(e, this.holdRenderTarget, n, i),
        (this.accumulateIndex = 0));
    const o = e.autoClear;
    e.autoClear = !1;
    const a = 1 / r.length;
    if (this.accumulateIndex >= 0 && this.accumulateIndex < r.length) {
      (this.copyUniforms.opacity.value = a),
        (this.copyUniforms.tDiffuse.value = t.texture);
      const c = Math.pow(2, this.sampleLevel);
      for (let h = 0; h < c; h++) {
        const u = this.accumulateIndex,
          d = r[u];
        if (
          (this.camera.setViewOffset &&
            this.camera.setViewOffset(
              n.width,
              n.height,
              d[0] * 0.0625,
              d[1] * 0.0625,
              n.width,
              n.height
            ),
          e.setRenderTarget(t),
          e.clear(),
          e.render(this.scene, this.camera),
          e.setRenderTarget(this.sampleRenderTarget),
          this.accumulateIndex === 0 && e.clear(),
          this.fsQuad.render(e),
          this.accumulateIndex++,
          this.accumulateIndex >= r.length)
        )
          break;
      }
      this.camera.clearViewOffset && this.camera.clearViewOffset();
    }
    const l = this.accumulateIndex * a;
    l > 0 &&
      ((this.copyUniforms.opacity.value = 1),
      (this.copyUniforms.tDiffuse.value = this.sampleRenderTarget.texture),
      e.setRenderTarget(t),
      e.clear(),
      this.fsQuad.render(e)),
      l < 1 &&
        ((this.copyUniforms.opacity.value = 1 - l),
        (this.copyUniforms.tDiffuse.value = this.holdRenderTarget.texture),
        e.setRenderTarget(t),
        l === 0 && e.clear(),
        this.fsQuad.render(e)),
      (e.autoClear = o);
  }
}
const ow = [
  [[0, 0]],
  [
    [4, 4],
    [-4, -4],
  ],
  [
    [-2, -6],
    [6, -2],
    [-6, 2],
    [2, 6],
  ],
  [
    [1, -3],
    [-1, 3],
    [5, 1],
    [-3, -5],
    [-5, 5],
    [-7, -1],
    [3, 7],
    [7, -7],
  ],
  [
    [1, 1],
    [-1, -3],
    [-3, 2],
    [4, -1],
    [-5, -2],
    [2, 5],
    [5, 3],
    [3, -5],
    [-2, 6],
    [0, -7],
    [-4, -6],
    [-6, 4],
    [-8, 0],
    [7, -4],
    [6, 7],
    [-7, -8],
  ],
  [
    [-4, -7],
    [-7, -5],
    [-3, -5],
    [-5, -4],
    [-1, -4],
    [-2, -2],
    [-6, -1],
    [-4, 0],
    [-7, 1],
    [-1, 2],
    [-6, 3],
    [-3, 3],
    [-7, 6],
    [-3, 6],
    [-5, 7],
    [-1, 7],
    [5, -7],
    [1, -6],
    [6, -5],
    [4, -4],
    [2, -3],
    [7, -2],
    [1, -1],
    [4, -1],
    [2, 1],
    [6, 2],
    [0, 4],
    [4, 4],
    [2, 5],
    [7, 5],
    [5, 6],
    [3, 7],
  ],
];
export {
  kf as A,
  Cs as B,
  zf as C,
  fw as D,
  mw as E,
  dw as F,
  Md as G,
  Li as H,
  Yu as I,
  id as J,
  Kl as K,
  st as L,
  Fr as M,
  hi as N,
  gw as O,
  Yt as P,
  aw as Q,
  pw as R,
  hw as S,
  At as T,
  As as U,
  ae as V,
  Bt as W,
  lw as X,
  Qe as Y,
  mt as Z,
  cw as _,
  uw as a,
  xw as b,
  yw as c,
  du as d,
  Nt as e,
  vw as f,
  Of as g,
  Uf as h,
  Hy as i,
  ye as j,
  mx as k,
  yu as l,
  pi as m,
  Vt as n,
  Ln as o,
  jt as p,
  qu as q,
  Rn as r,
  at as s,
  yi as t,
  it as u,
  an as v,
  Zt as w,
  Jc as x,
  Vu as y,
  ty as z,
};
//# sourceMappingURL=vendor.fbd047fa.js.map
